[{"repository":"mbassador","sha1":"e7a76287cb4e9019a2f977240b6d7aa16fea8fe9","url":"https://github.com/bennidi/mbassador/commit/e7a76287cb4e9019a2f977240b6d7aa16fea8fe9","preChangeSourceCode":{"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.events.TestEvent2;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Filter;\nimport net.engio.mbassy.listener.Filters;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Listener(delivery = Mode.Sequential)\n    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestEvent event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n            TestEvent2 event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n    }\n\n    @Listener(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestEvent event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n            TestEvent2 event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.listener.*;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Listener\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, delivery = Mode.Concurrent)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Listener(\n            priority = 10,\n            delivery = Mode.Sequential,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include all (inherited) methods directly annotated using @Listener)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for(Method handler : allHandlers){\n            if(!ReflectionUtils.containsOverridingMethod(allHandlers, handler)){\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n\n        List<MessageHandlerMetadata>  filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Listener annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for(Method handler : bottomMostHandlers){\n            Listener listener = handler.getAnnotation(Listener.class);\n            if(!listener.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(listener), listener);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if(handler == null || handler.getAnnotation(Listener.class) == null){\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/MethodDispatchTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Listener;\nimport org.junit.Test;\n\n/**\n * Very simple test to verify dispatch to correct message handler\n *\n * @author bennidi\n *         Date: 1/17/13\n */\npublic class MethodDispatchTest extends UnitTest{\n\n   private boolean listener1Called = false;\n   private boolean listener2Called = false;\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Listener\n        public void handleString(String s) {\n             listener1Called = true;\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n           listener2Called = true;\n        }\n\n    }\n\n    @Test\n    public void testDispatch1(){\n        MBassador bus = new MBassador(BusConfiguration.Default());\n        EventListener2 listener2 = new EventListener2();\n        bus.subscribe(listener2);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener2Called);\n        assertFalse(listener1Called);\n\n        EventListener1 listener1 = new EventListener1();\n        bus.subscribe(listener1);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener1Called);\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/NonListeningBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.listener.Listener;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should not be considered a message listener\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    @Listener(enabled = false)\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Listener(enabled = false)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Listener(enabled = false)\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.dispatch.SubscriptionContext;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isEnveloped()){\n          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n       }\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/net/engio/mbassy/common/PublicationEvent.java":"package net.engio.mbassy.common;\n\n/**\n * A wrapped event is created when various conditions are matched (these depend on the concrete\n * (sub)type of wrapped event).\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic abstract class PublicationEvent {\n\n    private Object event;\n\n    public PublicationEvent(Object message) {\n        this.event = message;\n    }\n\n    public Object getEvent() {\n        return event;\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Enveloped.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Configure a handler to receive an enveloped message as a wrapper around the source\n * message. An enveloped message can be\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Enveloped {\n\n    /**\n     * The set of messages that should be dispatched to the message handler\n     */\n\tClass[] messages();\n\n\n}\n","src/main/java/net/engio/mbassy/listener/Filter.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * THe filter annotation is used to add filters to message listeners.\n * It references a class that implements the MessageFilter interface.\n * The object filter will be used to check whether a message should be delivered\n * to the message listener or not.\n *\n * <p/>\n * @author  bennidi\n * Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n\tClass<? extends IMessageFilter> value();\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class,\n        DeadEventTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/DeadEventTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Listener;\nimport org.junit.Test;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEventTest extends UnitTest{\n\n\n    @Test\n    public void testDeadEvent(){\n        MBassador bus = new MBassador(BusConfiguration.Default());\n        DeadEventHandler deadEventHandler = new DeadEventHandler();\n        bus.subscribe(deadEventHandler);\n        assertEquals(0, deadEventHandler.getDeadEventCount());\n        bus.post(new Object()).now();\n        assertEquals(1, deadEventHandler.getDeadEventCount());\n        bus.post(323).now();\n        assertEquals(2, deadEventHandler.getDeadEventCount());\n        bus.publish(\"fkdfdk\");\n        assertEquals(3, deadEventHandler.getDeadEventCount());\n    }\n\n    public class DeadEventHandler{\n\n         private ConcurrentSet deadEvents = new ConcurrentSet();\n\n        @Listener\n         public void handle(DeadEvent event){\n             deadEvents.add(event);\n         }\n\n\n        public int getDeadEventCount(){\n            return deadEvents.size();\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<EventListener1> listener = reader.getMessageListener(EventListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<EventListener2> listener = reader.getMessageListener(EventListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<EventListener3> listener = reader.getMessageListener(EventListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Listener(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Listener\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Listener\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EventListener3 extends EventListener2 {\n\n        // narrow the handler\n        @Listener(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Listener(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Listener(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Listener\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Listener\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n *\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher{\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":"package net.engio.mbassy.dispatch;\n\n/**\n * This interface marks components that have access to the subscription context.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface ISubscriptionContextAware extends IMessageBusAware {\n\n    /**\n     * Get the subscription context associated with this object\n     *\n     * @return\n     */\n    public SubscriptionContext getContext();\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n *\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n *\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message The message that should be delivered to the listeners\n     * @param listeners The listeners that should receive the message\n     */\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the message to each\n     * listener\n     * @return\n     */\n    public IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\nimport net.engio.mbassy.dispatch.SubscriptionContext;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private SubscriptionContext context;\n\n    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType){\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message){\n          dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.IMessageBus;\nimport net.engio.mbassy.dispatch.ISubscriptionContextAware;\nimport net.engio.mbassy.dispatch.SubscriptionContext;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware implements ISubscriptionContextAware{\n\n    private SubscriptionContext context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext getContext() {\n        return context;\n    }\n\n    @Override\n    public IMessageBus getBus() {\n        return context.getOwningBus();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error){\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for(IPublicationErrorHandler handler : handlers){\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler){\n        try {\n            handler.invoke(listener, message);\n        }catch(IllegalAccessException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        }\n        catch(IllegalArgumentException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        }\n        catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        }\n        catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Listener(delivery = Mode.Sequential)\n    public void handleSubTestEvent(SubTestEvent event) {\n        super.handleSubTestEvent(event);\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Filters.java":"package net.engio.mbassy.listener;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class Filters {\n\n    public static final class AllowAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return false;\n        }\n    }\n\n\n    public static final class RejectSubtypes implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            for(Class handledMessage : metadata.getHandledMessages()){\n                if(handledMessage.equals(event.getClass()))return true;\n            }\n            return false;\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/common/TestUtil.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.IMessageBus;\n\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class TestUtil {\n\n\n    public static void setup(final IMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n        Runnable[] setupUnits = new Runnable[numberOfThreads];\n        int partitionSize;\n        if(listeners.size() >= numberOfThreads){\n          partitionSize =  (int)Math.floor(listeners.size() / numberOfThreads);\n        }\n        else{\n            partitionSize = 1;\n            numberOfThreads = listeners.size();\n        }\n\n        for(int i = 0; i < numberOfThreads; i++){\n            final int partitionStart = i * partitionSize;\n            final int partitionEnd = (i+1 < numberOfThreads)\n                    ? partitionStart + partitionSize + 1\n                    : listeners.size();\n            setupUnits[i] = new Runnable() {\n\n                private List<Object> listenerSubset = listeners.subList(partitionStart, partitionEnd);\n\n                public void run() {\n                   for(Object listener : listenerSubset){\n                       bus.subscribe(listener);\n                   }\n                }\n            };\n\n        }\n\n        ConcurrentExecutor.runConcurrent(setupUnits);\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport java.lang.reflect.Method;\n\nimport net.engio.mbassy.IMessageBus;\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n *\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        publication.markDelivered();\n        for(Object listener: listeners){\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        }\n        else {\n            for (int i = 0; i < filter.length; i++) {\n                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) return false;\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n         if(passesFilter(message)){\n             getDelegate().dispatch(publication, message, listeners);\n         }\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport java.util.List;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.listener.Filter;\nimport net.engio.mbassy.listener.Filters;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport net.engio.mbassy.listeners.NonListeningBean;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends UnitTest {\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subTestEvent = new SubTestEvent();\n\n        bus.post(event).now();\n        bus.post(subTestEvent).now();\n\n        assertEquals(100, event.counter.get());\n        assertEquals(0, subTestEvent.counter.get());\n\n    }\n\n\n    public static class FilteredMessageListener{\n\n        @Listener(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestEvent(TestEvent event){\n            event.counter.incrementAndGet();\n        }\n\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation extends ISubscriptionContextAware {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    public void invoke(final Object listener, final Object message);\n\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !listenerConfig.rejectSubtypes();\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType){\n        for(Class<?> handledMessage : handledMessages){\n            if(handledMessage.equals(messageType))return true;\n            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes(){\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return listenerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IMessageBus;\n\n/**\n * This interface marks components that have access to the message bus that they belong to.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface IMessageBusAware {\n\n    public IMessageBus getBus();\n}\n","src/test/java/net/engio/mbassy/MessagePublicationTest.java":"package net.engio.mbassy;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.events.TestEvent2;\nimport net.engio.mbassy.listeners.EventingTestBean;\nimport net.engio.mbassy.listeners.EventingTestBean2;\nimport net.engio.mbassy.listeners.EventingTestBean3;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport net.engio.mbassy.listeners.MultiEventHandler;\nimport net.engio.mbassy.listeners.NonListeningBean;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MessagePublicationTest extends UnitTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class)\n                .create(10000, MultiEventHandler.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n        TestEvent2 event2 = new TestEvent2();\n\n        bus.publishAsync(event);\n        bus.publishAsync(subEvent);\n        bus.publishAsync(event2);\n\n        pause(processingTimeInMS);\n\n        assertEquals(50000, event.counter.get());\n        assertEquals(80000, subEvent.counter.get());\n        assertEquals(20000, event2.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publish(event);\n        bus.publish(subEvent);\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, event.counter.get());\n        assertEquals(70000, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n            }\n        }, 10);\n\n        pause(processingTimeInMS);\n\n        for (TestEvent event : testEvents) {\n            assertEquals(30000, event.counter.get());\n        }\n\n        for (SubTestEvent event : subtestEvents) {\n            assertEquals(70000, event.counter.get());\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, delivery = Mode.Sequential)\n    public void handleSubTestEventAgain(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Filter;\nimport net.engio.mbassy.listener.Filters;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Mode;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Handler(delivery = Mode.Sequential)\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n    @Handler(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.*;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Handler\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Mode.Concurrent)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Handler(\n            priority = 10,\n            delivery = Mode.Sequential,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Handler config = messageHandler.getAnnotation(Handler.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for(Method handler : allHandlers){\n            if(!ReflectionUtils.containsOverridingMethod(allHandlers, handler)){\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n\n        List<MessageHandlerMetadata>  filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for(Method handler : bottomMostHandlers){\n            Handler handle = handler.getAnnotation(Handler.class);\n            if(!handle.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handle), handle);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if(handler == null || handler.getAnnotation(Handler.class) == null){\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/MethodDispatchTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Very simple test to verify dispatch to correct message handler\n *\n * @author bennidi\n *         Date: 1/17/13\n */\npublic class MethodDispatchTest extends MessageBusTest{\n\n   private boolean listener1Called = false;\n   private boolean listener2Called = false;\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Handler\n        public void handleString(String s) {\n             listener1Called = true;\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n           listener2Called = true;\n        }\n\n    }\n\n    @Test\n    public void testDispatch1(){\n        IMessageBus bus = getBus(BusConfiguration.Default());\n        EventListener2 listener2 = new EventListener2();\n        bus.subscribe(listener2);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener2Called);\n        assertFalse(listener1Called);\n\n        EventListener1 listener1 = new EventListener1();\n        bus.subscribe(listener1);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener1Called);\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/NonListeningBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.Handler;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should not be considered a message listener\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    @Handler(enabled = false)\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Handler(enabled = false)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Handler(enabled = false)\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.dispatch.*;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isEnveloped()){\n          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n       }\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/net/engio/mbassy/common/PublicationEvent.java":"package net.engio.mbassy.common;\n\n/**\n * A wrapped event is created when various conditions are matched (these depend on the concrete\n * (sub)type of wrapped event).\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic abstract class PublicationEvent {\n\n    private Object event;\n\n    public PublicationEvent(Object message) {\n        this.event = message;\n    }\n\n    public Object getMessage() {\n        return event;\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Enveloped.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Configure a handler to receive an enveloped message as a wrapper around the source\n * message. An enveloped message can contain any type of message\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Enveloped {\n\n    /**\n     * The set of messages that should be dispatched to the message handler\n     */\n\tClass[] messages();\n\n\n}\n","src/main/java/net/engio/mbassy/listener/Filter.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * The filter annotation is used to add filters to message listeners.\n * It references a class that implements the IMessageFilter interface.\n * The filter will be used to check whether a message should be delivered\n * to the listener or not.\n *\n * <p/>\n * @author  bennidi\n * Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n    /**\n     * The class that implements the filter.\n     * Note: A filter always needs to provide a non-arg constructor\n     * @return\n     */\n\tClass<? extends IMessageFilter> value();\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.ListenerSubscriptionTest;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class,\n        DeadEventTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/DeadEventTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEventTest extends MessageBusTest{\n\n\n    @Test\n    public void testDeadEvent(){\n        MBassador bus = getBus(BusConfiguration.Default());\n        DeadEventHandler deadEventHandler = new DeadEventHandler();\n        bus.subscribe(deadEventHandler);\n        assertEquals(0, deadEventHandler.getDeadEventCount());\n        bus.post(new Object()).now();\n        assertEquals(1, deadEventHandler.getDeadEventCount());\n        bus.post(323).now();\n        assertEquals(2, deadEventHandler.getDeadEventCount());\n        bus.publish(\"fkdfdk\");\n        assertEquals(3, deadEventHandler.getDeadEventCount());\n    }\n\n    public class DeadEventHandler{\n\n         private ConcurrentSet deadEvents = new ConcurrentSet();\n\n        @Handler\n         public void handle(DeadMessage message){\n             deadEvents.add(message);\n         }\n\n\n        public int getDeadEventCount(){\n            return deadEvents.size();\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<EventListener1> listener = reader.getMessageListener(EventListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<EventListener2> listener = reader.getMessageListener(EventListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<EventListener3> listener = reader.getMessageListener(EventListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EventListener3 extends EventListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n *\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher{\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * This interface marks components that have access to the subscription context.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface ISubscriptionContextAware extends IMessageBusAware {\n\n    /**\n     * Get the subscription context associated with this object\n     *\n     * @return\n     */\n    public SubscriptionContext getContext();\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n *\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n *\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message The message that should be delivered to the listeners\n     * @param listeners The listeners that should receive the message\n     */\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the message to each\n     * listener\n     * @return\n     */\n    public IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private SubscriptionContext context;\n\n    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType){\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message){\n          dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.dispatch.ISubscriptionContextAware;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware implements ISubscriptionContextAware{\n\n    private SubscriptionContext context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext getContext() {\n        return context;\n    }\n\n    @Override\n    public IMessageBus getBus() {\n        return context.getOwningBus();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error){\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for(IPublicationErrorHandler handler : handlers){\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler){\n        try {\n            handler.invoke(listener, message);\n        }catch(IllegalAccessException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        }\n        catch(IllegalArgumentException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        }\n        catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        }\n        catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Handler(delivery = Mode.Sequential)\n    public void handleSubTestEvent(SubTestMessage message) {\n        super.handleSubTestEvent(message);\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Filters.java":"package net.engio.mbassy.listener;\n\n/**\n * Some sample filters that are not particularly useful in production environment\n * but illustrate how filters are meant to be used.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class Filters {\n\n    public static final class AllowAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return false;\n        }\n    }\n\n\n    public static final class RejectSubtypes implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            for(Class handledMessage : metadata.getHandledMessages()){\n                if(handledMessage.equals(event.getClass()))return true;\n            }\n            return false;\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/common/TestUtil.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessageBus;\n\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class TestUtil {\n\n\n    public static void setup(final IMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n        Runnable[] setupUnits = new Runnable[numberOfThreads];\n        int partitionSize;\n        if(listeners.size() >= numberOfThreads){\n          partitionSize =  (int)Math.floor(listeners.size() / numberOfThreads);\n        }\n        else{\n            partitionSize = 1;\n            numberOfThreads = listeners.size();\n        }\n\n        for(int i = 0; i < numberOfThreads; i++){\n            final int partitionStart = i * partitionSize;\n            final int partitionEnd = (i+1 < numberOfThreads)\n                    ? partitionStart + partitionSize + 1\n                    : listeners.size();\n            setupUnits[i] = new Runnable() {\n\n                private List<Object> listenerSubset = listeners.subList(partitionStart, partitionEnd);\n\n                public void run() {\n                   for(Object listener : listenerSubset){\n                       bus.subscribe(listener);\n                   }\n                }\n            };\n\n        }\n\n        ConcurrentExecutor.runConcurrent(setupUnits);\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n *\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        publication.markDelivered();\n        for(Object listener: listeners){\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        }\n        else {\n            for (int i = 0; i < filter.length; i++) {\n                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) return false;\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n         if(passesFilter(message)){\n             getDelegate().dispatch(publication, message, listeners);\n         }\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.*;\nimport org.junit.Test;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listeners.ListenerFactory;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation extends ISubscriptionContextAware {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    public void invoke(final Object listener, final Object message);\n\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Handler handlerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType){\n        for(Class<?> handledMessage : handledMessages){\n            if(handledMessage.equals(messageType))return true;\n            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes(){\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.IMessageBus;\n\n/**\n * This interface marks components that have access to the message bus that they belong to.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface IMessageBusAware {\n\n    public IMessageBus getBus();\n}\n","src/test/java/net/engio/mbassy/MessagePublicationTest.java":"package net.engio.mbassy;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.events.SubTestMessage;\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listeners.EventingTestBean;\nimport net.engio.mbassy.listeners.EventingTestBean2;\nimport net.engio.mbassy.listeners.EventingTestBean3;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport net.engio.mbassy.listeners.MultiEventHandler;\nimport net.engio.mbassy.listeners.NonListeningBean;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MessagePublicationTest extends MessageBusTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class)\n                .create(10000, MultiEventHandler.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n        TestMessage2 message2 = new TestMessage2();\n\n        bus.publishAsync(message);\n        bus.publishAsync(subMessage);\n        bus.publishAsync(message2);\n\n        pause(processingTimeInMS);\n\n        assertEquals(50000, message.counter.get());\n        assertEquals(80000, subMessage.counter.get());\n        assertEquals(20000, message2.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, message.counter.get());\n        assertEquals(70000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n        final CopyOnWriteArrayList<SubTestMessage> subtestMessages = new CopyOnWriteArrayList<SubTestMessage>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestMessage message = new TestMessage();\n                    SubTestMessage subMessage = new SubTestMessage();\n                    testMessages.add(message);\n                    subtestMessages.add(subMessage);\n\n                    bus.publishAsync(message);\n                    bus.publish(subMessage);\n                }\n            }\n        }, 10);\n\n        pause(processingTimeInMS);\n\n        for (TestMessage message : testMessages) {\n            assertEquals(30000, message.counter.get());\n        }\n\n        for (SubTestMessage message : subtestMessages) {\n            assertEquals(70000, message.counter.get());\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Mode.Sequential)\n    public void handleSubTestEventAgain(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":[[21,21],[22,22],[24,24],[25,25],[26,26],[28,28],[29,29],[30,30],[34,34],[35,35],[37,37],[38,38],[39,39],[41,41],[42,42],[43,43]],"src/test/java/net/engio/mbassy/DeadEventTest.java":[[20,20]],"src/test/java/net/engio/mbassy/MetadataReaderTest.java":[[120,120],[178,178],[161,161],[146,146],[115,115],[167,167],[126,126],[151,151]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[97,97],[77,77],[78,78],[82,82],[55,55]],"src/test/java/net/engio/mbassy/FilterTest.java":[[27,27],[28,28],[29,31],[38,38],[39,39],[41,41],[42,42],[44,44],[45,45]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[90,90],[57,57]],"src/test/java/net/engio/mbassy/MethodDispatchTest.java":[[42,42],[23,23]],"src/test/java/net/engio/mbassy/MessagePublicationTest.java":[[98,98],[99,99],[103,103],[120,120],[121,121],[122,122],[123,123],[125,125],[126,126],[133,133],[134,134],[137,137],[138,138],[37,37],[51,51],[52,52],[53,53],[55,55],[56,56],[57,57],[61,61],[62,62],[63,63],[70,70],[83,83],[84,84],[86,86],[87,87],[91,91],[92,92]]},"postChangeRange":{"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":[[21,21],[22,22],[24,24],[25,25],[26,26],[28,28],[29,29],[30,30],[34,34],[35,35],[37,37],[38,38],[39,39],[41,41],[42,42],[43,43]],"src/test/java/net/engio/mbassy/DeadEventTest.java":[[22,22]],"src/test/java/net/engio/mbassy/MetadataReaderTest.java":[[120,120],[178,178],[161,161],[146,146],[115,115],[167,167],[126,126],[151,151]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[97,97],[77,77],[78,78],[82,82],[55,55]],"src/test/java/net/engio/mbassy/FilterTest.java":[[32,32],[33,33],[34,34],[41,41],[42,42],[44,44],[45,45],[47,47],[48,48],[49,49]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[90,90],[57,57]],"src/test/java/net/engio/mbassy/MethodDispatchTest.java":[[44,44],[25,25]],"src/test/java/net/engio/mbassy/MessagePublicationTest.java":[[100,100],[101,101],[105,105],[122,122],[123,123],[124,124],[125,125],[127,127],[128,128],[135,135],[136,136],[139,139],[140,140],[39,39],[53,53],[54,54],[55,55],[57,57],[58,58],[59,59],[63,63],[64,64],[65,65],[72,72],[85,85],[86,86],[88,88],[89,89],[93,93],[94,94]]},"microChanges":[],"refactorings":[{"type":"\"Change Variable Type\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}]}]},{"repository":"mbassador","sha1":"7c08bd02993694b115474f63ba0b3f91f0beeaab","url":"https://github.com/bennidi/mbassador/commit/7c08bd02993694b115474f63ba0b3f91f0beeaab","preChangeSourceCode":{"src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.ListenerSubscriptionTest;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        StrongConcurrentSetTest.class,\n        WeakConcurrentSetTest.class,\n        AsynchronousMessageBusTest.class,\n        SyncBusTest.MBassadorTest.class,\n        SyncBusTest.SyncMessageBusTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class,\n        DeadEventTest.class,\n        SynchronizedHandlerTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<MessageListener1> listener = reader.getMessageListener(new MessageListener1());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<MessageListener2> listener = reader.getMessageListener(new MessageListener2());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<MessageListener3> listener = reader.getMessageListener(new MessageListener3());\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(new EnvelopedListener());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(new EnvelopedListenerSubclass());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class MessageListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class MessageListener2 extends MessageListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class MessageListener3 extends MessageListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.messages.ITestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends UnitTest{\n\n    @Test\n    public void testSimpleSynchronousHandler(){\n        SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n        SimpleSynchronousMessageHandler\n                listener1 = new SimpleSynchronousMessageHandler(),\n                listener2 = new SimpleSynchronousMessageHandler();\n        subMan.subscribe(listener1);\n        subMan.subscribe(listener2);\n\n        Collection<Subscription> subscriptions = subMan.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions){\n            assertEquals(2, sub.size());\n            assertTrue(sub.contains(listener1));\n            assertTrue(sub.contains(listener2));\n        }\n\n        subscriptions = subMan.getSubscriptionsByMessageType(ITestMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions){\n            assertEquals(2, sub.size());\n            assertTrue(sub.contains(listener1));\n            assertTrue(sub.contains(listener2));\n        }\n    }\n\n\n    static class SimpleSynchronousMessageHandler{\n\n        @Handler\n        public void handle(TestMessage message) {\n        }\n\n        @Handler\n        public void handle(ITestMessage message) {\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Object listener) {\n        Class<?> target = listener.getClass();\n        Listener listenerConfig = target.getAnnotation(Listener.class);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = handler.getAnnotation(Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handlerConfig), handlerConfig, listenerConfig);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Object listener) {\n        return new MessageListenerMetadata(getMessageHandlers(listener), listener.getClass());\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private final Method handler;\n\n    private final IMessageFilter[] filter;\n\n    private final Handler handlerConfig;\n\n    private final boolean isAsynchronous;\n\n    private final Enveloped envelope;\n\n    private final List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private final boolean acceptsSubtypes;\n\n    private final Listener listenerConfig;\n\n    private final boolean isSynchronized;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig, Listener listenerConfig) {\n        if(handler == null || handlerConfig == null){\n            throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n        }\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Invoke.Asynchronously);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        this.listenerConfig = listenerConfig;\n        this.isSynchronized = handler.getAnnotation(Synchronized.class) != null;\n        if (this.envelope != null) {\n            for(Class messageType : envelope.messages()){\n                handledMessages.add(messageType);\n            }\n        } else {\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n    public boolean isSynchronized(){\n        return isSynchronized;\n    }\n\n    public boolean useStrongReferences(){\n        return listenerConfig != null && listenerConfig.references().equals(References.Strong);\n    }\n\n    public boolean isAsynchronous() {\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered() {\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority() {\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\n        return handlerConfig.invocation();\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n        Class current = subclass;\n        while (!current.equals(overridingMethod.getDeclaringClass())) {\n            try {\n                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) {\n                filtered.add(method);\n            }\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class) && !from.isInterface()) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        collectInterfaces(from, superclasses);\n        return superclasses;\n    }\n\n    public static void collectInterfaces(Class from, Collection<Class> accumulator){\n        for(Class intface : from.getInterfaces()){\n            accumulator.add(intface);\n            collectInterfaces(intface, accumulator);\n        }\n    }\n\n    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for (int i = 0; i < subClassMethodParameters.length; i++) {\n            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers;\n\n    private Class<T> listenerDefinition;\n\n    public MessageListenerMetadata(List<MessageHandlerMetadata> handlers, Class<T> listenerDefinition) {\n        this.handlers = handlers;\n        this.listenerDefinition = listenerDefinition;\n    }\n\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for (MessageHandlerMetadata handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.*;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport org.junit.Test;\n\nimport java.util.List;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, MessageListener1.class)\n                .create(10000, MessageListener2.class)\n                .create(10000, MessageListener3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subMessage).now();\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, message.counter.get());\n        assertEquals(70000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n\n        ISyncMessageBus bus = getSyncMessageBus();\n\n\n        for(int i = 0; i< 10000; i++){\n            bus.subscribe(new MessageListener2());\n        }\n\n        runGC();\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subMessage).now();\n\n        pause(processingTimeInMS);\n\n        assertEquals(10000, message.counter.get());\n        assertEquals(20000, subMessage.counter.get());\n\n    }\n\n    protected abstract ISyncMessageBus getSyncMessageBus();\n\n\n    public static class MessageListener1 {\n\n        // every event of type TestEvent or any subtype will be delivered\n        // to this listener\n        @Handler\n        public void handleTestEvent(TestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n        // this handler will be invoked asynchronously\n        @Handler(priority = 0, invocation = HandleSubTestEventInvocation.class)\n        public void handleSubTestEvent(SubTestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n        // this handler will receive events of type SubTestEvent\n        // or any subtabe and that passes the given filter\n        @Handler(\n                priority = 10,\n                delivery = Invoke.Synchronously,\n                filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n        public void handleFiltered(SubTestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class HandleSubTestEventInvocation extends HandlerInvocation<MessageListener1, SubTestMessage> {\n\n        public HandleSubTestEventInvocation(SubscriptionContext context) {\n            super(context);\n        }\n\n        @Override\n        public void invoke(MessageListener1 listener, SubTestMessage message) {\n            listener.handleSubTestEvent(message);\n        }\n    }\n\n    @Listener(references = References.Strong)\n    public static class MessageListener2 extends net.engio.mbassy.listeners.EventingTestBean {\n\n        // redefine the configuration for this handler\n        @Handler(delivery = Invoke.Synchronously)\n        public void handleSubTestEvent(SubTestMessage message) {\n            super.handleSubTestEvent(message);\n        }\n\n    }\n\n    @Listener(references = References.Strong)\n    public static class MessageListener3 extends net.engio.mbassy.listeners.EventingTestBean2 {\n\n\n        // this handler will be invoked asynchronously\n        @Handler(priority = 0, delivery = Invoke.Synchronously)\n        public void handleSubTestEventAgain(SubTestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new MBassador(BusConfiguration.Default());\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new SyncMessageBus(new SyncBusConfiguration());\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public List<Class<?>> getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listener);\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible and using a write lock from the beginning with will dramatically decrease performance\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        readWriteLock.readLock().lock();\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        readWriteLock.readLock().unlock();\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static class Factory {\n\n        public MessagePublication createPublication(ISyncMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n        }\n\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private boolean delivered = false;\n\n    private ISyncMessageBus bus;\n\n    public MessagePublication(ISyncMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                bus.post(new FilteredMessage(message)).now();\n            } else if (!isDeadEvent()) {\n                bus.post(new DeadMessage(message)).now();\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (!state.equals(State.Initial)) {\n            return this;\n        }\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError() {\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.ListenerSubscriptionTest;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        StrongConcurrentSetTest.class,\n        WeakConcurrentSetTest.class,\n        AsynchronousMessageBusTest.class,\n        SyncBusTest.MBassadorTest.class,\n        SyncBusTest.SyncMessageBusTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class,\n        DeadEventTest.class,\n        SynchronizedHandlerTest.class,\n        SubscriptionManagerTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class MessageListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class MessageListener2 extends MessageListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class MessageListener3 extends MessageListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.messages.ITestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends UnitTest{\n\n    @Test\n    public void testSimpleSynchronousHandler(){\n        final SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n        final Set listeners = Collections.synchronizedSet(new HashSet());\n        final int concurrentUnits = 5;\n        final int numberOfLoops = 100;\n        final int numberOfListeners =  numberOfLoops * concurrentUnits * 2;\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(int i = 0 ; i < numberOfLoops ; i++){\n                    SimpleSynchronousMessageHandler\n                            listener1 = new SimpleSynchronousMessageHandler();\n                    SimpleSynchronousMessageHandler2 listener2 = new SimpleSynchronousMessageHandler2();\n                    subMan.subscribe(listener1);\n                    subMan.subscribe(listener2);\n                    listeners.add(listener1);\n                    listeners.add(listener2);\n                }\n\n            }\n        }, concurrentUnits);\n\n\n        Collection<Subscription> subscriptions = subMan.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(2, subscriptions.size());\n\n        for(Subscription sub : subscriptions){\n            assertEquals(numberOfListeners, sub.size());\n            for(Object listener : listeners){\n\n                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n            }\n        }\n\n        subscriptions = subMan.getSubscriptionsByMessageType(ITestMessage.class);\n        assertEquals(2, subscriptions.size());\n        for(Subscription sub : subscriptions){\n            assertEquals(numberOfListeners, sub.size());\n            for(Object listener : listeners){\n                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n            }\n        }\n    }\n\n\n    static class SimpleSynchronousMessageHandler{\n\n        @Handler\n        public void handle(TestMessage message) {\n        }\n\n        @Handler\n        public void handle(ITestMessage message) {\n        }\n    }\n\n\n    static class SimpleSynchronousMessageHandler2{\n\n        @Handler\n        public void handle(TestMessage message) {\n        }\n\n        @Handler\n        public void handle(ITestMessage message) {\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public MessageListenerMetadata getMessageListener(Class target) {\n        MessageListenerMetadata listenerMetadata = new MessageListenerMetadata(target);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = handler.getAnnotation(Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handlerConfig), handlerConfig, listenerMetadata);\n            listenerMetadata.addHandler(handlerMetadata);\n\n        }\n        return listenerMetadata;\n    }\n\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private final Method handler;\n\n    private final IMessageFilter[] filter;\n\n    private final Handler handlerConfig;\n\n    private final boolean isAsynchronous;\n\n    private final Enveloped envelope;\n\n    private final List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private final boolean acceptsSubtypes;\n\n    private final MessageListenerMetadata listenerConfig;\n\n    private final boolean isSynchronized;\n\n    private Class listeningClass;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig, MessageListenerMetadata listenerConfig) {\n        if(handler == null || handlerConfig == null){\n            throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n        }\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Invoke.Asynchronously);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        this.listenerConfig = listenerConfig;\n        this.isSynchronized = handler.getAnnotation(Synchronized.class) != null;\n        if (this.envelope != null) {\n            for(Class messageType : envelope.messages()){\n                handledMessages.add(messageType);\n            }\n        } else {\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n    public boolean isSynchronized(){\n        return isSynchronized;\n    }\n\n    public boolean useStrongReferences(){\n        return listenerConfig.useStrongReferences();\n    }\n\n    public boolean isFromListener(Object listener){\n        return listenerConfig.isFromListener(listener);\n    }\n\n    public boolean isAsynchronous() {\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered() {\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority() {\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\n        return handlerConfig.invocation();\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n        Class current = subclass;\n        while (!current.equals(overridingMethod.getDeclaringClass())) {\n            try {\n                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) {\n                filtered.add(method);\n            }\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class) && !from.isInterface()) {\n            superclasses.add(from.getSuperclass());\n            collectInterfaces(from, superclasses);\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static void collectInterfaces(Class from, Collection<Class> accumulator){\n        for(Class intface : from.getInterfaces()){\n            accumulator.add(intface);\n            collectInterfaces(intface, accumulator);\n        }\n    }\n\n    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for (int i = 0; i < subClassMethodParameters.length; i++) {\n            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers = new ArrayList<MessageHandlerMetadata>();\n\n    private Class<T> listenerDefinition;\n\n    private Listener listenerAnnotation;\n\n    public MessageListenerMetadata(Class<T> listenerDefinition) {\n        this.listenerDefinition = listenerDefinition;\n        Listener listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n    }\n\n\n    public boolean isFromListener(Object listener){\n        return listenerDefinition.equals(listener.getClass());\n    }\n\n    public boolean useStrongReferences(){\n        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n    }\n\n    public MessageListenerMetadata addHandlers(Collection<? extends MessageHandlerMetadata> c) {\n        handlers.addAll(c);\n        return this;\n    }\n\n    public boolean addHandler(MessageHandlerMetadata messageHandlerMetadata) {\n        return handlers.add(messageHandlerMetadata);\n    }\n\n    public List<MessageHandlerMetadata> getHandlers(){\n        return handlers;\n    }\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for (MessageHandlerMetadata handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.*;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport org.junit.Test;\n\nimport java.util.List;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, MessageListener1.class)\n                .create(10000, MessageListener2.class)\n                .create(10000, MessageListener3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subMessage).now();\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, message.counter.get());\n        assertEquals(70000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n\n        ISyncMessageBus bus = getSyncMessageBus();\n\n\n        for(int i = 0; i< 10000; i++){\n            bus.subscribe(new MessageListener2());\n        }\n\n        runGC();\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subMessage).now();\n\n        pause(processingTimeInMS);\n\n        assertEquals(10000, message.counter.get());\n        assertEquals(20000, subMessage.counter.get());\n\n    }\n\n    protected abstract ISyncMessageBus getSyncMessageBus();\n\n\n    public static class MessageListener1 {\n\n        // every event of type TestEvent or any subtype will be delivered\n        // to this listener\n        @Handler\n        public void handleTestEvent(TestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n        // this handler will be invoked asynchronously\n        @Handler(priority = 0, invocation = HandleSubTestEventInvocation.class)\n        public void handleSubTestEvent(SubTestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n        // this handler will receive events of type SubTestEvent\n        // or any subtabe and that passes the given filter\n        @Handler(\n                priority = 10,\n                delivery = Invoke.Synchronously,\n                filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n        public void handleFiltered(SubTestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class HandleSubTestEventInvocation extends HandlerInvocation<MessageListener1, SubTestMessage> {\n\n        public HandleSubTestEventInvocation(SubscriptionContext context) {\n            super(context);\n        }\n\n        @Override\n        public void invoke(MessageListener1 listener, SubTestMessage message) {\n            listener.handleSubTestEvent(message);\n        }\n    }\n\n    @Listener(references = References.Strong)\n    public static class MessageListener2 extends net.engio.mbassy.listeners.EventingTestBean {\n\n        // redefine the configuration for this handler\n        @Handler(delivery = Invoke.Synchronously)\n        public void handleSubTestEvent(SubTestMessage message) {\n            super.handleSubTestEvent(message);\n        }\n\n    }\n\n    @Listener(references = References.Strong)\n    public static class MessageListener3 extends net.engio.mbassy.listeners.EventingTestBean2 {\n\n\n        // this handler will be invoked asynchronously\n        @Handler(priority = 0, delivery = Invoke.Synchronously)\n        public void handleSubTestEventAgain(SubTestMessage message) {\n            message.counter.incrementAndGet();\n        }\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new MBassador(BusConfiguration.Default());\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new SyncMessageBus(new SyncBusConfiguration());\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    public boolean isFromListener(Object listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public List<Class<?>> getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible and using a write lock from the beginning with will dramatically decrease performance\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        readWriteLock.readLock().lock();\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        readWriteLock.readLock().unlock();\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static class Factory {\n\n        public MessagePublication createPublication(ISyncMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n        }\n\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private boolean delivered = false;\n\n    private ISyncMessageBus bus;\n\n    protected MessagePublication(ISyncMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                bus.post(new FilteredMessage(message)).now();\n            } else if (!isDeadEvent()) {\n                bus.post(new DeadMessage(message)).now();\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (!state.equals(State.Initial)) {\n            return this;\n        }\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError() {\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error\n    }\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/MetadataReaderTest.java":[[62,62],[41,41],[75,75],[30,30],[51,51]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[26,28],[29,29],[30,30],[33,33],[35,35],[36,36],[37,37],[41,41],[43,43],[44,44],[45,45]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[61,61]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[69,69]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[85,85]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[40,40]]},"postChangeRange":{"src/test/java/net/engio/mbassy/MetadataReaderTest.java":[[62,62],[41,41],[75,75],[30,30],[51,51]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[30,30],[31,31],[32,32],[33,33],[34,34],[36,50],[54,54],[57,57],[58,61],[65,65],[67,67],[68,70]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[63,63]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[67,67]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[85,85]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[40,40]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":60,"endLine":60}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":69,"endLine":69}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":60,"endLine":60}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":60,"endLine":60}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":69,"endLine":69}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":69,"endLine":69}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":60,"endLine":60}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":69,"endLine":69}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":69,"endLine":69}]}],"refactorings":[]},{"repository":"mbassador","sha1":"5c2fc81e7af7b18b2077a87e9d9abdb6916373ee","url":"https://github.com/bennidi/mbassador/commit/5c2fc81e7af7b18b2077a87e9d9abdb6916373ee","preChangeSourceCode":{"src/test/java/net/engio/mbassy/common/ListenerFactory.java":"package net.engio.mbassy.common;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * The factory can be used to declaratively specify how many instances of some given classes\n * should be created. It will create those instances using reflection and provide a list containing those instances.\n * The factory also holds strong references to the instances such that GC will not interfere with tests unless the\n * factory is explicitly cleared.\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class ListenerFactory {\n\n    private Map<Class, Integer> requiredBeans = new HashMap<Class, Integer>();\n    private List generatedListeners;\n    private int requiredSize = 0;\n\n    public int getNumberOfListeners(Class listener){\n        return requiredBeans.containsKey(listener) ? requiredBeans.get(listener) : 0;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Class clazz){\n        requiredBeans.put(clazz, numberOfInstances);\n        requiredSize +=numberOfInstances;\n        return this;\n    }\n\n\n    public List<Object> getAll(){\n        generatedListeners = new ArrayList(requiredSize);\n        try {\n            for(Class clazz : requiredBeans.keySet()){\n                int numberOfRequiredBeans = requiredBeans.get(clazz);\n                for(int i = 0; i < numberOfRequiredBeans; i++){\n                    generatedListeners.add(clazz.newInstance());\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(e);\n        }\n        Collections.shuffle(generatedListeners);\n        return generatedListeners;\n    }\n\n    // not thread-safe but not yet used concurrently\n    public void clear(){\n        generatedListeners = null;\n        requiredBeans.clear();\n    }\n\n    /**\n     * Create a thread-safe read-only iterator\n     * @return\n     */\n    public Iterator iterator(){\n        if(generatedListeners == null)getAll();\n        final AtomicInteger current = new AtomicInteger(0);\n\n        return new Iterator() {\n            @Override\n            public boolean hasNext() {\n                return current.get() < generatedListeners.size();\n            }\n\n            @Override\n            public Object next() {\n                int index =  current.getAndIncrement();\n                return index < generatedListeners.size() ? generatedListeners.get(index) : null;\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Iterator is read only\");\n            }\n        };\n    }\n\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/common/ListenerFactory.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * The factory can be used to declaratively specify how many instances of some given classes\n * should be created. It will create those instances using reflection and provide a list containing those instances.\n * The factory also holds strong references to the instances such that GC will not interfere with tests unless the\n * factory is explicitly cleared.\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class ListenerFactory {\n\n    private Map<Class, Integer> requiredBeans = new HashMap<Class, Integer>();\n    private volatile List generatedListeners;\n    private int requiredSize = 0;\n\n    public int getNumberOfListeners(Class listener){\n        return requiredBeans.containsKey(listener) ? requiredBeans.get(listener) : 0;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Class clazz){\n        requiredBeans.put(clazz, numberOfInstances);\n        requiredSize +=numberOfInstances;\n        return this;\n    }\n\n\n    public synchronized List<Object> getAll(){\n        if(generatedListeners != null)\n            return generatedListeners;\n        List listeners = new ArrayList(requiredSize);\n        try {\n            for(Class clazz : requiredBeans.keySet()){\n                int numberOfRequiredBeans = requiredBeans.get(clazz);\n                for(int i = 0; i < numberOfRequiredBeans; i++){\n                    listeners.add(clazz.newInstance());\n                }\n            }\n        } catch (Exception e) {\n            // if instantiation fails, counts will be incorrect\n            // -> fail early here\n            Assert.fail(\"There was a problem instantiating a listener \" + e);\n        }\n        Collections.shuffle(listeners);\n        generatedListeners  = Collections.unmodifiableList(listeners);\n        return generatedListeners;\n    }\n\n    // not thread-safe but not yet used concurrently\n    public synchronized  void clear(){\n        generatedListeners = null;\n        requiredBeans.clear();\n    }\n\n    /**\n     * Create a thread-safe read-only iterator\n     *\n     * NOTE: Iterator is not perfectly synchronized with mutator methods of the list of generated listeners\n     * In theory, it is possible that the list is changed while iterators are still running which should be avoided.\n     * @return\n     */\n    public Iterator iterator(){\n        getAll();\n        final AtomicInteger current = new AtomicInteger(0);\n\n        return new Iterator() {\n            @Override\n            public boolean hasNext() {\n                return current.get() < generatedListeners.size();\n            }\n\n            @Override\n            public Object next() {\n                int index =  current.getAndIncrement();\n                return index < generatedListeners.size() ? generatedListeners.get(index) : null;\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Iterator is read only\");\n            }\n        };\n    }\n\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/common/ListenerFactory.java":[[60,60],[33,33],[38,38],[42,42],[43,43],[45,45]]},"postChangeRange":{"src/test/java/net/engio/mbassy/common/ListenerFactory.java":[[56,56],[64,64],[65,65],[69,69],[34,34],[35,36],[37,37],[42,42],[48,48],[50,50],[51,51]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/common/ListenerFactory.java","startLine":35,"endLine":35}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/common/ListenerFactory.java","startLine":35,"endLine":35}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/common/ListenerFactory.java","startLine":60,"endLine":60}],"rightSideLocations":[]}],"refactorings":[]},{"repository":"mbassador","sha1":"17b1fee1b6b44612588e711aa0279c511c9d8d3a","url":"https://github.com/bennidi/mbassador/commit/17b1fee1b6b44612588e711aa0279c511c9d8d3a","preChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n    \n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSetWeak.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSetWeak.contains(uniqueObject));\n        }\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final IConcurrentSet weakConcurrentSet = createSet();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            weakConcurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                    if (toRemove.contains(src))\n                        testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSetWeak.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Handler(delivery = Invoke.Synchronously)\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n    @Handler(delivery = Invoke.Synchronously, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Handler\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Invoke.Asynchronously, invocation = HandleSubTestEventInvocation.class)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Handler(\n            priority = 10,\n            delivery = Invoke.Synchronously,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    public static class HandleSubTestEventInvocation extends HandlerInvocation<EventingTestBean, SubTestMessage> {\n\n        public HandleSubTestEventInvocation(SubscriptionContext context) {\n            super(context);\n        }\n\n        @Override\n        public void invoke(EventingTestBean listener, SubTestMessage message) {\n            listener.handleSubTestEvent(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Map;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n\n    // Internal state\n    private final Object lock = new Object();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public IConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) {\n            return this;\n        }\n        synchronized (lock) {\n            insert(element);\n        }\n        return this;\n    }\n\n    @Override\n    public boolean contains(T element) {\n        ISetEntry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) {\n            return;\n        }\n        head = createEntry(element, head);\n        entries.put(element, head);\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public IConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (lock) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) {\n                    return this;\n                }\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) {\n            return false;\n        }\n        synchronized (lock) {\n            ISetEntry<T> listelement = entries.get(element);\n            if (listelement == null) {\n                return false; //removed by other thread\n            }\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                ISetEntry<T> oldHead = head;\n                head = head.next();\n                oldHead.clear(); // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\n@Listener(references = References.Strong)\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Handler(delivery = Invoke.Synchronously)\n    public void handleSubTestEvent(SubTestMessage message) {\n        super.handleSubTestEvent(message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        Listener listenerConfig = target.getAnnotation(Listener.class);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = handler.getAnnotation(Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handlerConfig), handlerConfig, listenerConfig);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listeners.EventingTestBean;\nimport net.engio.mbassy.listeners.EventingTestBean2;\nimport net.engio.mbassy.listeners.EventingTestBean3;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport net.engio.mbassy.listeners.NonListeningBean;\nimport net.engio.mbassy.subscription.Subscription;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Testing different scenarios of subscribing objects (listeners and non-listeners) to the message bus.\n *\n * @author bennidi\n *         Date: 1/9/13\n */\npublic class ListenerSubscriptionTest extends MessageBusTest{\n\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = getBus(new BusConfiguration());\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 200000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(30000, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(100000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/NonListeningBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.Handler;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should not be considered a message listener\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    @Handler(enabled = false)\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Handler(enabled = false)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Handler(enabled = false)\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * that lives inside a message bus.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext<Bus extends ISyncMessageBus> {\n\n    private Bus owningBus;\n\n    private MessageHandlerMetadata handlerMetadata;\n\n    public SubscriptionContext(Bus owningBus, MessageHandlerMetadata handlerMetadata) {\n        this.owningBus = owningBus;\n        this.handlerMetadata = handlerMetadata;\n    }\n\n    /**\n     * Get a reference to the message bus this context belongs to\n     *\n     * @return\n     */\n    public Bus getOwningBus() {\n        return owningBus;\n    }\n\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author bennidi\n *         Date: 11/16/12\n *         Time: 10:39 AM\n *         To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context) throws MessageBusException{\n        try {\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, context.getHandlerMetadata().useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws Exception {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n        return constructor.newInstance(context);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyncMessageBus<T,P> {\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n    /**\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n\n    interface IPostCommand extends ISyncPostCommand {\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        MessagePublication asynchronously();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout is reached.\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        MessagePublication asynchronously(long timeout, TimeUnit unit);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<EventListener1> listener = reader.getMessageListener(EventListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<EventListener2> listener = reader.getMessageListener(EventListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<EventListener3> listener = reader.getMessageListener(EventListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EventListener3 extends EventListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n        Class current = subclass;\n        while (!current.equals(overridingMethod.getDeclaringClass())) {\n            try {\n                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) {\n                filtered.add(method);\n            }\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for (int i = 0; i < subClassMethodParameters.length; i++) {\n            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/MessagePublicationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listeners.*;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MessagePublicationTest extends MessageBusTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class)\n                .create(10000, MultiEventHandler.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n        TestMessage2 message2 = new TestMessage2();\n\n        bus.publishAsync(message);\n        bus.publishAsync(subMessage);\n        bus.publishAsync(message2);\n\n        pause(processingTimeInMS);\n\n        assertEquals(50000, message.counter.get());\n        assertEquals(80000, subMessage.counter.get());\n        assertEquals(20000, message2.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, message.counter.get());\n        assertEquals(70000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n\n\n        for(int i = 0; i< 10000; i++){\n            bus.subscribe(new EventingTestBean2());\n        }\n\n        runGC();\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(10000, message.counter.get());\n        assertEquals(20000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n        final CopyOnWriteArrayList<SubTestMessage> subtestMessages = new CopyOnWriteArrayList<SubTestMessage>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestMessage message = new TestMessage();\n                    SubTestMessage subMessage = new SubTestMessage();\n                    testMessages.add(message);\n                    subtestMessages.add(subMessage);\n\n                    bus.publishAsync(message);\n                    bus.publish(subMessage);\n                }\n            }\n        }, 10);\n\n        pause(processingTimeInMS);\n\n        for (TestMessage message : testMessages) {\n            assertEquals(30000, message.counter.get());\n        }\n\n        for (SubTestMessage message : subtestMessages) {\n            assertEquals(70000, message.counter.get());\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\n@Listener(references = References.Strong)\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Invoke.Synchronously)\n    public void handleSubTestEventAgain(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> implements ISyncMessageBus<T, P> {\n\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet<Class>();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final MessagePublication.Factory publicationFactory;\n\n\n    public AbstractSyncMessageBus(SyncBusConfiguration configuration) {\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass)) {\n                return; // early reject of known classes that do not participate in eventing\n            }\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for (Class<?> messageType : messageTypes) {\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener) {\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n    \n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSetWeak.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSetWeak.contains(uniqueObject));\n        }\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final IConcurrentSet weakConcurrentSet = createSet();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            weakConcurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                    if (toRemove.contains(src))\n                        testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet setUnderTest = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            setUnderTest.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = setUnderTest.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, setUnderTest.size());\n        for(Object src : source){\n            assertFalse(setUnderTest.contains(src));\n        }\n    }\n\n\n    /**\n     * In this test HashMap will cross capacity threshold multiple times in\n     * different directions which will trigger rehashing. Because rehashing\n     * requires modification of Entry class for all hash map entries some keys\n     * may temporarily disappear from the map.\n     * <p>\n     * For more information please take a look at transfer method in HashMap.\n     *\n     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n     */\n    @Test\n    public void testConcurrentAddRemove() {\n        final IConcurrentSet set = createSet();\n        final List permanentObjects = createWithRandomIntegers(80, null);\n        final List volatileObjects = createWithRandomIntegers(10000, permanentObjects);\n        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n        final int mutatorThreshold = 1000;\n\n        // Add elements that will not be touched by the constantly running mutating thread\n        final int numItems = 8;\n        for (Object permanent : permanentObjects) {\n            set.add(permanent);\n        }\n\n        // Adds and removes items >= numItems\n        // thus forcing constant rehashing of the backing hashtable\n        Runnable updatingThread = new Runnable() {\n            public void run() {\n                Random rand = new Random();\n                for(int times = 0; times < 1000 ; times++){\n                    System.out.println(\"New mutator cycle: \" + times);\n                    HashSet elements = new HashSet(mutatorThreshold);\n\n                    for (int i = numItems; i < mutatorThreshold; i++) {\n                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n                        set.add(volatileObject);\n                        elements.add(volatileObject);\n                    }\n                    for (Object volObj : elements) {\n                        set.remove(volObj);\n                    }\n                }\n            };\n        };\n\n        Runnable lookupThread = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++) {\n                    System.out.println(\"New lookup cycle: \" + i);\n                    for (Object permanent : permanentObjects) {\n                        // permanent items are never touched,\n                        // --> set.contains(j) should always return true\n                        if(!set.contains(permanent))\n                            missing.add(permanent);\n                    }\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(updatingThread, lookupThread, lookupThread, lookupThread);\n        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n\n    }\n\n\n    public List createWithRandomIntegers(int size, List<Integer> exluding){\n        if(exluding == null) exluding = new ArrayList<Integer>();\n        List<Integer> result = new ArrayList<Integer>(size);\n        Random rand = new Random();\n        for(int i = 0; i < size;i++){\n            result.add(rand.nextInt());\n        }\n        for(Integer excluded : exluding)\n            result.remove(excluded);\n        return result;\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.messages.TestMessage2;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Handler(delivery = Invoke.Synchronously)\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n    @Handler(delivery = Invoke.Synchronously, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Handler\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Invoke.Asynchronously, invocation = HandleSubTestEventInvocation.class)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Handler(\n            priority = 10,\n            delivery = Invoke.Synchronously,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    public static class HandleSubTestEventInvocation extends HandlerInvocation<EventingTestBean, SubTestMessage> {\n\n        public HandleSubTestEventInvocation(SubscriptionContext context) {\n            super(context);\n        }\n\n        @Override\n        public void invoke(EventingTestBean listener, SubTestMessage message) {\n            listener.handleSubTestEvent(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Map;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n\n    // Internal state\n    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public IConcurrentSet<T> add(T element) {\n        if (element == null) return this;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        if (element == null || entries.containsKey(element)) {\n            writeLock.unlock();\n            return this;\n        } else {\n            insert(element);\n            writeLock.unlock();\n        }\n        return this;\n    }\n\n    @Override\n    public boolean contains(T element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n        }\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public IConcurrentSet<T> addAll(Iterable<T> elements) {\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return this;\n    }\n\n    @Override\n    public boolean remove(T element) {\n        if (!contains(element)) {\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    ISetEntry<T> oldHead = head;\n                    head = head.next();\n                    oldHead.clear(); // optimize for GC\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\n@Listener(references = References.Strong)\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Handler(delivery = Invoke.Synchronously)\n    public void handleSubTestEvent(SubTestMessage message) {\n        super.handleSubTestEvent(message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Object listener) {\n        Class<?> target = listener.getClass();\n        Listener listenerConfig = target.getAnnotation(Listener.class);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = handler.getAnnotation(Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handlerConfig), handlerConfig, listenerConfig);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Object listener) {\n        return new MessageListenerMetadata(getMessageHandlers(listener), listener.getClass());\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.listeners.EventingTestBean;\nimport net.engio.mbassy.listeners.EventingTestBean2;\nimport net.engio.mbassy.listeners.EventingTestBean3;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport net.engio.mbassy.listeners.NonListeningBean;\nimport net.engio.mbassy.subscription.Subscription;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Testing different scenarios of subscribing objects (listeners and non-listeners) to the message bus.\n *\n * @author bennidi\n *         Date: 1/9/13\n */\npublic class ListenerSubscriptionTest extends MessageBusTest{\n\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = getBus(new BusConfiguration());\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 200000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(30000, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(100000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/NonListeningBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.listener.Handler;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should not be considered a message listener\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    @Handler(enabled = false)\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Handler(enabled = false)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Handler(enabled = false)\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * managed by the subscription manager.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext<Bus extends ISyncMessageBus> {\n\n    private Bus owningBus;\n\n    private MessageHandlerMetadata handlerMetadata;\n\n    public SubscriptionContext(Bus owningBus, MessageHandlerMetadata handlerMetadata) {\n        this.owningBus = owningBus;\n        this.handlerMetadata = handlerMetadata;\n    }\n\n    /**\n     * Get a reference to the message bus this context belongs to\n     *\n     * @return\n     */\n    public Bus getOwningBus() {\n        return owningBus;\n    }\n\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.MessageBusException;\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    private ISyncMessageBus bus;\n\n    public SubscriptionFactory setBus(ISyncMessageBus bus) {\n        this.bus = bus;\n        return this;\n    }\n\n    public Subscription createSubscription(MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n        try {\n            SubscriptionContext context = new SubscriptionContext(bus, handlerMetadata);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, context.getHandlerMetadata().useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws Exception {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n        return constructor.newInstance(context);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyncMessageBus<T,P> {\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n    /**\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n\n    interface IPostCommand extends ISyncPostCommand {\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        MessagePublication asynchronously();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout is reached.\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        MessagePublication asynchronously(long timeout, TimeUnit unit);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<MessageListener1> listener = reader.getMessageListener(new MessageListener1());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<MessageListener2> listener = reader.getMessageListener(new MessageListener2());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<MessageListener3> listener = reader.getMessageListener(new MessageListener3());\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(new EnvelopedListener());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(new EnvelopedListenerSubclass());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class MessageListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class MessageListener2 extends MessageListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class MessageListener3 extends MessageListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n        Class current = subclass;\n        while (!current.equals(overridingMethod.getDeclaringClass())) {\n            try {\n                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) {\n                filtered.add(method);\n            }\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class) && !from.isInterface()) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        collectInterfaces(from, superclasses);\n        return superclasses;\n    }\n\n    public static void collectInterfaces(Class from, Collection<Class> accumulator){\n        for(Class intface : from.getInterfaces()){\n            accumulator.add(intface);\n            collectInterfaces(intface, accumulator);\n        }\n    }\n\n    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for (int i = 0; i < subClassMethodParameters.length; i++) {\n            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/MessagePublicationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.messages.TestMessage2;\nimport net.engio.mbassy.listeners.*;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MessagePublicationTest extends MessageBusTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class)\n                .create(10000, MultiEventHandler.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n        TestMessage2 message2 = new TestMessage2();\n\n        bus.publishAsync(message);\n        bus.publishAsync(subMessage);\n        bus.publishAsync(message2);\n\n        pause(processingTimeInMS);\n\n        assertEquals(50000, message.counter.get());\n        assertEquals(80000, subMessage.counter.get());\n        assertEquals(20000, message2.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, message.counter.get());\n        assertEquals(70000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n\n\n        for(int i = 0; i< 10000; i++){\n            bus.subscribe(new EventingTestBean2());\n        }\n\n        runGC();\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(10000, message.counter.get());\n        assertEquals(20000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n        final CopyOnWriteArrayList<SubTestMessage> subtestMessages = new CopyOnWriteArrayList<SubTestMessage>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestMessage message = new TestMessage();\n                    SubTestMessage subMessage = new SubTestMessage();\n                    testMessages.add(message);\n                    subtestMessages.add(subMessage);\n\n                    bus.publishAsync(message);\n                    bus.publish(subMessage);\n                }\n            }\n        }, 10);\n\n        pause(processingTimeInMS);\n\n        for (TestMessage message : testMessages) {\n            assertEquals(30000, message.counter.get());\n        }\n\n        for (SubTestMessage message : subtestMessages) {\n            assertEquals(70000, message.counter.get());\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\n@Listener(references = References.Strong)\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Invoke.Synchronously)\n    public void handleSubTestEventAgain(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> implements ISyncMessageBus<T, P> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n\n    public AbstractSyncMessageBus(SyncBusConfiguration configuration) {\n        this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n                configuration.getSubscriptionFactory().setBus(this));\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public List<Class<?>> getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[221,221],[227,227],[235,235],[245,245],[247,247]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[58,58]],"src/test/java/net/engio/mbassy/MetadataReaderTest.java":[[41,41],[30,30],[51,51],[62,62],[75,75]],"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":[[41,41],[46,48],[49,49],[50,50],[33,34],[74,75],[76,76],[77,88],[89,90],[91,91],[60,61],[62,64],[65,67]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[65,65]],"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":[[138,155],[69,81],[53,53],[54,54],[85,126]]},"postChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[219,219],[225,225],[233,233],[243,243],[245,245]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[58,58]],"src/test/java/net/engio/mbassy/MetadataReaderTest.java":[[41,41],[30,30],[51,51],[62,62],[75,75]],"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":[[47,47],[49,55],[60,63],[32,32],[33,33],[34,34],[36,36],[38,39],[40,41],[89,90],[91,109],[110,111],[73,73],[74,76],[77,79],[81,83]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[65,65],[69,69]],"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":[[64,65],[47,48],[31,32],[52,53]]},"microChanges":[{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":87,"endLine":87}],"rightSideLocations":[]},{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":96,"endLine":96}],"rightSideLocations":[]},{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":69,"endLine":69}],"rightSideLocations":[]},{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":73,"endLine":73}],"rightSideLocations":[]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":32,"endLine":32}]},{"type":"SimplifyConditional","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":62,"endLine":62}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":77,"endLine":77}]},{"type":"ReverseConditional","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":62,"endLine":62}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":77,"endLine":77}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":60,"endLine":60}]},{"type":"ReverseConditional","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":46,"endLine":46}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":60,"endLine":60}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":89,"endLine":89},{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":96,"endLine":96},{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":99,"endLine":99}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":74,"endLine":74}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":89,"endLine":89}]},{"type":"EncapsulateInCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":79,"endLine":79},{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":82,"endLine":82}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":96,"endLine":96},{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":99,"endLine":99}]}],"refactorings":[{"type":"\"Extract Class\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":140,"endLine":140},{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":146,"endLine":146},{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":148,"endLine":148}],"rightSideLocations":[]},{"type":"\"Extract Class\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":87,"endLine":87},{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":91,"endLine":91},{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":94,"endLine":94},{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":96,"endLine":96}],"rightSideLocations":[]},{"type":"\"Extract Class\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":69,"endLine":69},{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java","startLine":73,"endLine":73}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"e4b6a84ab8d2487fe610d294535f3f593b2f819c","url":"https://github.com/bennidi/mbassador/commit/e4b6a84ab8d2487fe610d294535f3f593b2f819c","preChangeSourceCode":{"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all async message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPostCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    public AbstractSyncAsyncMessageBus(BusConfiguration configuration) {\n        super(configuration);\n        this.executor = configuration.getExecutor();\n        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n         dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\", null, null, null));\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method queues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * The base class for all async message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPostCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    private static final AtomicInteger threadID = new AtomicInteger();\n    \n    public AbstractSyncAsyncMessageBus(BusConfiguration configuration) {\n        super(configuration);\n        this.executor = configuration.getExecutor();\n        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n         dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\", null, null, null));\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatcher.setName(\"MBassyDispatch-\" + threadID.incrementAndGet());\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method queues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        if(executor != null) executor.shutdown();\n    }\n\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[92,92]]},"postChangeRange":{"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[58,58],[96,96]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java","startLine":96,"endLine":96}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java","startLine":96,"endLine":96}]}],"refactorings":[]},{"repository":"mbassador","sha1":"40e41d11d7847d660bba6691859b0506514bd0ac","url":"https://github.com/bennidi/mbassador/commit/40e41d11d7847d660bba6691859b0506514bd0ac","preChangeSourceCode":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n\n        private boolean failOnException;\n\n        public AssertionErrorHandler(boolean failOnException) {\n            this.failOnException = failOnException;\n        }\n\n        @Override\n        public void handleError(PublicationError error) {\n            if(failOnException)\n                org.junit.Assert.fail(error.getCause().getMessage());\n        }\n    }\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return SyncAsync(true);\n    }\n\n    public static IBusConfiguration SyncAsync(boolean failOnError) {\n        return new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n        //DS: removed as publication error handlers now in configuration object\n//            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Message filters can be used to control what messages are delivered to a specific message handler.\n * Filters are attached to message handler using the @Listener annotation.\n * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n * The handler will be invoked only if each filter accepted the message.\n *\n * Example:\n *\n * {@code\n * @Lister\n * @Filters(Urlfilter.class)\n * public void someHandler(String message){...}\n *\n * class Urlfilter implements IMessageFilter<String>{\n *     public boolean accepts(String message, MessageHandler metadata){\n *         return message.startsWith(\"http\");\n *     }\n * }\n *\n * bus.post(\"http://www.infoq.com\"); // will be delivered\n * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n *\n * NOTE: A message filter must provide a no-arg constructor!!!\n * }\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic interface IMessageFilter<M> {\n\n    /**\n     * Check whether the message matches some criteria\n     *\n     * @param message The message to be handled by the handler\n     * @param  context The context object containing a description of the message handler and the bus environment\n     * @return  true: if the message matches the criteria and should be delivered to the handler\n     *          false: otherwise\n     */\n    boolean accepts(M message, SubscriptionContext context);\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n *\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener(){\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener(){\n        ListenerFactory listeners = listeners(\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class,\n                MessagesListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener(){\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener,  sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers(){\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testPrioritizedMessageHandlers(){\n        ListenerFactory listeners = listeners(PrioritizedListener.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private BusRuntime mockedRuntime(){\n        return new BusRuntime(null)\n                .add(Properties.Handler.PublicationError, Collections.EMPTY_SET)\n                .add(Properties.Handler.AsynchronousHandlerExecutor, null);\n    }\n\n    private ListenerFactory listeners(Class ...listeners){\n        ListenerFactory factory = new ListenerFactory();\n        for(Class listener : listeners){\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n    /**\n     *  define handlers with different priorities which need to be executed\n     *  in their respective order\n     */\n    public static class PrioritizedListener{\n\n\n        @net.engio.mbassy.listener.Handler(priority = 1)\n        public void handlePrio1(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 2)\n        public void handlePrio2(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 3)\n        public void handlePrio3(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 4)\n        public void handlePrio4(IMessage message){\n            message.handled(this.getClass());\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/el/StandardELResolutionContext.java":"package net.engio.mbassy.dispatch.el;\n\nimport javax.el.*;\nimport java.lang.reflect.Method;\n\n/**\n *  This ELContext implementation provides support for standard BeanEL resolution in conditional message handlers.\n *  The message parameter of the message handlers is bound to 'msg' such that it can be referenced int the EL expressions.\n *\n *  Example:\n *  @Handler(condition = \"msg.type == 'onClick'\")\n *  public void handle(ButtonEvent event)\n *\n */\npublic class StandardELResolutionContext extends ELContext {\n\n\tprivate final ELResolver resolver;\n\tprivate final FunctionMapper functionMapper;\n\tprivate final VariableMapper variableMapper;\n    private final Object message;\n\n\n\tpublic StandardELResolutionContext(Object message) {\n\t\tsuper();\n        this.message = message;\n\t\tthis.functionMapper = new NoopFunctionMapper();\n\t\tthis.variableMapper = new MsgMapper();\n        // Composite resolver not necessary as the only resolution type currently supported is standard BeanEL\n\t\t//this.resolver = new CompositeELResolver();\n        this.resolver = new BeanELResolver(true);\n\t}\n\t\n\n\n\t/*************************************************************************\n\t * The resolver for the event object.\n\t * @see javax.el.ELContext#getELResolver()\n\t ************************************************************************/\n\t@Override\n\tpublic ELResolver getELResolver() {\n\t\treturn this.resolver;\n\t}\n\n\t/*************************************************************************\n\t * @see javax.el.ELContext#getFunctionMapper()\n\t ************************************************************************/\n\t@Override\n\tpublic FunctionMapper getFunctionMapper() {\n\t\treturn this.functionMapper;\n\t}\n\n\t/*************************************************************************\n\t * @see javax.el.ELContext#getVariableMapper()\n\t ************************************************************************/\n\t@Override\n\tpublic VariableMapper getVariableMapper() {\n\t\treturn this.variableMapper;\n\t}\n\n    /**\n     * This mapper resolves the variable identifies \"msg\" to the message\n     * object of the current handler invocation\n     */\n\tprivate class MsgMapper extends VariableMapper {\n        private static final String msg = \"msg\";\n        // reuse the same expression as it always resolves to the same object\n        private final ValueExpression msgExpression = ElFilter.ELFactory().createValueExpression(message, message.getClass());\n\n\t\tpublic ValueExpression resolveVariable(final String s) {\n            // resolve 'msg' to the message object of the handler invocation\n            return !s.equals(msg) ? null : msgExpression;\n\t\t}\n\n\t\tpublic ValueExpression setVariable(String s,\n\t\t\t\tValueExpression valueExpression) {\n            // not necessary - the mapper resolves only \"msg\" and nothing else\n\t\t\treturn null;\n\t\t}\n\t}\n\n    /**\n     * This function mapper does nothing, i.e. custom EL functions are not\n     * supported by default. It may be supported in the future to pass in\n     * custom function mappers at bus instanciation time.\n     */\n\tprivate class NoopFunctionMapper extends FunctionMapper {\n\t\tpublic Method resolveFunction(String s, String s1) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n}\n","src/test/java/net/engio/mbassy/common/MessageManager.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.messages.IMessage;\n\nimport java.util.Collection;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Created with IntelliJ IDEA.\n * User: benjamin\n * Date: 6/26/13\n * Time: 12:23 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class MessageManager {\n\tprivate static final Logger LOG =\n\t\t\tLoggerFactory.getLogger(MessageManager.class);\n\n\n    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();\n\n\n    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void waitForMessages(int timeoutInMs){\n        long start = System.currentTimeMillis();\n        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){\n            // check each created message once\n            for(MessageContext messageCtx : messages){\n                boolean handledCompletely = true;\n                for(Class listener : messageCtx.getListeners()){\n                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();\n                }\n                // remove the ones that were handled as expected\n                if(handledCompletely){\n                    logSuccess(messageCtx);\n                    messages.remove(messageCtx);\n                }\n\n            }\n            pause(100);\n        }\n        if(messages.size() > 0){\n            logFailingMessages(messages);\n            throw new RuntimeException(\"Message were not fully processed in given time\");\n        }\n\n\n    }\n\n    private void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n   private void logSuccess(MessageContext mCtx){\n       LOG.info(\"Message \" + mCtx.getMessage() + \" was successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n   }\n\n\n\n    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append(\"Failing messages:\\n\");\n        for(MessageContext failingMessage : failing)\n            errorMessage.append(failingMessage);\n        LOG.info(errorMessage.toString());\n    }\n\n    private class MessageContext{\n\n        private long expectedCount;\n        private IMessage message;\n        private Class[] listeners;\n\n        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners;\n        }\n\n        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners.toArray(new Class[]{});\n        }\n\n        private long getExpectedCount() {\n            return expectedCount;\n        }\n\n        private IMessage getMessage() {\n            return message;\n        }\n\n        private Class[] getListeners() {\n            return listeners;\n        }\n\n        private String printListeners(){\n            StringBuilder listenersAsString = new StringBuilder();\n            for(Class listener : listeners){\n                listenersAsString.append(listener.getName());\n                listenersAsString.append(\",\");\n            }\n            return listenersAsString.toString();\n        }\n\n        @Override\n        public String toString() {\n            // TODO: actual count of listeners\n            return message.getClass().getSimpleName() + \"{\" +\n                    \"expectedCount=\" + expectedCount +\n                    \", listeners=\" + printListeners() +\n                    '}';\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: modified to pass ExceptionCounter via the configuration object\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new IncrementingMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n        //DS: added errorHandler parameter to allow adding handler from caller\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n            if (errorHandler != null) {\n                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);\n            }\n            return new MBassador(asyncFIFOConfig);\n\n        }\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n            if (errorHandler != null) {\n                syncPubSubCfg.addPublicationErrorHandler(errorHandler);\n            }\n            return new SyncMessageBus(syncPubSubCfg);\n        }\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n    }\n\n\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else throw new RuntimeException(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n        try {\n            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationError);\n            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandler().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandler().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandler().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandler().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        StrongConcurrentSetTest.class,\n        WeakConcurrentSetTest.class,\n        SyncAsyncTest.class,\n        SyncBusTest.MBassadorTest.class,\n        SyncBusTest.SyncMessageBusTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        MethodDispatchTest.class,\n        DeadMessageTest.class,\n        SynchronizedHandlerTest.class,\n        SubscriptionManagerTest.class,\n        AsyncFIFOBusTest.class,\n        ConditionalHandlers.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/listeners/ExceptionThrowingListener.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\nimport net.engio.mbassy.messages.StandardMessage;\n\n/**\n * @author bennidi\n *         Date: 5/25/13\n */\n@Listener(references = References.Strong)\npublic class ExceptionThrowingListener {\n\n\n    // this handler will be invoked asynchronously\n    @Handler()\n    public void handle(StandardMessage message) {\n        throw new RuntimeException(\"This is an expected exception\");\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/Properties.java":"package net.engio.mbassy.bus.common;\n\n/**\n * A collection of properties commonly used by different parts of the library.\n *\n * @author bennidi\n *         Date: 22.02.15\n */\npublic final class Properties {\n\n    public static final class Handler {\n\n        public static final String PublicationError = \"bus.handlers.error\";\n        public static final String AsynchronousHandlerExecutor = \"bus.handlers.async-executor\";\n    }\n\n    public static final class Common {\n\n        public static final String Id = \"bus.id\";\n    }\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/IMessageBus.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\n/**\n * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n * A message publication starts when an object is send to the bus using one of the its publication methods.\n *\n * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n *\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n * in a synchronized fashion using @Synchronized annotation\n *\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n *\n * <p/>\n * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n *\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the respective message handlers.\n *\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n *\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n *\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends GenericMessagePublicationSupport<T, P>{\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    P post(T message);\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return true if any unfinished message publications are found\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.Collection;\n\n/**\n * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n * may not be accessible due to security constraints or is not annotated properly.\n * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n * Error handlers can be added via the {@link IBusConfiguration}.\n *\n */\n\npublic interface ErrorHandlingSupport {\n\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: Exception counter added via config\n        IBusConfiguration config = SyncAsync();\n        config.addPublicationErrorHandler(ExceptionCounter);\n        final MBassador bus = new MBassador(config);\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).asynchronously();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java":"package net.engio.mbassy.bus;\n\nimport com.mycila.testing.junit.MycilaJunitRunner;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.MessageBusTest;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Added for changes proposed under https://github.com/bennidi/mbassador/issues/106\n * <p/>\n * Created by David Sowerby on 13/04/15.\n */\n@RunWith(MycilaJunitRunner.class)\npublic class AbstractPubSubSupportTest {\n\n    IBusConfiguration configuration;\n\n    @Mock\n    IPublicationErrorHandler handler1;\n\n    @Mock\n    IPublicationErrorHandler handler2;\n\n    @Mock\n    IPublicationErrorHandler handler3;\n\n    @Mock\n    PublicationError publicationError;\n\n\n    @Before\n    public void setup() {\n        configuration = MessageBusTest.SyncAsync();\n    }\n\n\n    @Test\n    public void testHandlePublicationError_handlers_present_sync() {\n        //given\n\n        configuration.addPublicationErrorHandler(handler1);\n        configuration.addPublicationErrorHandler(handler2);\n        configuration.addPublicationErrorHandler(handler3);\n        //when\n        SyncMessageBus<String> bus = new SyncMessageBus<String>(configuration);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n        verify(handler2).handleError(publicationError);\n        verify(handler3).handleError(publicationError);\n    }\n\n    @Test\n    public void testHandlePublicationError_handlers_present_async() {\n        //given\n\n        configuration.addPublicationErrorHandler(handler1);\n        configuration.addPublicationErrorHandler(handler2);\n        configuration.addPublicationErrorHandler(handler3);\n        //when\n        MBassador<String> bus = new MBassador<String>(configuration);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n        verify(handler2).handleError(publicationError);\n        verify(handler3).handleError(publicationError);\n    }\n\n\n    @Test\n    public void testHandlePublicationError_construct_with_handler_sync() {\n        //given\n\n        //when\n        SyncMessageBus<String> bus = new SyncMessageBus<String>(handler1);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n    }\n\n    @Test\n    public void testHandlePublicationError_constrcut_with_handler_async() {\n        //given\n\n        configuration.addPublicationErrorHandler(handler1);\n        //when\n        MBassador<String> bus = new MBassador<String>(handler1);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n    }\n\n    @Test\n    public void testHandlePublicationError_no_handlers_present_construct_with_config_async() {\n        //given\n        final String errorMsg = \"Test error\";\n        when(publicationError.toString()).thenReturn(errorMsg);\n        PrintStream old = null;\n\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream ps = new PrintStream(baos);\n            old = System.out;\n            System.setOut(ps);\n            //when\n            MBassador<String> bus = new MBassador<String>(configuration);\n            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n            bus.handlePublicationError(publicationError);\n            //then\n            assertThat(baos.toString()).contains(errorMsg);\n\n        } finally {\n            System.out.flush();\n            if (old != null) {\n                System.setOut(old);\n            }\n        }\n\n    }\n\n    @Test\n    public void testHandlePublicationError_default_construct_sync() {\n        //given\n        final String errorMsg = \"Test error\";\n        when(publicationError.toString()).thenReturn(errorMsg);\n        PrintStream old = null;\n\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream ps = new PrintStream(baos);\n            old = System.out;\n            System.setOut(ps);\n            //when\n            SyncMessageBus<String> bus = new SyncMessageBus<String>();\n            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n            bus.handlePublicationError(publicationError);\n            //then\n            assertThat(baos.toString()).contains(errorMsg);\n\n        } finally {\n            System.out.flush();\n            if (old != null) {\n                System.setOut(old);\n            }\n        }\n    }\n\n    @Test\n    public void testHandlePublicationError_default_construct_async() {\n        //given\n        final String errorMsg = \"Test error\";\n        when(publicationError.toString()).thenReturn(errorMsg);\n        PrintStream old = null;\n\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream ps = new PrintStream(baos);\n            old = System.out;\n            System.setOut(ps);\n            //when\n            MBassador<String> bus = new MBassador<String>();\n            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n            bus.handlePublicationError(publicationError);\n            //then\n            assertThat(baos.toString()).contains(errorMsg);\n\n        } finally {\n            System.out.flush();\n            if (old != null) {\n                System.setOut(old);\n            }\n        }\n\n    }\n\n\n}","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.*;\n\nimport static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n    public static final String ERROR_HANDLER_MSG = \"INFO: No error handler has been configured to handle exceptions during publication.\\n\" +\n            \"Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\\n\" +\n            \"Falling back to console logger.\";\n\n\n\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n\n        //transfer publication error handlers from the config object\n        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());\n        if (errorHandlers.isEmpty()) {\n            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n            System.out.println(ERROR_HANDLER_MSG);\n        }\n        this.runtime = new BusRuntime(this).add(PublicationError, getRegisteredErrorHandlers())\n                                           .add(Properties.Common.Id, UUID.randomUUID()\n                                                                          .toString());\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n                                                                          .equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n    }\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n\n        private boolean failOnException;\n\n        public AssertionErrorHandler(boolean failOnException) {\n            this.failOnException = failOnException;\n        }\n\n        @Override\n        public void handleError(PublicationError error) {\n            if(failOnException)\n                org.junit.Assert.fail(error.getCause().getMessage());\n        }\n    }\n\n    public static final class EmptyErrorHandler implements IPublicationErrorHandler{\n\n        @Override\n        public void handleError(PublicationError error) {\n        }\n    }\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return SyncAsync(true);\n    }\n\n    public static IBusConfiguration SyncAsync(boolean failOnError) {\n        IBusConfiguration config = new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n        if(failOnError)\n            config.addPublicationErrorHandler(new AssertionErrorHandler(failOnError));\n        return config;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Message filters can be used to control what messages are delivered to a specific message handler.\n * Filters are attached to message handler using the @Listener annotation.\n * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n * The handler will be invoked only if each filter accepted the message.\n *\n * Example:\n *\n * <pre>\n * <code>\n * {@literal @}Listener\n * {@literal @}Filters(Urlfilter.class)\n * public void someHandler(String message){...}\n *\n * class Urlfilter implements IMessageFilter<String>{\n *     public boolean accepts(String message, MessageHandler metadata){\n *         return message.startsWith(\"http\");\n *     }\n * }\n *\n * bus.post(\"http://www.infoq.com\"); // will be delivered\n * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n *\n * </code>\n * </pre>\n *\n * NOTE: A message filter must provide a no-arg constructor!!!\n *\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic interface IMessageFilter<M> {\n\n    /**\n     * Check whether the message matches some criteria\n     *\n     * @param message The message to be handled by the handler\n     * @param  context The context object containing a description of the message handler and the bus environment\n     * @return  true: if the message matches the criteria and should be delivered to the handler\n     *          false: otherwise\n     */\n    boolean accepts(M message, SubscriptionContext context);\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n *\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener(){\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener(){\n        ListenerFactory listeners = listeners(\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class,\n                MessagesListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener(){\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener,  sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers(){\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testPrioritizedMessageHandlers(){\n        ListenerFactory listeners = listeners(PrioritizedListener.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private BusRuntime mockedRuntime(){\n        return new BusRuntime(null)\n                .add(Properties.Handler.PublicationErrorHandlers, Collections.EMPTY_SET)\n                .add(Properties.Handler.AsynchronousHandlerExecutor, null);\n    }\n\n    private ListenerFactory listeners(Class ...listeners){\n        ListenerFactory factory = new ListenerFactory();\n        for(Class listener : listeners){\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n    /**\n     *  define handlers with different priorities which need to be executed\n     *  in their respective order\n     */\n    public static class PrioritizedListener{\n\n\n        @net.engio.mbassy.listener.Handler(priority = 1)\n        public void handlePrio1(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 2)\n        public void handlePrio2(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 3)\n        public void handlePrio3(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 4)\n        public void handlePrio4(IMessage message){\n            message.handled(this.getClass());\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/el/StandardELResolutionContext.java":"package net.engio.mbassy.dispatch.el;\n\nimport javax.el.*;\nimport java.lang.reflect.Method;\n\n/**\n *  This ELContext implementation provides support for standard BeanEL resolution in conditional message handlers.\n *  The message parameter of the message handlers is bound to 'msg' such that it can be referenced int the EL expressions.\n *\n *  <pre>\n *  <code>\n *  {@literal @}Handler(condition = \"msg.type == 'onClick'\")\n *  public void handle(ButtonEvent event)\n *  </code>\n *  </pre>\n */\npublic class StandardELResolutionContext extends ELContext {\n\n\tprivate final ELResolver resolver;\n\tprivate final FunctionMapper functionMapper;\n\tprivate final VariableMapper variableMapper;\n    private final Object message;\n\n\n\tpublic StandardELResolutionContext(Object message) {\n\t\tsuper();\n        this.message = message;\n\t\tthis.functionMapper = new NoopFunctionMapper();\n\t\tthis.variableMapper = new MsgMapper();\n        // Composite resolver not necessary as the only resolution type currently supported is standard BeanEL\n\t\t//this.resolver = new CompositeELResolver();\n        this.resolver = new BeanELResolver(true);\n\t}\n\t\n\n\n\t/*************************************************************************\n\t * The resolver for the event object.\n\t * @see javax.el.ELContext#getELResolver()\n\t ************************************************************************/\n\t@Override\n\tpublic ELResolver getELResolver() {\n\t\treturn this.resolver;\n\t}\n\n\t/*************************************************************************\n\t * @see javax.el.ELContext#getFunctionMapper()\n\t ************************************************************************/\n\t@Override\n\tpublic FunctionMapper getFunctionMapper() {\n\t\treturn this.functionMapper;\n\t}\n\n\t/*************************************************************************\n\t * @see javax.el.ELContext#getVariableMapper()\n\t ************************************************************************/\n\t@Override\n\tpublic VariableMapper getVariableMapper() {\n\t\treturn this.variableMapper;\n\t}\n\n    /**\n     * This mapper resolves the variable identifies \"msg\" to the message\n     * object of the current handler invocation\n     */\n\tprivate class MsgMapper extends VariableMapper {\n        private static final String msg = \"msg\";\n        // reuse the same expression as it always resolves to the same object\n        private final ValueExpression msgExpression = ElFilter.ELFactory().createValueExpression(message, message.getClass());\n\n\t\tpublic ValueExpression resolveVariable(final String s) {\n            // resolve 'msg' to the message object of the handler invocation\n            return !s.equals(msg) ? null : msgExpression;\n\t\t}\n\n\t\tpublic ValueExpression setVariable(String s,\n\t\t\t\tValueExpression valueExpression) {\n            // not necessary - the mapper resolves only \"msg\" and nothing else\n\t\t\treturn null;\n\t\t}\n\t}\n\n    /**\n     * This function mapper does nothing, i.e. custom EL functions are not\n     * supported by default. It may be supported in the future to pass in\n     * custom function mappers at bus instanciation time.\n     */\n\tprivate class NoopFunctionMapper extends FunctionMapper {\n\t\tpublic Method resolveFunction(String s, String s1) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n}\n","src/test/java/net/engio/mbassy/common/MessageManager.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.messages.IMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * User: benjamin\n * Date: 6/26/13\n * Time: 12:23 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class MessageManager {\n\tprivate static final Logger LOG =\n\t\t\tLoggerFactory.getLogger(MessageManager.class);\n\n\n    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();\n\n\n    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void waitForMessages(int timeoutInMs){\n        long start = System.currentTimeMillis();\n        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){\n            // check each created message once\n            for(MessageContext messageCtx : messages){\n                boolean handledCompletely = true;\n                for(Class listener : messageCtx.getListeners()){\n                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();\n                }\n                // remove the ones that were handled as expected\n                if(handledCompletely){\n                    logSuccess(messageCtx);\n                    messages.remove(messageCtx);\n                }\n\n            }\n            pause(100);\n        }\n        if(messages.size() > 0){\n            logFailingMessages(messages);\n            throw new RuntimeException(\"Message were not fully processed in given time\");\n        }\n\n\n    }\n\n    private void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n   private void logSuccess(MessageContext mCtx){\n       LOG.info(mCtx.getMessage().getClass().getSimpleName() + \" successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n   }\n\n\n\n    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append(\"Failing messages:\\n\");\n        for(MessageContext failingMessage : failing)\n            errorMessage.append(failingMessage);\n        LOG.info(errorMessage.toString());\n    }\n\n    private class MessageContext{\n\n        private long expectedCount;\n        private IMessage message;\n        private Class[] listeners;\n\n        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners;\n        }\n\n        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners.toArray(new Class[]{});\n        }\n\n        private long getExpectedCount() {\n            return expectedCount;\n        }\n\n        private IMessage getMessage() {\n            return message;\n        }\n\n        private Class[] getListeners() {\n            return listeners;\n        }\n\n        private String printListeners(){\n            StringBuilder listenersAsString = new StringBuilder();\n            for(Class listener : listeners){\n                listenersAsString.append(listener.getName());\n                listenersAsString.append(\",\");\n            }\n            return listenersAsString.toString();\n        }\n\n        @Override\n        public String toString() {\n            // TODO: actual count of listeners\n            return message.getClass().getSimpleName() + \"{\" +\n                    \"expectedCount=\" + expectedCount +\n                    \", listeners=\" + printListeners() +\n                    '}';\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: modified to pass ExceptionCounter via the configuration object\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n        exceptionCount.set(0); // reset for next test\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new IncrementingMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n        //DS: added errorHandler parameter to allow adding handler from caller\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n            if (errorHandler != null) {\n                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);\n            }\n            return new MBassador(asyncFIFOConfig);\n\n        }\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n            if (errorHandler != null) {\n                syncPubSubCfg.addPublicationErrorHandler(errorHandler);\n            }\n            return new SyncMessageBus(syncPubSubCfg);\n        }\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n    }\n\n\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else throw new RuntimeException(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n        try {\n            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationErrorHandlers);\n            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandler().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandler().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandler().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandler().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        StrongConcurrentSetTest.class,\n        WeakConcurrentSetTest.class,\n        SyncAsyncTest.class,\n        SyncBusTest.MBassadorTest.class,\n        SyncBusTest.SyncMessageBusTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        MethodDispatchTest.class,\n        DeadMessageTest.class,\n        SynchronizedHandlerTest.class,\n        SubscriptionManagerTest.class,\n        AsyncFIFOBusTest.class,\n        ConditionalHandlerTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/listeners/ExceptionThrowingListener.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\n\n/**\n * @author bennidi\n *         Date: 5/25/13\n */\n@Listener(references = References.Strong)\npublic class ExceptionThrowingListener {\n\n\n    @Handler()\n    public void handle(Object message) {\n        throw new RuntimeException(\"This is an expected exception\");\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/Properties.java":"package net.engio.mbassy.bus.common;\n\n/**\n * A collection of properties commonly used by different parts of the library.\n *\n * @author bennidi\n *         Date: 22.02.15\n */\npublic final class Properties {\n\n    public static final class Handler {\n\n        public static final String PublicationErrorHandlers = \"bus.handlers.error\";\n        public static final String AsynchronousHandlerExecutor = \"bus.handlers.async-executor\";\n    }\n\n    public static final class Common {\n\n        public static final String Id = \"bus.id\";\n    }\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/IMessageBus.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\n/**\n * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n * A message publication starts when an object is send to the bus using one of the its publication methods.\n *\n * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n *\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n * in a synchronized fashion using @Synchronized annotation\n *\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n *\n * <p/>\n * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n *\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the respective message handlers.\n *\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n *\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n *\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends GenericMessagePublicationSupport<T, P>{\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    P post(T message);\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return true if any unfinished message publications are found\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.Collection;\n\n/**\n * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n * may not be accessible due to security constraints or is not annotated properly.\n * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n * Error handlers can be added via the {@link IBusConfiguration}.\n *\n */\n\npublic interface ErrorHandlingSupport {\n\n\n    /**\n     * Get all registered instance of {@link IPublicationErrorHandler}\n     *\n     * @return  an immutable collection containing all the registered error handlers\n     */\n    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: Exception counter added via config\n        IBusConfiguration config = SyncAsync(false)\n            .addPublicationErrorHandler(ExceptionCounter);\n\n        final MBassador bus = new MBassador(config);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable asynchronousPublication = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).asynchronously();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java":"package net.engio.mbassy.bus;\n\nimport com.mycila.testing.junit.MycilaJunitRunner;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.MessageBusTest;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Added for changes proposed under https://github.com/bennidi/mbassador/issues/106\n * <p/>\n * Created by David Sowerby on 13/04/15.\n */\n@RunWith(MycilaJunitRunner.class)\npublic class AbstractPubSubSupportTest {\n\n    IBusConfiguration configuration;\n\n    @Mock\n    IPublicationErrorHandler handler1;\n\n    @Mock\n    IPublicationErrorHandler handler2;\n\n    @Mock\n    IPublicationErrorHandler handler3;\n\n    @Mock\n    PublicationError publicationError;\n\n\n    @Before\n    public void setup() {\n        configuration = MessageBusTest.SyncAsync(false);\n    }\n\n\n    @Test\n    public void testHandlePublicationError_handlers_present_sync() {\n        //given\n\n        configuration.addPublicationErrorHandler(handler1);\n        configuration.addPublicationErrorHandler(handler2);\n        configuration.addPublicationErrorHandler(handler3);\n        //when\n        SyncMessageBus<String> bus = new SyncMessageBus<String>(configuration);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n        verify(handler2).handleError(publicationError);\n        verify(handler3).handleError(publicationError);\n    }\n\n    @Test\n    public void testHandlePublicationError_handlers_present_async() {\n        //given\n\n        configuration.addPublicationErrorHandler(handler1);\n        configuration.addPublicationErrorHandler(handler2);\n        configuration.addPublicationErrorHandler(handler3);\n        //when\n        MBassador<String> bus = new MBassador<String>(configuration);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n        verify(handler2).handleError(publicationError);\n        verify(handler3).handleError(publicationError);\n    }\n\n\n    @Test\n    public void testHandlePublicationError_construct_with_handler_sync() {\n        //given\n\n        //when\n        SyncMessageBus<String> bus = new SyncMessageBus<String>(handler1);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n    }\n\n    @Test\n    public void testHandlePublicationError_constrcut_with_handler_async() {\n        //given\n\n        configuration.addPublicationErrorHandler(handler1);\n        //when\n        MBassador<String> bus = new MBassador<String>(handler1);\n        bus.handlePublicationError(publicationError);\n        //then\n        verify(handler1).handleError(publicationError);\n    }\n\n    /**\n     * Test configuration that does not provide a publication error handler.\n     * This should print a warning message and fallback to STDOUT handler\n     */\n    @Test\n    public void testHandlePublicationError_no_handlers_present_construct_with_config_async() {\n        //given\n        PrintStream old = null;\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream ps = new PrintStream(baos);\n            old = System.out;\n            System.setOut(ps);\n            //when no publication error handler is provided\n            MBassador<String> bus = new MBassador<String>(configuration);\n            // then we see the warning on the console\n            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n        } finally {\n            System.out.flush();\n            if (old != null) {\n                System.setOut(old);\n            }\n        }\n\n    }\n\n    @Test\n    public void testHandlePublicationError_default_construct_sync() {\n        //given\n        final String errorMsg = \"Test error\";\n        when(publicationError.toString()).thenReturn(errorMsg);\n        PrintStream old = null;\n\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream ps = new PrintStream(baos);\n            old = System.out;\n            System.setOut(ps);\n            //when\n            SyncMessageBus<String> bus = new SyncMessageBus<String>();\n            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n            bus.handlePublicationError(publicationError);\n            //then\n            assertThat(baos.toString()).contains(errorMsg);\n\n        } finally {\n            System.out.flush();\n            if (old != null) {\n                System.setOut(old);\n            }\n        }\n    }\n\n    @Test\n    public void testHandlePublicationError_default_construct_async() {\n        //given\n        final String errorMsg = \"Test error\";\n        when(publicationError.toString()).thenReturn(errorMsg);\n        PrintStream old = null;\n\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream ps = new PrintStream(baos);\n            old = System.out;\n            System.setOut(ps);\n            //when\n            MBassador<String> bus = new MBassador<String>();\n            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);\n            bus.handlePublicationError(publicationError);\n            //then\n            assertThat(baos.toString()).contains(errorMsg);\n\n        } finally {\n            System.out.flush();\n            if (old != null) {\n                System.setOut(old);\n            }\n        }\n\n    }\n\n\n}","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.*;\n\nimport static net.engio.mbassy.bus.common.Properties.Handler.PublicationErrorHandlers;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n    public static final String ERROR_HANDLER_MSG = \"INFO: No error handler has been configured to handle exceptions during publication.\\n\" +\n            \"Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\\n\" +\n            \"Falling back to console logger.\";\n\n\n\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n\n        //transfer publication error handlers from the config object\n        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());\n        if (errorHandlers.isEmpty()) {\n            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n            System.out.println(ERROR_HANDLER_MSG);\n        }\n        this.runtime = new BusRuntime(this).add(PublicationErrorHandlers, getRegisteredErrorHandlers())\n                                           .add(Properties.Common.Id, UUID.randomUUID()\n                                                                          .toString());\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n                                                                          .equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    protected void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n    }\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":[[59,60]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[217,217]],"src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java":[[20,20]],"src/test/java/net/engio/mbassy/SyncAsyncTest.java":[[136,136],[137,137],[144,144],[147,147],[153,153],[160,160]],"src/test/java/net/engio/mbassy/common/MessageManager.java":[[98,98]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[104,104]],"src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java":[[108,108],[109,109],[120,120],[122,122]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[24,24]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[49,49],[102,102]]},"postChangeRange":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":[[66,67],[70,71],[72,72]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[217,217]],"src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java":[[20,20],[22,22]],"src/test/java/net/engio/mbassy/SyncAsyncTest.java":[[136,137],[144,144],[147,147],[152,152],[159,159]],"src/test/java/net/engio/mbassy/common/MessageManager.java":[[97,97]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[104,104],[110,110]],"src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java":[[45,45],[105,108]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[24,24]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[49,49],[102,102]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/common/MessageBusTest.java","startLine":70,"endLine":70}]}],"refactorings":[]},{"repository":"mbassador","sha1":"4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e","url":"https://github.com/bennidi/mbassador/commit/4a4b355a7f6a1a88deae429f66cc4995fa7dbe3e","preChangeSourceCode":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n\n        private boolean failOnException;\n\n        public AssertionErrorHandler(boolean failOnException) {\n            this.failOnException = failOnException;\n        }\n\n        @Override\n        public void handleError(PublicationError error) {\n            if(failOnException)\n                org.junit.Assert.fail(error.getCause().getMessage());\n        }\n    }\n\n    public static final class EmptyErrorHandler implements IPublicationErrorHandler{\n\n        @Override\n        public void handleError(PublicationError error) {\n        }\n    }\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return SyncAsync(true);\n    }\n\n    public static IBusConfiguration SyncAsync(boolean failOnError) {\n        IBusConfiguration config = new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n        if(failOnError)\n            config.addPublicationErrorHandler(new AssertionErrorHandler(failOnError));\n        return config;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListener.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * All instances of any class that defines at least one message handler (see @MessageHandler) are message listeners. Thus,\n * a message listener is any object capable of receiving messages by means of defined message handlers.\n * There are no restrictions about the number of allowed message handlers in a message listener.\n *\n * A message listener can be configured using the @Listener annotation but is always implicitly configured by the handler\n * definition it contains.\n *\n * This class is an internal representation of a message listener used to encapsulate all relevant objects\n * and data about that message listener, especially all its handlers.\n * There will be only one instance of MessageListener per message listener class and message bus instance.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListener<T> {\n\n\n    public static IPredicate<MessageHandler> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandler>() {\n            @Override\n            public boolean apply(MessageHandler target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandler> handlers = new ArrayList<MessageHandler>();\n\n    private Class<T> listenerDefinition;\n\n    private Listener listenerAnnotation;\n\n    public MessageListener(Class<T> listenerDefinition) {\n       this.listenerDefinition = listenerDefinition;\n       listenerAnnotation = ReflectionUtils.getAnnotation( listenerDefinition, Listener.class );\n    }\n\n\n    public boolean isFromListener(Class listener){\n        return listenerDefinition.equals(listener);\n    }\n\n    public boolean useStrongReferences(){\n        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n    }\n\n    public MessageListener addHandlers(Collection<? extends MessageHandler> c) {\n        handlers.addAll(c);\n        return this;\n    }\n\n    public boolean addHandler(MessageHandler messageHandler) {\n        return handlers.add(messageHandler);\n    }\n\n    public List<MessageHandler> getHandlers(){\n        return handlers;\n    }\n\n    public List<MessageHandler> getHandlers(IPredicate<MessageHandler> filter) {\n        List<MessageHandler> matching = new LinkedList<MessageHandler>();\n        for (MessageHandler handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.listener.MessageListener;\nimport org.junit.Test;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListener.ForMessage;\n\n/**\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends AssertSupport {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListener<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    /*\n    public void testInterfaced() {\n        MessageListener listener = reader.getMessageListener(InterfacedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, Object.class);\n        validator.check(listener);\n    }  WIP */\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListener<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListener<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListener<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListener listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class MessageListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class MessageListener2 extends MessageListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class MessageListener3 extends MessageListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = Number.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = Integer.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public static interface ListenerInterface{\n\n        @Handler\n        @Enveloped(messages = Object.class)\n        void handle(MessageEnvelope envelope);\n    }\n\n    public class InterfacedListener implements  ListenerInterface{\n\n        @Override\n        public void handle(MessageEnvelope envelope) {\n            //\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n * @author dorkbox\n *         Date: 22/2/15\n */\npublic abstract class AbstractConcurrentSet<T> implements Set<T> {\n    private static final AtomicLong id = new AtomicLong();\n    private final long ID = id.getAndIncrement();\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public boolean add(T element) {\n        if (element == null) return false;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        boolean changed = insert(element);\n        writeLock.unlock();\n        return changed;\n    }\n\n    @Override\n    public boolean contains(Object element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private boolean insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> elements) {\n        boolean changed = false;\n\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    changed |= insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean remove(Object element) {\n        if (!contains(element)) {\n            // return quickly\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    // if it was second, now it's first\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        return this.entries.entrySet().toArray();\n    }\n\n    @SuppressWarnings(\"hiding\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return this.entries.entrySet().toArray(a);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public void clear() {\n        Lock writeLock = this.lock.writeLock();\n        try {\n            writeLock.lock();\n                head = null;\n                entries.clear();\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"rawtypes\")\n        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n        if (this.ID != other.ID) {\n            return false;\n        }\n        return true;\n    }\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // can not nullify references to help GC since running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/IMessageListener.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.messages.IMessage;\n\n/**\n *\n * @author bennidi\n *         Date: 5/24/13\n */\npublic class IMessageListener {\n\n    private static abstract class BaseListener {\n\n        @Handler\n        public void handle(IMessage message){\n            message.handled(this.getClass());\n        }\n\n    }\n\n    public static class DefaultListener extends BaseListener {\n\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n    }\n\n    public static class NoSubtypesListener extends BaseListener {\n\n        @Handler(rejectSubtypes = true)\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n    }\n\n\n    public static class AsyncListener extends BaseListener {\n\n        @Handler(delivery = Invoke.Asynchronously)\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n\n    }\n\n    public static class DisabledListener extends BaseListener {\n\n        @Handler(enabled = false)\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: Exception counter added via config\n        IBusConfiguration config = SyncAsync(false)\n            .addPublicationErrorHandler(ExceptionCounter);\n\n        final MBassador bus = new MBassador(config);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable asynchronousPublication = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).asynchronously();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/Listeners.java":"package net.engio.mbassy.listeners;\n\nimport java.util.*;\n\n/**\n * Created with IntelliJ IDEA.\n * User: benjamin\n * Date: 6/26/13\n * Time: 11:48 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class Listeners {\n\n    private static final List<Class> Synchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.DefaultListener.class,\n            IMessageListener.DefaultListener.class,\n            StandardMessageListener.DefaultListener.class,\n            MultipartMessageListener.DefaultListener.class,\n            ICountableListener.DefaultListener.class,\n            IMultipartMessageListener.DefaultListener.class}));\n\n    private static final List<Class> Asynchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.AsyncListener.class,\n            IMessageListener.AsyncListener.class,\n            StandardMessageListener.AsyncListener.class,\n            MultipartMessageListener.AsyncListener.class,\n            ICountableListener.AsyncListener.class,\n            IMultipartMessageListener.AsyncListener.class}));\n\n    private static final List<Class> SubtypeRejecting = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.NoSubtypesListener.class,\n            IMessageListener.NoSubtypesListener.class,\n            StandardMessageListener.NoSubtypesListener.class,\n            MultipartMessageListener.NoSubtypesListener.class,\n            ICountableListener.NoSubtypesListener.class,\n            IMultipartMessageListener.NoSubtypesListener.class}));\n\n    private static final List<Class> NoHandlers = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.DisabledListener.class,\n            IMessageListener.DisabledListener.class,\n            StandardMessageListener.DisabledListener.class,\n            MultipartMessageListener.DisabledListener.class,\n            ICountableListener.DisabledListener.class,\n            IMultipartMessageListener.DisabledListener.class,\n            Object.class,String.class}));\n\n\n    private static final List<Class> HandlesIMessage = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            IMessageListener.DefaultListener.class,\n            IMessageListener.AsyncListener.class,\n            IMessageListener.NoSubtypesListener.class,\n            IMultipartMessageListener.DefaultListener.class,\n            IMultipartMessageListener.AsyncListener.class,\n            IMultipartMessageListener.NoSubtypesListener.class,\n            MessagesListener.DefaultListener.class,\n            MessagesListener.AsyncListener.class,\n            MessagesListener.NoSubtypesListener.class,\n            StandardMessageListener.DefaultListener.class,\n            StandardMessageListener.AsyncListener.class,\n            StandardMessageListener.NoSubtypesListener.class,\n            MultipartMessageListener.DefaultListener.class,\n            MultipartMessageListener.AsyncListener.class,\n            MultipartMessageListener.NoSubtypesListener.class}));\n\n    private static final List<Class> HandlesStandardessage = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            IMessageListener.DefaultListener.class,\n            IMessageListener.AsyncListener.class,\n            ICountableListener.DefaultListener.class,\n            ICountableListener.AsyncListener.class,\n            StandardMessageListener.DefaultListener.class,\n            StandardMessageListener.AsyncListener.class,\n            StandardMessageListener.NoSubtypesListener.class}));\n\n\n    public static Collection<Class> synchronous(){\n        return Synchronous;\n    }\n\n    public static Collection<Class> asynchronous(){\n        return Asynchronous;\n    }\n\n    public static Collection<Class> subtypeRejecting(){\n        return SubtypeRejecting;\n    }\n\n    public static Collection<Class> noHandlers(){\n        return NoHandlers;\n    }\n\n    public static Collection<Class> handlesIMessage(){\n        return HandlesIMessage;\n    }\n\n    public static Collection<Class> handlesStandardMessage(){\n        return HandlesStandardessage;\n    }\n\n\n    public static Collection<Class> join(Collection<Class>...listenerSets){\n        Set<Class> join = new HashSet<Class>();\n        for(Collection<Class> listeners : listenerSets)\n            join.addAll(listeners);\n        for(Collection<Class> listeners : listenerSets)\n            join.retainAll(listeners);\n        return join;\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/common/MessageManager.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.messages.IMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * User: benjamin\n * Date: 6/26/13\n * Time: 12:23 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class MessageManager {\n\tprivate static final Logger LOG =\n\t\t\tLoggerFactory.getLogger(MessageManager.class);\n\n\n    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();\n\n\n    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void waitForMessages(int timeoutInMs){\n        long start = System.currentTimeMillis();\n        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){\n            // check each created message once\n            for(MessageContext messageCtx : messages){\n                boolean handledCompletely = true;\n                for(Class listener : messageCtx.getListeners()){\n                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();\n                }\n                // remove the ones that were handled as expected\n                if(handledCompletely){\n                    logSuccess(messageCtx);\n                    messages.remove(messageCtx);\n                }\n\n            }\n            pause(100);\n        }\n        if(messages.size() > 0){\n            logFailingMessages(messages);\n            throw new RuntimeException(\"Message were not fully processed in given time\");\n        }\n\n\n    }\n\n    private void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n   private void logSuccess(MessageContext mCtx){\n       LOG.info(mCtx.getMessage().getClass().getSimpleName() + \" successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n   }\n\n\n\n    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append(\"Failing messages:\\n\");\n        for(MessageContext failingMessage : failing)\n            errorMessage.append(failingMessage);\n        LOG.info(errorMessage.toString());\n    }\n\n    private class MessageContext{\n\n        private long expectedCount;\n        private IMessage message;\n        private Class[] listeners;\n\n        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners;\n        }\n\n        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners.toArray(new Class[]{});\n        }\n\n        private long getExpectedCount() {\n            return expectedCount;\n        }\n\n        private IMessage getMessage() {\n            return message;\n        }\n\n        private Class[] getListeners() {\n            return listeners;\n        }\n\n        private String printListeners(){\n            StringBuilder listenersAsString = new StringBuilder();\n            for(Class listener : listeners){\n                listenersAsString.append(listener.getName());\n                listenersAsString.append(\",\");\n            }\n            return listenersAsString.toString();\n        }\n\n        @Override\n        public String toString() {\n            // TODO: actual count of listeners\n            return message.getClass().getSimpleName() + \"{\" +\n                    \"expectedCount=\" + expectedCount +\n                    \", listeners=\" + printListeners() +\n                    '}';\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n\n\n    public WeakConcurrentSet() {\n        super(new WeakHashMap<T, ISetEntry<T>>());\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            // the current listelement of this iterator\n            // used to keep track of the iteration process\n            private ISetEntry<T> current = head;\n\n            // this method will remove all orphaned entries\n            // until it finds the first entry whose value has not yet been garbage collected\n            // the method assumes that the current element is already orphaned and will remove it\n            private void removeOrphans(){\n                Lock writelock = lock.writeLock();\n                try{\n                    writelock.lock();\n                    do {\n                        ISetEntry orphaned = current;\n                        current = current.next();\n                        orphaned.remove();\n                    } while(current != null && current.getValue() == null);\n                }\n                finally {\n                    writelock.unlock();\n                }\n            }\n\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                if (current.getValue() == null) {\n                // trigger removal of orphan references\n                // because a null value indicates that the value has been garbage collected\n                    removeOrphans();\n                    return current != null; // if any entry is left then it will have a value\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    removeOrphans();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                //throw new UnsupportedOperationException(\"Explicit removal of set elements is only allowed via the controlling set. Sorry!\");\n                if (current == null) {\n                    return;\n                }\n                ISetEntry<T> newCurrent = current.next();\n                WeakConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n    @Override\n    protected Entry<T> createEntry(T value, Entry<T> next) {\n        return next != null ? new WeakEntry<T>(value, next) : new WeakEntry<T>(value);\n    }\n\n\n    public static class WeakEntry<T> extends Entry<T> {\n\n        private WeakReference<T> value;\n\n        private WeakEntry(T value, Entry<T> next) {\n            super(next);\n            this.value = new WeakReference<T>(value);\n        }\n\n        private WeakEntry(T value) {\n            super();\n            this.value = new WeakReference<T>(value);\n        }\n\n        @Override\n        public T getValue() {\n            return value.get();\n        }\n\n\n\n\n    }\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying platform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int waitForMessageTimeout = 60000;\n    protected static final int processingTimeInMS = 2000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n\n        private boolean failOnException;\n\n        public AssertionErrorHandler(boolean failOnException) {\n            this.failOnException = failOnException;\n        }\n\n        @Override\n        public void handleError(PublicationError error) {\n            if(failOnException)\n                org.junit.Assert.fail(error.getCause().getMessage());\n        }\n    }\n\n    public static final class EmptyErrorHandler implements IPublicationErrorHandler{\n\n        @Override\n        public void handleError(PublicationError error) {\n        }\n    }\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return SyncAsync(true);\n    }\n\n    public static IBusConfiguration SyncAsync(boolean failOnError) {\n        IBusConfiguration config = new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n        if(failOnError)\n            config.addPublicationErrorHandler(new AssertionErrorHandler(failOnError));\n        return config;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListener.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * All instances of any class defining at least one message handler @link MessageHandler are message listeners. Thus,\n * a message listener is any object capable of receiving messages by means of defined message handlers.\n * There are no restrictions about the number of allowed message handlers in a message listener.\n *\n * A message listener can be configured using the @Listener annotation but is always implicitly configured by the handler\n * definition it contains.\n *\n * This class is an internal representation of a message listener used to encapsulate all relevant objects\n * and data about that message listener, especially all its handlers.\n * There will be only one instance of MessageListener per message listener class and message bus instance.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListener<T> {\n\n\n    public static IPredicate<MessageHandler> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandler>() {\n            @Override\n            public boolean apply(MessageHandler target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandler> handlers = new ArrayList<MessageHandler>();\n\n    private Class<T> listenerDefinition;\n\n    private Listener listenerAnnotation;\n\n    public MessageListener(Class<T> listenerDefinition) {\n       this.listenerDefinition = listenerDefinition;\n       listenerAnnotation = ReflectionUtils.getAnnotation( listenerDefinition, Listener.class );\n    }\n\n\n    public boolean isFromListener(Class listener){\n        return listenerDefinition.equals(listener);\n    }\n\n    public boolean useStrongReferences(){\n        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n    }\n\n    public MessageListener addHandlers(Collection<? extends MessageHandler> c) {\n        handlers.addAll(c);\n        return this;\n    }\n\n    public boolean addHandler(MessageHandler messageHandler) {\n        return handlers.add(messageHandler);\n    }\n\n    public List<MessageHandler> getHandlers(){\n        return handlers;\n    }\n\n    public List<MessageHandler> getHandlers(IPredicate<MessageHandler> filter) {\n        List<MessageHandler> matching = new LinkedList<MessageHandler>();\n        for (MessageHandler handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.listener.MessageListener;\nimport net.engio.mbassy.listeners.SimpleHandler;\nimport org.junit.Test;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListener.ForMessage;\n\n/**\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends AssertSupport {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListener<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    /*\n    public void testInterfaced() {\n        MessageListener listener = reader.getMessageListener(InterfacedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, Object.class);\n        validator.check(listener);\n    }  WIP */\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListener<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListener<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListener<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testAnonymousListener() {\n       SimpleHandler anonymousSimpleHandler = new SimpleHandler() {\n           @Override\n           @Handler\n           public void onMessage(Object msg) {\n               // nop\n           }\n       };\n        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(anonymousSimpleHandler.getClass());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, Object.class);\n        validator.check(listener);\n\n\n    }\n\n\n    // Define and assert expectations on handlers in a listener\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListener listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n    // a simple event listener\n    public class MessageListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class MessageListener2 extends MessageListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class MessageListener3 extends MessageListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = Number.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = Integer.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public static interface ListenerInterface{\n\n        @Handler\n        @Enveloped(messages = Object.class)\n        void handle(MessageEnvelope envelope);\n    }\n\n    public class InterfacedListener implements  ListenerInterface{\n\n        @Override\n        public void handle(MessageEnvelope envelope) {\n            //\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n * @author dorkbox\n *         Date: 22/2/15\n */\npublic abstract class AbstractConcurrentSet<T> implements Set<T> {\n    private static final AtomicLong id = new AtomicLong();\n    private final long ID = id.getAndIncrement();\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public boolean add(T element) {\n        if (element == null) return false;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        boolean changed = insert(element);\n        writeLock.unlock();\n        return changed;\n    }\n\n    @Override\n    public boolean contains(Object element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private boolean insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> elements) {\n        boolean changed = false;\n\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    changed |= insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean remove(Object element) {\n        if (!contains(element)) {\n            // return quickly\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    // if it was second, now it's first\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        return this.entries.entrySet().toArray();\n    }\n\n    @SuppressWarnings(\"hiding\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return this.entries.entrySet().toArray(a);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public void clear() {\n        Lock writeLock = this.lock.writeLock();\n        try {\n            writeLock.lock();\n                head = null;\n                entries.clear();\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"rawtypes\")\n        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n        if (this.ID != other.ID) {\n            return false;\n        }\n        return true;\n    }\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // Not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // Can not nullify references to help GC because running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/IMessageListener.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.messages.IMessage;\n\n/**\n * A collection of different listener flavours meant for convenient reuse in different\n * test scenarios.\n *\n * @author bennidi\n *         Date: 5/24/13\n */\npublic class IMessageListener {\n\n    private static abstract class BaseListener {\n\n        @Handler\n        public void handle(IMessage message){\n            message.handled(this.getClass());\n        }\n\n    }\n\n    public static class DefaultListener extends BaseListener {\n\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n    }\n\n    public static class NoSubtypesListener extends BaseListener {\n\n        @Handler(rejectSubtypes = true)\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n    }\n\n\n    public static class AsyncListener extends BaseListener {\n\n        @Handler(delivery = Invoke.Asynchronously)\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n\n    }\n\n    public static class DisabledListener extends BaseListener {\n\n        @Handler(enabled = false)\n        public void handle(IMessage message){\n            super.handle(message);\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.createAndTrack(\n                        StandardMessage.class,\n                        InstancesPerListener,\n                        Listeners.join(Listeners.asynchronous(),Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(\n                        MultipartMessage.class,\n                        InstancesPerListener,\n                        IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(waitForMessageTimeout);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: Exception counter added via config\n        IBusConfiguration config = SyncAsync(false)\n            .addPublicationErrorHandler(ExceptionCounter);\n\n        final MBassador bus = new MBassador(config);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable asynchronousPublication = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).asynchronously();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/Listeners.java":"package net.engio.mbassy.listeners;\n\nimport java.util.*;\n\n/**\n * Created with IntelliJ IDEA.\n * User: benjamin\n * Date: 6/26/13\n * Time: 11:48 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class Listeners {\n\n    private static final List<Class> Synchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.DefaultListener.class,\n            IMessageListener.DefaultListener.class,\n            StandardMessageListener.DefaultListener.class,\n            MultipartMessageListener.DefaultListener.class,\n            ICountableListener.DefaultListener.class,\n            IMultipartMessageListener.DefaultListener.class}));\n\n    private static final List<Class> Asynchronous = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.AsyncListener.class,\n            IMessageListener.AsyncListener.class,\n            StandardMessageListener.AsyncListener.class,\n            MultipartMessageListener.AsyncListener.class,\n            ICountableListener.AsyncListener.class,\n            IMultipartMessageListener.AsyncListener.class}));\n\n    private static final List<Class> SubtypeRejecting = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.NoSubtypesListener.class,\n            IMessageListener.NoSubtypesListener.class,\n            StandardMessageListener.NoSubtypesListener.class,\n            MultipartMessageListener.NoSubtypesListener.class,\n            ICountableListener.NoSubtypesListener.class,\n            IMultipartMessageListener.NoSubtypesListener.class}));\n\n    private static final List<Class> NoHandlers = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            MessagesListener.DisabledListener.class,\n            IMessageListener.DisabledListener.class,\n            StandardMessageListener.DisabledListener.class,\n            MultipartMessageListener.DisabledListener.class,\n            ICountableListener.DisabledListener.class,\n            IMultipartMessageListener.DisabledListener.class,\n            Object.class,String.class}));\n\n\n    private static final List<Class> HandlesIMessage = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            IMessageListener.DefaultListener.class,\n            IMessageListener.AsyncListener.class,\n            IMessageListener.NoSubtypesListener.class,\n            IMultipartMessageListener.DefaultListener.class,\n            IMultipartMessageListener.AsyncListener.class,\n            IMultipartMessageListener.NoSubtypesListener.class,\n            MessagesListener.DefaultListener.class,\n            MessagesListener.AsyncListener.class,\n            MessagesListener.NoSubtypesListener.class,\n            StandardMessageListener.DefaultListener.class,\n            StandardMessageListener.AsyncListener.class,\n            StandardMessageListener.NoSubtypesListener.class,\n            MultipartMessageListener.DefaultListener.class,\n            MultipartMessageListener.AsyncListener.class,\n            MultipartMessageListener.NoSubtypesListener.class}));\n\n    private static final List<Class> HandlesStandardessage = Collections.unmodifiableList(Arrays.asList(new Class[]{\n            IMessageListener.DefaultListener.class,\n            IMessageListener.AsyncListener.class,\n            ICountableListener.DefaultListener.class,\n            ICountableListener.AsyncListener.class,\n            StandardMessageListener.DefaultListener.class,\n            StandardMessageListener.AsyncListener.class,\n            StandardMessageListener.NoSubtypesListener.class}));\n\n\n    public static Collection<Class> synchronous(){\n        return Synchronous;\n    }\n\n    public static Collection<Class> asynchronous(){\n        return Asynchronous;\n    }\n\n    public static Collection<Class> subtypeRejecting(){\n        return SubtypeRejecting;\n    }\n\n    public static Collection<Class> noHandlers(){\n        return NoHandlers;\n    }\n\n    public static Collection<Class> handlesIMessage(){\n        return HandlesIMessage;\n    }\n\n    public static Collection<Class> handlesStandardMessage(){\n        return HandlesStandardessage;\n    }\n\n\n    public static Collection<Class> join(Collection<Class>...listenerSets){\n        Set<Class> join = new HashSet<Class>();\n        for(Collection<Class> listeners : listenerSets)\n            join.addAll(listeners);\n        for(Collection<Class> listeners : listenerSets)\n            join.retainAll(listeners);\n        return join;\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/common/MessageManager.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.messages.IMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Collection;\n\n/**\n *\n */\npublic class MessageManager {\n\tprivate static final Logger LOG =\n\t\t\tLoggerFactory.getLogger(MessageManager.class);\n\n\n    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();\n\n\n    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> T createAndTrack(Class<T> messageType, int expectedCount, Collection<Class> listeners){\n        T message;\n        try {\n            message = messageType.newInstance();\n            register(message, expectedCount, listeners);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return message;\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){\n        try {\n            messages.add(new MessageContext(expectedCount, message, listeners));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void waitForMessages(int timeoutInMs){\n        long start = System.currentTimeMillis();\n        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){\n            // check each created message once\n            for(MessageContext messageCtx : messages){\n                boolean handledCompletely = true;\n                for(Class listener : messageCtx.getListeners()){\n                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();\n                }\n                // remove the ones that were handled as expected\n                if(handledCompletely){\n                    logSuccess(messageCtx);\n                    messages.remove(messageCtx);\n                }\n\n            }\n            pause(100);\n        }\n        if(messages.size() > 0){\n            logFailingMessages(messages);\n            org.junit.Assert.fail(\"Message were not fully processed in given time\");\n        }\n\n\n    }\n\n    private void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n   private void logSuccess(MessageContext mCtx){\n       LOG.info(mCtx.getMessage().getClass().getSimpleName() + \" successfully handled \" + mCtx.getExpectedCount() + \" times by \" + mCtx.printListeners());\n   }\n\n\n\n    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){\n        StringBuilder errorMessage = new StringBuilder();\n        errorMessage.append(\"Failing messages:\\n\");\n        for(MessageContext failingMessage : failing)\n            errorMessage.append(failingMessage);\n        LOG.info(errorMessage.toString());\n    }\n\n    private class MessageContext{\n\n        private long expectedCount;\n        private IMessage message;\n        private Class[] listeners;\n\n        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners;\n        }\n\n        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {\n            this.expectedCount = expectedCount;\n            this.message = message;\n            this.listeners = listeners.toArray(new Class[]{});\n        }\n\n        private long getExpectedCount() {\n            return expectedCount;\n        }\n\n        private IMessage getMessage() {\n            return message;\n        }\n\n        private Class[] getListeners() {\n            return listeners;\n        }\n\n        private String printListeners(){\n            StringBuilder listenersAsString = new StringBuilder();\n            for(Class listener : listeners){\n                listenersAsString.append(listener.getName());\n                listenersAsString.append(\",\");\n            }\n            return listenersAsString.toString();\n        }\n\n        @Override\n        public String toString() {\n            // TODO: actual count of listeners\n            return message.getClass().getSimpleName() + \"{\" +\n                    \"expectedCount=\" + expectedCount +\n                    \", listeners=\" + printListeners() +\n                    '}';\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n\n\n    public WeakConcurrentSet() {\n        super(new WeakHashMap<T, ISetEntry<T>>());\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            // the current listelement of this iterator\n            // used to keep track of the iteration process\n            private ISetEntry<T> current = head;\n\n            // this method will remove all orphaned entries\n            // until it finds the first entry whose value has not yet been garbage collected\n            // the method assumes that the current element is already orphaned and will remove it\n            private void removeOrphans(){\n                Lock writelock = lock.writeLock();\n                try{\n                    writelock.lock();\n                    do {\n                        ISetEntry orphaned = current;\n                        current = current.next();\n                        if (orphaned  == head) {\n                            head = head.next();\n                        }\n                        orphaned.remove();\n                    } while(current != null && current.getValue() == null);\n                }\n                finally {\n                    writelock.unlock();\n                }\n            }\n\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                if (current.getValue() == null) {\n                // trigger removal of orphan references\n                // because a null value indicates that the value has been garbage collected\n                    removeOrphans();\n                    return current != null; // if any entry is left then it will have a value\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    removeOrphans();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                //throw new UnsupportedOperationException(\"Explicit removal of set elements is only allowed via the controlling set. Sorry!\");\n                if (current == null) {\n                    return;\n                }\n                ISetEntry<T> newCurrent = current.next();\n                WeakConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n    @Override\n    protected Entry<T> createEntry(T value, Entry<T> next) {\n        return next != null ? new WeakEntry<T>(value, next) : new WeakEntry<T>(value);\n    }\n\n\n    public static class WeakEntry<T> extends Entry<T> {\n\n        private WeakReference<T> value;\n\n        private WeakEntry(T value, Entry<T> next) {\n            super(next);\n            this.value = new WeakReference<T>(value);\n        }\n\n        private WeakEntry(T value) {\n            super();\n            this.value = new WeakReference<T>(value);\n        }\n\n        @Override\n        public T getValue() {\n            return value.get();\n        }\n\n\n\n\n    }\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/SyncAsyncTest.java":[[116,116],[120,120],[72,72],[83,83],[88,88]],"src/test/java/net/engio/mbassy/common/MessageManager.java":[[82,82]]},"postChangeRange":{"src/test/java/net/engio/mbassy/SyncAsyncTest.java":[[122,122],[126,126],[72,72],[89,89],[94,94]],"src/test/java/net/engio/mbassy/common/MessageManager.java":[[78,78]],"src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java":[[43,45]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java","startLine":43,"endLine":43}]}],"refactorings":[]},{"repository":"mbassador","sha1":"89f44544bd9d68c94c5fc84dcef167cb33b25df5","url":"https://github.com/bennidi/mbassador/commit/89f44544bd9d68c94c5fc84dcef167cb33b25df5","preChangeSourceCode":{"src/test/java/org/mbassy/listeners/EventingTestBean.java":"package org.mbassy.listeners;\n\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Filter;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.MessageFilter;\nimport org.mbassy.listener.Mode;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Listener\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, dispatch = Mode.Asynchronous)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Listener(\n            priority = 10,\n            dispatch = Mode.Synchronous,\n            filters = {@Filter(MessageFilter.None.class), @Filter(MessageFilter.All.class)})\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n\n}\n","src/test/java/org/mbassy/ConcurrentSetTest.java":"package org.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Test;\nimport org.mbassy.common.ConcurrentSet;\n\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/12/12\n * Time: 3:02 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class ConcurrentSetTest extends  UnitTest{\n\n    private int numberOfElements = 100000;\n\n    private int numberOfThreads = 50;\n\n\n    @Test\n    public void testIterator(){\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        for(int i=0;i < numberOfElements ; i++){\n            Object candidate = new Object();\n\n            if(rand.nextInt() % 3 == 0){\n                distinct.add(candidate);\n            }\n            target.add(candidate);\n        }\n\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(Object src : target){\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n\n\n\n        for(Object tar : target){\n            Assert.assertTrue(distinct.contains(tar));\n        }\n\n\n\n    }\n\n\n        @Test\n    public void testInsert(){\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        Object candidate = new Object();\n        for(int i=0;i < numberOfElements ; i++){\n            if(rand.nextInt() % 3 == 0){\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(Object src : duplicates){\n                    target.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        pause(3000);\n\n\n        for(Object tar : target){\n            Assert.assertTrue(distinct.contains(tar));\n        }\n\n        for(Object src : distinct){\n            Assert.assertTrue(target.contains(src));\n        }\n\n        Assert.assertEquals(distinct.size(), target.size());\n    }\n\n\n\n    @Test\n    public void testRemove1(){\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n        for(int i=0;i < numberOfElements ; i++){\n            Object candidate = new Object();\n            source.add(candidate);\n            if(i % 3 == 0){\n                toRemove.add(candidate);\n            }\n        }\n\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(Object src : source){\n                    target.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(Object src : toRemove){\n                    target.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        pause(3000);\n\n        for(Object tar : target){\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n\n        for(Object src : source){\n            if(!toRemove.contains(src))Assert.assertTrue(target.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemove2(){\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> target = new ConcurrentSet<Object>();\n        for(int i=0;i < numberOfElements ; i++){\n            Object candidate = new Object();\n            source.add(candidate);\n            if(i % 3 == 0){\n                toRemove.add(candidate);\n            }\n        }\n\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(Object src : source){\n                    target.add(src);\n                    if(toRemove.contains(src))\n                        target.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        pause(3000);\n\n        for(Object tar : target){\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n\n        for(Object src : source){\n            if(!toRemove.contains(src))Assert.assertTrue(target.contains(src));\n        }\n    }\n\n}\n","src/test/java/org/mbassy/listeners/NonListeningBean.java":"package org.mbassy.listeners;\n\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.Mode;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should be considered a message lister\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport org.mbassy.subscription.*;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SimplePostCommand<T>>{\n\n    public MBassador(){\n        this(2);\n    }\n\n    public MBassador(int dispatcherThreadCount){\n        super(dispatcherThreadCount);\n    }\n\n    public MBassador(int dispatcherThreadCount, ExecutorService executor){\n        super(dispatcherThreadCount,executor);\n    }\n\n    @Override\n    protected SubscriptionFactory getSubscriptionFactory() {\n        return new SubscriptionFactory(this);\n    }\n\n    public void publishAsync(T message){\n        addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n\tpublic void publish(T message){\n\t\ttry {\n\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n\t\t\tif(subscriptions == null){\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions){\n                subscription.publish(message);\n            }\n\t\t} catch (Throwable e) {\n\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t.setMessage(\"Error during publication of message\")\n\t\t\t\t\t.setCause(e)\n\t\t\t\t\t.setPublishedObject(message));\n\t\t}\n\n\t}\n\n\n    @Override\n    public SimplePostCommand post(T message) {\n        return new SimplePostCommand(this, message);\n    }\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionFactory.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    private IMessageBus owner;\n\n\n    public SubscriptionFactory(IMessageBus owner) {\n        this.owner = owner;\n    }\n\n    public Subscription createSubscription(MessageHandlerMetadata messageHandlerMetadata){\n        if(messageHandlerMetadata.isFiltered()){\n            if(messageHandlerMetadata.isAsynchronous()){\n                return new UnfilteredAsynchronousSubscription(owner, messageHandlerMetadata);\n            }\n            else{\n                return new UnfilteredSynchronousSubscription(owner, messageHandlerMetadata);\n            }\n        }\n        else{\n            if(messageHandlerMetadata.isAsynchronous()){\n                return new FilteredAsynchronousSubscription(owner, messageHandlerMetadata);\n            }\n            else{\n                return new FilteredSynchronousSubscription(owner, messageHandlerMetadata);\n            }\n        }\n    }\n}\n","src/main/java/org/mbassy/IMessageBus.java":"package org.mbassy;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for each concrete message publication.\n * A message publication is the publication of any message using one of the bus' publish(..) methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Listener annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of insertion (subscription) but any\n * class using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any messageHandler may only be subscribed once (subsequent subscriptions of an already subscribed messageHandler will be silently ignored)\n * <p/>\n * Removing a listener means removing all subscribed message handlers of that object. This remove operation\n * immediately takes effect and on all running dispatch processes. A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    public void subscribe(Object listener);\n\n\n    /**\n     * Immediately unsubscribe all registered message handlers (if any) of the given listener. When this call returns\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the messageHandler was still subscribed).\n     * A call to this method passing null, an already subscribed message or any message that does not define any listeners\n     * will not have any effect.\n     *\n     * @param listener\n     * @return  true, if the listener was found and successfully removed\n     *          false otherwise\n     */\n    public boolean unsubscribe(Object listener);\n\n    /**\n     *\n     * @param message\n     * @return\n     */\n    public P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n    public Executor getExecutor();\n\n\n\n    public static interface IPostCommand{\n\n        public void now();\n\n        public void asynchronously();\n\n    }\n\n}\n","src/main/java/org/mbassy/listener/MetadataReader.java":"package org.mbassy.listener;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:22 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private MessageFilter[] getFilter(Listener subscription) throws Exception{\n        if (subscription.filters().length == 0) return null;\n        MessageFilter[] filters = new MessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            MessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) throws Exception{\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        MessageFilter[] filter = getFilter(config);\n        return new MessageHandlerMetadata(messageHandler, filter, config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<Method> getListeners(Class<?> target) {\n        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        List<Method>  handlers = new LinkedList<Method>();\n        for(Method listener : allMethods){\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(listener, target);\n\n            if(overriddenHandler != null && isHandler(overriddenHandler)){\n                handlers.add(overriddenHandler);\n            }\n            if(overriddenHandler == null){\n                handlers.add(listener);\n            }\n        }\n        return ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n    }\n\n    private static boolean isHandler(Method m){\n        Annotation[] annotations  = m.getDeclaredAnnotations();\n        for(Annotation annotation : annotations){\n            if(annotation.equals(Listener.class))return true;\n        }\n        return false;\n\n    }\n\n}\n","src/main/java/org/mbassy/listener/Listener.java":"package org.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * TODO. Insert class description here\n * <p/>\n * @author bennidi\n * Date: 2/8/12\n * Time: 3:35 PM\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Listener {\n\n\tFilter[] filters() default {}; // no filters by default\n\n    Mode dispatch() default Mode.Synchronous;\n\n    int priority() default 0;\n\n}\n","src/main/java/org/mbassy/IPublicationErrorHandler.java":"package org.mbassy;\n\n/**\n * TODO. Insert class description here\n * <p/>\n * @author bennidi\n * Date: 2/22/12\n */\npublic interface IPublicationErrorHandler {\n\n\tpublic void handleError(PublicationError error);\n\n    // This is the default error handler it will simply log to standard out and\n    // print stack trace if available\n    static final class ConsoleLogger implements IPublicationErrorHandler {\n        @Override\n        public void handleError(PublicationError error) {\n            System.out.println(error);\n            if (error.getCause() != null) error.getCause().printStackTrace();\n        }\n    }\n\n    ;\n}\n","src/main/java/org/mbassy/common/ReflectionUtils.java":"package org.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n        Class current = subclass;\n        while(!current.equals(overridingMethod.getDeclaringClass())){\n            try {\n                Method overridden = current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n                return overridden;\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) filtered.add(method);\n        }\n        return filtered;\n    }\n\n    public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) return true;\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subbclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        if(subClassMethodParameters.length != subClassMethodParameters.length){\n            return false;\n        }\n        //the parameters must occur in the exact same order\n        for(int i = 0 ; i< subClassMethodParameters.length; i++){\n           if(!superClassMethodParameters[i].equals(subClassMethodParameters[i])){\n               return false;\n           }\n        }\n        return true;\n    }\n\n}\n","src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":"package org.mbassy.listener;\n\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.Mode;\nimport org.mbassy.listener.MessageFilter;\n\nimport java.lang.reflect.Method;\n\n/**\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private MessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n\n    public MessageHandlerMetadata(Method handler, MessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter == null || filter.length == 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public MessageFilter[] getFilter() {\n        return filter;\n    }\n}\n","src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listeners.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends UnitTest {\n\n\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n\n        MBassador bus = new MBassador();\n        int listenerCount = 1000;\n\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n            assertTrue(bus.unsubscribe(listener));\n            assertFalse(bus.unsubscribe(nonListener));\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n    }\n\n    @Test\n    public void testSubscribeConcurrent() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        SubTestEvent subEvent = new SubTestEvent();\n\n        bus.publish(event);\n        bus.publish(subEvent);\n\n        pause(4000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n\n    @Test\n    public void testAsynchronous() throws InterruptedException {\n\n        MBassador bus = new MBassador();\n        int listenerCount = 1000;\n        List<EventingTestBean> persistentReferences = new ArrayList();\n\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean bean = new EventingTestBean();\n            persistentReferences.add(bean);\n            bus.subscribe(bean);\n        }\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publishAsync(event);\n        bus.publishAsync(subEvent);\n\n        pause(2000);\n\n        assertTrue(event.counter.get() == 1000);\n        assertTrue(subEvent.counter.get() == 1000 * 2);\n\n    }\n\n    @Test\n    public void testSynchronous() throws InterruptedException {\n\n        MBassador bus = new MBassador();\n        int listenerCount = 10;\n        List<EventingTestBean> persistentReferences = new ArrayList();\n        for (int i = 1; i <= listenerCount; i++) {\n\n\n            EventingTestBean bean = new EventingTestBean();\n            persistentReferences.add(bean);\n            bus.subscribe(bean);\n\n            TestEvent event = new TestEvent();\n            TestEvent subEvent = new SubTestEvent();\n\n            bus.publish(event);\n            bus.publish(subEvent);\n\n            assertEquals(i, event.counter.get());\n\n            pause(50);\n\n            assertEquals(i * 2, subEvent.counter.get());\n\n        }\n\n    }\n\n    @Test\n    public void testConcurrentPublication() {\n        final MBassador bus = new MBassador();\n        final int listenerCount = 100;\n        final int concurrency = 20;\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final CopyOnWriteArrayList<EventingTestBean> persistentReferences = new CopyOnWriteArrayList<EventingTestBean>();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < listenerCount; i++) {\n                    EventingTestBean bean = new EventingTestBean();\n                    persistentReferences.add(bean);\n                    bus.subscribe(bean);\n                }\n            }\n        }, concurrency);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < listenerCount; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n            }\n        }, concurrency);\n\n        pause(3000);\n\n        for (TestEvent event : testEvents) {\n            assertEquals(listenerCount * concurrency, event.counter.get());\n        }\n\n        for (SubTestEvent event : subtestEvents) {\n            assertEquals(listenerCount * concurrency * 2, event.counter.get());\n        }\n\n    }\n\n\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private MetadataReader metadataReader = new MetadataReader();\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private CopyOnWriteArrayList<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>();\n\n    private final SubscriptionFactory subscriptionFactory;\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            handlePublicationError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    public AbstractMessageBus() {\n        this(2);\n    }\n\n    public AbstractMessageBus(int dispatcherThreadCount) {\n        this(2, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n    }\n\n    public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n        this.executor = executor;\n        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n        subscriptionFactory = getSubscriptionFactory();\n        initialize();\n    }\n\n    protected abstract SubscriptionFactory getSubscriptionFactory();\n\n    protected void initialize() {\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = false;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved || subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially for each class\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<Method> messageHandlers = metadataReader.getListeners(listeningClass);  // get all methods with subscriptions\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        // create subscriptions for all detected listeners\n                        for (Method messageHandler : messageHandlers) {\n                            if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n                            Class eventType = getMessageType(messageHandler);\n                            Subscription subscription = subscriptionFactory.createSubscription(metadataReader.getHandlerMetadata(messageHandler));\n                            subscription.subscribe(listener);\n                            addMessageTypeSubscription(eventType, subscription);\n                            subscriptionsByListener.add(subscription);\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n        pendingMessages.offer(request);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : getSuperclasses(messageType)) {\n            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n        }\n        // IMPROVEMENT: use tree list that sorts during insertion\n        //Collections.sort(subscriptions, new SubscriptionByPriorityDesc());\n        return subscriptions;\n    }\n\n    private Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    // associate a suscription with a message type\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new CopyOnWriteArraySet<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        return true;\n    }\n\n    private static Class getMessageType(Method listener) {\n        return listener.getParameterTypes()[0];\n    }\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/org/mbassy/subscription/Subscription.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.common.ConcurrentSet;\nimport org.mbassy.PublicationError;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * Subscription is a thread safe container for objects that contain message handlers\n */\npublic abstract class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    private final Method handler;\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private int priority = 0;\n\n    private IMessageBus owningBus ;\n\n    public Subscription(IMessageBus owningBus, MessageHandlerMetadata messageHandler) {\n        this.owningBus = owningBus;\n        this.priority = messageHandler.getPriority();\n        this.handler = messageHandler.getHandler();\n        this.handler.setAccessible(true);\n    }\n\n    public abstract void publish(Object message);\n\n    protected abstract void dispatch(final Object message, final Object listener);\n\n\n    protected IMessageBus getMessageBus(){\n        return owningBus;\n    }\n\n    public int getPriority(){\n        return priority;\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n\n    }\n\n    protected void handlePublicationError(PublicationError error){\n        Collection<IPublicationErrorHandler> handlers = owningBus.getRegisteredErrorHandlers();\n        for(IPublicationErrorHandler handler : handlers){\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener){\n        try {\n            handler.invoke(listener, message);\n        }catch(IllegalAccessException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        }\n        catch(IllegalArgumentException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        }\n        catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        }\n        catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n","src/main/java/org/mbassy/listener/Filter.java":"package org.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * THe filter annotation is used to add filters to message listeners.\n * It references a class that implements the MessageFilter interface.\n * The object filter will be used to check whether a message should be delivered\n * to the message listener or not.\n *\n * <p/>\n * @author  benni\n * Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n\tClass<? extends MessageFilter> value();\n}\n"},"postChangeSourceCode":{"src/test/java/org/mbassy/listeners/EventingTestBean.java":"package org.mbassy.listeners;\n\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Filter;\nimport org.mbassy.listener.IMessageFilter;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.Mode;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Listener\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, dispatch = Mode.Asynchronous)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Listener(\n            priority = 10,\n            dispatch = Mode.Synchronous,\n            filters = {@Filter(IMessageFilter.None.class), @Filter(IMessageFilter.All.class)})\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n\n}\n","src/test/java/org/mbassy/ConcurrentSetTest.java":"package org.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Test;\nimport org.mbassy.common.ConcurrentSet;\n\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n *\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    private int numberOfElements = 100000;\n\n    private int numberOfThreads = 50;\n\n\n    @Test\n    public void testIteratorCleanup() {\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // this will remove all objects that have not been inserted into the set of persisting candidates\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n\n\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n\n\n    }\n\n    @Test\n    public void testPerformance(){\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for(Object o: source){\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for(Object o: source){\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n}\n","src/test/java/org/mbassy/listeners/NonListeningBean.java":"package org.mbassy.listeners;\n\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.Mode;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should not be considered a message listener\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport org.mbassy.subscription.*;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n\n    public MBassador(){\n        this(2);\n    }\n\n    public MBassador(int dispatcherThreadCount){\n        super(dispatcherThreadCount);\n    }\n\n    public MBassador(int dispatcherThreadCount, ExecutorService executor){\n        super(dispatcherThreadCount,executor);\n    }\n\n    @Override\n    protected SubscriptionFactory getSubscriptionFactory() {\n        return new SubscriptionFactory(this);\n    }\n\n    public void publishAsync(T message){\n        addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n\tpublic void publish(T message){\n\t\ttry {\n\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n\t\t\tif(subscriptions == null){\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions){\n                subscription.publish(message);\n            }\n\t\t} catch (Throwable e) {\n\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t.setMessage(\"Error during publication of message\")\n\t\t\t\t\t.setCause(e)\n\t\t\t\t\t.setPublishedObject(message));\n\t\t}\n\n\t}\n\n\n    @Override\n    public SyncAsyncPostCommand post(T message) {\n        return new SyncAsyncPostCommand(this, message);\n    }\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionFactory.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.dispatch.*;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    private IMessageBus owner;\n\n    public SubscriptionFactory(IMessageBus owner) {\n        this.owner = owner;\n    }\n\n    public Subscription createSubscription(MessageHandlerMetadata messageHandlerMetadata){\n        MessagingContext context = new MessagingContext(owner, messageHandlerMetadata);\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/org/mbassy/IMessageBus.java":"package org.mbassy;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Listener annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    public void subscribe(Object listener);\n\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     *\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return  true, if the listener was found and successfully removed\n     *          false otherwise\n     */\n    public boolean unsubscribe(Object listener);\n\n    /**\n     *\n     * @param message\n     * @return\n     */\n    public P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    public Executor getExecutor();\n\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     *\n     */\n    public static interface IPostCommand{\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        public void now();\n\n        /**\n         * Execute the message publication asynchronously. This call return immediately and all matching message handlers\n         * will be invoked in another thread.\n         */\n        public void asynchronously();\n\n    }\n\n}\n","src/main/java/org/mbassy/listener/MetadataReader.java":"package org.mbassy.listener;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:22 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription) throws Exception{\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) throws Exception{\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        IMessageFilter[] filter = getFilter(config);\n        return new MessageHandlerMetadata(messageHandler, filter, config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<Method> getListeners(Class<?> target) {\n        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        List<Method>  handlers = new LinkedList<Method>();\n        for(Method listener : allMethods){\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(listener, target);\n\n            if(overriddenHandler != null && isHandler(overriddenHandler)){\n                handlers.add(overriddenHandler);\n            }\n            if(overriddenHandler == null){\n                handlers.add(listener);\n            }\n        }\n        return ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n    }\n\n    private static boolean isHandler(Method m){\n        Annotation[] annotations  = m.getDeclaredAnnotations();\n        for(Annotation annotation : annotations){\n            if(annotation.equals(Listener.class))return true;\n        }\n        return false;\n\n    }\n\n}\n","src/main/java/org/mbassy/listener/Listener.java":"package org.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any object as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Listener {\n\n\n\tFilter[] filters() default {}; // no filters by default\n\n    Mode dispatch() default Mode.Synchronous;\n\n    int priority() default 0;\n\n}\n","src/main/java/org/mbassy/IPublicationErrorHandler.java":"package org.mbassy;\n\n/**\n * Publication error handlers are provided with a publication error every time an error occurs during message publication.\n * A handler might fail with an exception, not be accessible because of the presence of a security manager\n * or other reasons might lead to failures during the message publication process.\n *\n * <p/>\n * @author bennidi\n * Date: 2/22/12\n */\npublic interface IPublicationErrorHandler {\n\n    /**\n     * Handle the given publication error.\n     *\n     * @param error\n     */\n\tpublic void handleError(PublicationError error);\n\n    // This is the default error handler it will simply log to standard out and\n    // print stack trace if available\n    static final class ConsoleLogger implements IPublicationErrorHandler {\n        @Override\n        public void handleError(PublicationError error) {\n            System.out.println(error);\n            if (error.getCause() != null) error.getCause().printStackTrace();\n        }\n    }\n\n    ;\n}\n","src/main/java/org/mbassy/common/ReflectionUtils.java":"package org.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n        Class current = subclass;\n        while(!current.equals(overridingMethod.getDeclaringClass())){\n            try {\n                Method overridden = current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n                return overridden;\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) filtered.add(method);\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) return true;\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subbclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        if(subClassMethodParameters.length != subClassMethodParameters.length){\n            return false;\n        }\n        //the parameters must occur in the exact same order\n        for(int i = 0 ; i< subClassMethodParameters.length; i++){\n           if(!superClassMethodParameters[i].equals(subClassMethodParameters[i])){\n               return false;\n           }\n        }\n        return true;\n    }\n\n}\n","src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":"package org.mbassy.listener;\n\nimport java.lang.reflect.Method;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public Class getDeclaredMessageType(){\n        return handler.getParameterTypes()[0];\n    }\n}\n","src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listeners.*;\nimport org.mbassy.subscription.Subscription;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends UnitTest {\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = new MBassador();\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 1000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(300, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(1000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publishAsync(event);\n        bus.publishAsync(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publish(event);\n        bus.publish(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n            }\n        }, 10);\n\n        pause(3000);\n\n        for (TestEvent event : testEvents) {\n            assertEquals(300, event.counter.get());\n        }\n\n        for (SubTestEvent event : subtestEvents) {\n            assertEquals(700, event.counter.get());\n        }\n\n    }\n\n\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private MetadataReader metadataReader = new MetadataReader();\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private CopyOnWriteArrayList<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            handlePublicationError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    public AbstractMessageBus() {\n        this(2);\n    }\n\n    public AbstractMessageBus(int dispatcherThreadCount) {\n        this(2, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n    }\n\n    public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n        this.executor = executor;\n        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n        subscriptionFactory = getSubscriptionFactory();\n        initialize();\n    }\n\n    protected abstract SubscriptionFactory getSubscriptionFactory();\n\n    protected void initialize() {\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially for each class\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<Method> messageHandlers = metadataReader.getListeners(listeningClass);  // get all methods with subscriptions\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        // create subscriptions for all detected listeners\n                        for (Method messageHandler : messageHandlers) {\n                            if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n                            Class eventType = getMessageType(messageHandler);\n                            Subscription subscription = subscriptionFactory.createSubscription(metadataReader.getHandlerMetadata(messageHandler));\n                            subscription.subscribe(listener);\n                            addMessageTypeSubscription(eventType, subscription);\n                            subscriptionsByListener.add(subscription);\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n        pendingMessages.offer(request);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new CopyOnWriteArraySet<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        return true;\n    }\n\n    private static Class getMessageType(Method listener) {\n        return listener.getParameterTypes()[0];\n    }\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/org/mbassy/subscription/Subscription.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.common.ConcurrentSet;\nimport org.mbassy.PublicationError;\nimport org.mbassy.dispatch.IMessageDispatcher;\nimport org.mbassy.dispatch.MessagingContext;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport javax.xml.ws.handler.MessageContext;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private MessagingContext context;\n\n    public Subscription(MessagingContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public void publish(Object message){\n          dispatcher.dispatch(message, listeners);\n    }\n\n    public MessagingContext getContext(){\n        return context;\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n","src/main/java/org/mbassy/listener/Filter.java":"package org.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * THe filter annotation is used to add filters to message listeners.\n * It references a class that implements the MessageFilter interface.\n * The object filter will be used to check whether a message should be delivered\n * to the message listener or not.\n *\n * <p/>\n * @author  bennidi\n * Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n\tClass<? extends IMessageFilter> value();\n}\n"},"preChangeRange":{"src/test/java/org/mbassy/listeners/EventingTestBean.java":[[36,36]],"src/test/java/org/mbassy/MBassadorTest.java":[[32,32]],"src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":[[48,48],[37,37]],"src/test/java/org/mbassy/ConcurrentSetTest.java":[[158,158],[168,168],[171,175],[179,179],[181,181],[186,186]],"src/main/java/org/mbassy/AbstractMessageBus.java":[[105,105],[107,107]],"src/main/java/org/mbassy/subscription/Subscription.java":[[37,37],[47,47]],"src/main/java/org/mbassy/MBassador.java":[[59,59],[60,60]],"src/main/java/org/mbassy/subscription/SubscriptionFactory.java":[[26,41]],"src/main/java/org/mbassy/IMessageBus.java":[[58,58],[60,60],[61,61],[62,62]],"src/main/java/org/mbassy/listener/MetadataReader.java":[[34,34],[36,36],[39,39],[54,54]]},"postChangeRange":{"src/main/java/org/mbassy/IPublicationErrorHandler.java":[[14,18]],"src/test/java/org/mbassy/listeners/EventingTestBean.java":[[36,36]],"src/test/java/org/mbassy/MBassadorTest.java":[[27,27],[34,34],[45,45],[46,46],[47,47],[49,49],[50,50],[51,51],[54,56],[59,59],[60,60],[61,61],[63,63],[64,64],[65,65]],"src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":[[47,47],[36,36]],"src/main/java/org/mbassy/AbstractMessageBus.java":[[171,171],[108,108],[110,110]],"src/test/java/org/mbassy/ConcurrentSetTest.java":[[138,138],[149,149],[152,154],[159,166],[169,169],[174,174],[176,176]],"src/main/java/org/mbassy/subscription/Subscription.java":[[37,39],[46,46]],"src/main/java/org/mbassy/MBassador.java":[[59,59],[60,60]],"src/main/java/org/mbassy/subscription/SubscriptionFactory.java":[[26,26],[27,27],[28,28],[29,29]],"src/main/java/org/mbassy/IMessageBus.java":[[99,104],[61,61],[63,63],[65,65],[66,66],[122,125],[116,119]],"src/main/java/org/mbassy/listener/MetadataReader.java":[[34,34],[36,36],[39,39],[54,54]]},"microChanges":[],"refactorings":[{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/test/java/org/mbassy/ConcurrentSetTest.java","startLine":186,"endLine":186}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"8349aef7c8cd33f944c87c2bde961ea7663b0f10","url":"https://github.com/bennidi/mbassador/commit/8349aef7c8cd33f944c87c2bde961ea7663b0f10","preChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    private int numberOfElements = 100000;\n    private int numberOfThreads = 50;\n\n    @Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n    @Test\n    public void testIteratorCleanup() {\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of persisting candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n\n\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSet.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (int i = 0; i < filter.length; i++) {\n                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Handler handlerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        if (this.envelope != null) {\n            for (Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        } else {\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous() {\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered() {\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority() {\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.events.SubTestMessage;\nimport org.junit.Test;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Testing different scenarios of subscribing objects (listeners and non-listeners) to the message bus.\n *\n * @author bennidi\n *         Date: 1/9/13\n */\npublic class ListenerSubscriptionTest extends MessageBusTest{\n\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = getBus(new BusConfiguration());\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 200000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(30000, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(100000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n}\n","src/main/java/net/engio/mbassy/common/ConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T> {\n\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) {\n            return this;\n        }\n        synchronized (this) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element) {\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) {\n            return;\n        }\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size() {\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (this) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) {\n                    return this;\n                }\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) {\n            return false;\n        }\n        synchronized (this) {\n            Entry<T> listelement = entries.get(element);\n            if (listelement == null) {\n                return false; //removed by other thread\n            }\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                Entry<T> oldHead = head;\n                head = head.next();\n                oldHead.next = null; // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) {\n                    return false;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) {\n                    return;\n                }\n                Entry<T> newCurrent = current.next();\n                ConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n        Class current = subclass;\n        while (!current.equals(overridingMethod.getDeclaringClass())) {\n            try {\n                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) {\n                filtered.add(method);\n            }\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        if (subClassMethodParameters.length != subClassMethodParameters.length) {\n            return false;\n        }\n        //the parameters must occur in the exact same order\n        for (int i = 0; i < subClassMethodParameters.length; i++) {\n            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static final IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers;\n\n    private Class<T> listenerDefinition;\n\n    public MessageListenerMetadata(List<MessageHandlerMetadata> handlers, Class<T> listenerDefinition) {\n        this.handlers = handlers;\n        this.listenerDefinition = listenerDefinition;\n    }\n\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for (MessageHandlerMetadata handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/MessageEnvelope.java":"package net.engio.mbassy.subscription;\n\nimport java.sql.Timestamp;\n\n/**\n * A message envelope is used to wrap messages of arbitrary type such that a handler\n * my receive messages of different types.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MessageEnvelope {\n\n    // Internal state\n    private Object message;\n\n    public MessageEnvelope(Object message) {\n        this.message = message;\n    }\n\n    public <T> T getMessage() {\n        return (T) message;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static class Factory {\n\n        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n        }\n\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private boolean delivered = false;\n\n    private IMessageBus bus;\n\n    public MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                bus.post(new FilteredMessage(message)).now();\n            } else if (!isDeadEvent()) {\n                bus.post(new DeadMessage(message)).now();\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (!state.equals(State.Initial)) {\n            return this;\n        }\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError() {\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error;\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final MessagePublication.Factory publicationFactory;\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass)) {\n                return; // early reject of known classes that do not participate in eventing\n            }\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for (Class<?> messageType : messageTypes) {\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener) {\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    private int numberOfElements = 100000;\n    private int numberOfThreads = 50;\n\n    @Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n    @Test\n    public void testIteratorCleanup() {\n\n        // Assemble\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of persisting candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSet.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (IMessageFilter aFilter : filter) {\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Handler handlerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        if (this.envelope != null) {\n            Collections.addAll(handledMessages, envelope.messages());\n        } else {\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous() {\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered() {\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority() {\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/test/java/net/engio/mbassy/bus/ListenerSubscriptionTest.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listeners.EventingTestBean;\nimport net.engio.mbassy.listeners.EventingTestBean2;\nimport net.engio.mbassy.listeners.EventingTestBean3;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport net.engio.mbassy.listeners.NonListeningBean;\nimport net.engio.mbassy.subscription.Subscription;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Testing different scenarios of subscribing objects (listeners and non-listeners) to the message bus.\n *\n * @author bennidi\n *         Date: 1/9/13\n */\npublic class ListenerSubscriptionTest extends MessageBusTest{\n\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = getBus(new BusConfiguration());\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 200000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(30000, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestMessage.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(100000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n}\n","src/main/java/net/engio/mbassy/common/ConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T> {\n\n    // Internal state\n    private final Object lock = new Object();\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) {\n            return this;\n        }\n        synchronized (lock) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element) {\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) {\n            return;\n        }\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size() {\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (lock) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) {\n                    return this;\n                }\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) {\n            return false;\n        }\n        synchronized (lock) {\n            Entry<T> listelement = entries.get(element);\n            if (listelement == null) {\n                return false; //removed by other thread\n            }\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                Entry<T> oldHead = head;\n                head = head.next();\n                oldHead.next = null; // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) {\n                    return false;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) {\n                    return;\n                }\n                Entry<T> newCurrent = current.next();\n                ConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n        Class current = subclass;\n        while (!current.equals(overridingMethod.getDeclaringClass())) {\n            try {\n                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) {\n                filtered.add(method);\n            }\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for (int i = 0; i < subClassMethodParameters.length; i++) {\n            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers;\n\n    private Class<T> listenerDefinition;\n\n    public MessageListenerMetadata(List<MessageHandlerMetadata> handlers, Class<T> listenerDefinition) {\n        this.handlers = handlers;\n        this.listenerDefinition = listenerDefinition;\n    }\n\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for (MessageHandlerMetadata handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/MessageEnvelope.java":"package net.engio.mbassy.subscription;\n\n/**\n * A message envelope is used to wrap messages of arbitrary type such that a handler\n * my receive messages of different types.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MessageEnvelope {\n\n    // Internal state\n    private Object message;\n\n    public MessageEnvelope(Object message) {\n        this.message = message;\n    }\n\n    public <T> T getMessage() {\n        return (T) message;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static class Factory {\n\n        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n        }\n\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private boolean delivered = false;\n\n    private IMessageBus bus;\n\n    public MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                bus.post(new FilteredMessage(message)).now();\n            } else if (!isDeadEvent()) {\n                bus.post(new DeadMessage(message)).now();\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (!state.equals(State.Initial)) {\n            return this;\n        }\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError() {\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet<Class>();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final MessagePublication.Factory publicationFactory;\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass)) {\n                return; // early reject of known classes that do not participate in eventing\n            }\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for (Class<?> messageType : messageTypes) {\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener) {\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[29,31]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[36,37]],"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":[[33,33],[77,77],[61,61]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[94,96]],"src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":[[18,18]]},"postChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[39,39]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[29,31]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[37,37]],"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":[[34,34],[78,78],[62,62]]},"microChanges":[{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":94,"endLine":94}],"rightSideLocations":[]}],"refactorings":[]},{"repository":"mbassador","sha1":"4fce93874619bd364c46186e4e335773f752c60a","url":"https://github.com/bennidi/mbassador/commit/4fce93874619bd364c46186e4e335773f752c60a","preChangeSourceCode":{"src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.StrongConcurrentSet;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class StrongConcurrentSetTest extends ConcurrentSetTest{\n\n    @Override\n    protected IConcurrentSet createSet() {\n        return new StrongConcurrentSet();\n    }\n}\n","src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends AssertSupport {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n\n    protected Set gcProtector = new HashSet();\n\n    @Before\n    public void beforeTest(){\n        super.beforeTest();\n        gcProtector = new HashSet();\n    }\n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSet = createSet();\n        Random rand = new Random();\n\n        // getAll set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n    }\n\n    @Test()\n    public void testIterationWithConcurrentRemoval() {\n        final IConcurrentSet<AtomicInteger> testSet = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            AtomicInteger element = new AtomicInteger();\n            testSet.add(element);\n            gcProtector.add(element);\n        }\n\n        Runnable incrementer = new Runnable() {\n            @Override\n            public void run() {\n                while(testSet.size() > 100){\n                    for(AtomicInteger element : testSet)\n                        element.incrementAndGet();\n                }\n\n            }\n        };\n\n        Runnable remover = new Runnable() {\n            @Override\n            public void run() {\n                while(testSet.size() > 100){\n                    for(AtomicInteger element : testSet)\n                        if(rand.nextInt() % 3 == 0 && testSet.size() > 100)\n                            testSet.remove(element);\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(20, incrementer, incrementer, remover);\n\n        Set<Integer> counts = new HashSet<Integer>();\n        for (AtomicInteger count : testSet) {\n            counts.add(count.get());\n        }\n        // all atomic integers should have been visited by the the incrementer\n        // the same number of times\n        // in other words: they have either been removed at some point or incremented in each\n        // iteration such that all remaining atomic integers must share the same value\n        assertEquals(1, counts.size());\n    }\n\n\n\n    @Test\n    public void testRandomRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSet = createSet();\n        // getAll set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalOfHead() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSet = createSet();\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSet = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet setUnderTest = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            setUnderTest.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = setUnderTest.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, setUnderTest.size());\n        for(Object src : source){\n            assertFalse(setUnderTest.contains(src));\n        }\n    }\n\n\n    /**\n     * In this test HashMap will cross capacity threshold multiple times in\n     * different directions which will trigger rehashing. Because rehashing\n     * requires modification of Entry class for all hash map entries some keys\n     * may temporarily disappear from the map.\n     * <p>\n     * For more information please take a look at transfer method in HashMap.\n     *\n     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n     */\n    @Test\n    public void testConcurrentAddRemove() {\n        final IConcurrentSet testSet = createSet();\n        // a set of unique integers that will stay permanently in the test set\n        final List permanentObjects = new ArrayList();\n        // a set of objects that will be added and removed at random to the test set to force rehashing\n        final List volatileObjects = new ArrayList();\n        permanentObjects.addAll(createWithRandomIntegers(80, null));\n        volatileObjects.addAll(createWithRandomIntegers(10000, permanentObjects));\n        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n        final int mutatorThreshold = 1000;\n\n        // Add elements that will not be touched by the constantly running mutating thread\n        for (Object permanent : permanentObjects) {\n            testSet.add(permanent);\n        }\n\n        // Adds and removes items\n        // thus forcing constant rehashing of the backing hashtable\n        Runnable rehasher = new Runnable() {\n            public void run() {\n                Random rand = new Random();\n                for(int times = 0; times < 1000 ; times++){\n                    HashSet elements = new HashSet(mutatorThreshold);\n\n                    for (int i = 0; i < mutatorThreshold; i++) {\n                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n                        testSet.add(volatileObject);\n                        elements.add(volatileObject);\n                    }\n                    for (Object volObj : elements) {\n                        testSet.remove(volObj);\n                    }\n                }\n            };\n        };\n\n        Runnable lookup = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++) {\n                    for (Object permanent : permanentObjects) {\n                        // permanent items are never touched,\n                        // --> set.contains(j) should always return true\n                        if(!testSet.contains(permanent))\n                            missing.add(permanent);\n                    }\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(rehasher, lookup, lookup, lookup);\n        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n\n    }\n\n\n    public Set createWithRandomIntegers(int size, List<Integer> excluding){\n        if(excluding == null) excluding = new ArrayList<Integer>();\n        Set<Integer> result = new HashSet<Integer>(size);\n        Random rand = new Random();\n        while(result.size() < size){\n            result.add(rand.nextInt());\n        }\n        for(Integer excluded : excluding)\n            result.remove(excluded);\n        return result;\n    }\n\n    protected void protectFromGarbageCollector(Set elements){\n        for(Object element : elements)\n            gcProtector.add(element);\n    }\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Map;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public void add(T element) {\n        if (element == null) return;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        if (element == null || entries.containsKey(element)) {\n            writeLock.unlock();\n        } else {\n            insert(element);\n            writeLock.unlock();\n        }\n    }\n\n    @Override\n    public boolean contains(T element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n        }\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public void addAll(Iterable<T> elements) {\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    @Override\n    public boolean remove(T element) {\n        if (!contains(element)) {\n            // return quickly\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    // if it was second, now it's first\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // can not nullify references to help GC since running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n/**\n * This implementation uses strong references to the elements.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class StrongConcurrentSet<T> extends AbstractConcurrentSet<T>{\n\n\n    public StrongConcurrentSet() {\n        super(new HashMap<T, ISetEntry<T>>());\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private ISetEntry<T> current = head;\n\n            public boolean hasNext() {\n                return current != null;\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n               else {\n                    T value = current.getValue();\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) {\n                    return;\n                }\n                ISetEntry<T> newCurrent = current.next();\n                StrongConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n    @Override\n    protected Entry<T> createEntry(T value, Entry<T> next) {\n        return next != null ? new StrongEntry<T>(value, next) : new StrongEntry<T>(value);\n    }\n\n\n    public static class StrongEntry<T> extends Entry<T> {\n\n        private T value;\n\n        private StrongEntry(T value, Entry<T> next) {\n            super(next);\n            this.value = value;\n        }\n\n        private StrongEntry(T value) {\n            super();\n            this.value = value;\n        }\n\n        @Override\n        public T getValue() {\n            return value;\n        }\n\n\n\n\n    }\n}\n","src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\n/**\n *\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class WeakConcurrentSetTest extends ConcurrentSetTest{\n\n\n\n\n\n    @Override\n    protected IConcurrentSet createSet() {\n        return new WeakConcurrentSet();\n    }\n\n    @Test\n    public void testIteratorCleanup() {\n\n        // Assemble\n        final HashSet<Object> permanentElements = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                permanentElements.add(candidate);\n            }\n            testSetWeak.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of permanent candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSetWeak) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        // the set should have cleaned up the garbage collected elements\n        // it must still contain all of the permanent objects\n        // since different GC mechanisms can be used (not necessarily full, stop-the-world) not all dead objects\n        // must have been collected\n        assertTrue(permanentElements.size() <= testSetWeak.size() && testSetWeak.size() < numberOfElements);\n        for (Object test : testSetWeak) {\n            assertTrue(permanentElements.contains(test));\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread-safe container that manages exactly one message handler of all registered\n * message listeners of the same class, i.e. all subscribed instances (exlcuding subclasses) of a SingleMessageHandler.class\n * will be referenced in the subscription created for SingleMessageHandler.class.\n *\n * There will be as many unique subscription objects per message listener class as there are message handlers\n * defined in the message listeners class hierarchy.\n *\n * The subscription provides functionality for message publication by means of delegation to the respective\n * message dispatcher.\n *\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    /**\n     * Check whether this subscription manages a message handler of the given message listener class\n     *\n     * @param listener\n     * @return\n     */\n    public boolean belongsTo(Class listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    /**\n     * Check whether this subscriptions manages the given listener instance\n     * @param listener\n     * @return\n     */\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    /**\n     * Check whether this subscription manages a message handler\n     * @param messageType\n     * @return\n     */\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public Class[] getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(IMessagePublication publication, Object message){\n        if(listeners.size() > 0)\n            dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int byPriority = ((Integer)o2.getPriority()).compareTo(o1.getPriority());\n            return byPriority == 0 ? o2.id.compareTo(o1.id) : byPriority;\n        }\n    };\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandler messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        try{\n            readWriteLock.readLock().lock();\n\n            if (subscriptionsPerMessage.get(messageType) != null) {\n\t            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n            }\n            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (Subscription sub : subs) {\n                        if (sub.handlesMessageType(messageType)) {\n                            subscriptions.add(sub);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n\n    // associate a subscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport java.util.Collection;\n\nimport net.engio.mbassy.common.StrongConcurrentSet;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class StrongConcurrentSetTest extends ConcurrentSetTest{\n\n    @Override\n    protected Collection createSet() {\n        return new StrongConcurrentSet();\n    }\n}\n","src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends AssertSupport {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n\n    protected Set gcProtector = new HashSet();\n\n    @Before\n    public void beforeTest(){\n        super.beforeTest();\n        gcProtector = new HashSet();\n    }\n\n    protected abstract Collection createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final Collection testSet = createSet();\n        Random rand = new Random();\n\n        // getAll set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n    }\n\n    @Test()\n    public void testIterationWithConcurrentRemoval() {\n        final Collection<AtomicInteger> testSet = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            AtomicInteger element = new AtomicInteger();\n            testSet.add(element);\n            gcProtector.add(element);\n        }\n\n        Runnable incrementer = new Runnable() {\n            @Override\n            public void run() {\n                while(testSet.size() > 100){\n                    for(AtomicInteger element : testSet)\n                        element.incrementAndGet();\n                }\n\n            }\n        };\n\n        Runnable remover = new Runnable() {\n            @Override\n            public void run() {\n                while(testSet.size() > 100){\n                    for(AtomicInteger element : testSet)\n                        if(rand.nextInt() % 3 == 0 && testSet.size() > 100)\n                            testSet.remove(element);\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(20, incrementer, incrementer, remover);\n\n        Set<Integer> counts = new HashSet<Integer>();\n        for (AtomicInteger count : testSet) {\n            counts.add(count.get());\n        }\n        // all atomic integers should have been visited by the the incrementer\n        // the same number of times\n        // in other words: they have either been removed at some point or incremented in each\n        // iteration such that all remaining atomic integers must share the same value\n        assertEquals(1, counts.size());\n    }\n\n\n\n    @Test\n    public void testRandomRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final Collection testSet = createSet();\n        // getAll set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalOfHead() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final Collection testSet = createSet();\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final Collection testSet = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final Collection setUnderTest = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            setUnderTest.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = setUnderTest.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, setUnderTest.size());\n        for(Object src : source){\n            assertFalse(setUnderTest.contains(src));\n        }\n    }\n\n\n    /**\n     * In this test HashMap will cross capacity threshold multiple times in\n     * different directions which will trigger rehashing. Because rehashing\n     * requires modification of Entry class for all hash map entries some keys\n     * may temporarily disappear from the map.\n     * <p>\n     * For more information please take a look at transfer method in HashMap.\n     *\n     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n     */\n    @Test\n    public void testConcurrentAddRemove() {\n        final Collection testSet = createSet();\n        // a set of unique integers that will stay permanently in the test set\n        final List permanentObjects = new ArrayList();\n        // a set of objects that will be added and removed at random to the test set to force rehashing\n        final List volatileObjects = new ArrayList();\n        permanentObjects.addAll(createWithRandomIntegers(80, null));\n        volatileObjects.addAll(createWithRandomIntegers(10000, permanentObjects));\n        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n        final int mutatorThreshold = 1000;\n\n        // Add elements that will not be touched by the constantly running mutating thread\n        for (Object permanent : permanentObjects) {\n            testSet.add(permanent);\n        }\n\n        // Adds and removes items\n        // thus forcing constant rehashing of the backing hashtable\n        Runnable rehasher = new Runnable() {\n            public void run() {\n                Random rand = new Random();\n                for(int times = 0; times < 1000 ; times++){\n                    HashSet elements = new HashSet(mutatorThreshold);\n\n                    for (int i = 0; i < mutatorThreshold; i++) {\n                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n                        testSet.add(volatileObject);\n                        elements.add(volatileObject);\n                    }\n                    for (Object volObj : elements) {\n                        testSet.remove(volObj);\n                    }\n                }\n            };\n        };\n\n        Runnable lookup = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++) {\n                    for (Object permanent : permanentObjects) {\n                        // permanent items are never touched,\n                        // --> set.contains(j) should always return true\n                        if(!testSet.contains(permanent))\n                            missing.add(permanent);\n                    }\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(rehasher, lookup, lookup, lookup);\n        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n\n    }\n\n\n    public Set createWithRandomIntegers(int size, List<Integer> excluding){\n        if(excluding == null) excluding = new ArrayList<Integer>();\n        Set<Integer> result = new HashSet<Integer>(size);\n        Random rand = new Random();\n        while(result.size() < size){\n            result.add(rand.nextInt());\n        }\n        for(Integer excluded : excluding)\n            result.remove(excluded);\n        return result;\n    }\n\n    protected void protectFromGarbageCollector(Set elements){\n        for(Object element : elements)\n            gcProtector.add(element);\n    }\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n * @author dorkbox\n *         Date: 22/2/15\n */\npublic abstract class AbstractConcurrentSet<T> implements Set<T> {\n    private static final AtomicLong id = new AtomicLong();\n    private final long ID = id.getAndIncrement();\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public boolean add(T element) {\n        if (element == null) return false;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        boolean changed = insert(element);\n        writeLock.unlock();\n        return changed;\n    }\n\n    @Override\n    public boolean contains(Object element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private boolean insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> elements) {\n        boolean changed = false;\n\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    changed |= insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean remove(Object element) {\n        if (!contains(element)) {\n            // return quickly\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    // if it was second, now it's first\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        return this.entries.entrySet().toArray();\n    }\n\n    @SuppressWarnings(\"hiding\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return this.entries.entrySet().toArray(a);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"rawtypes\")\n        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n        if (this.ID != other.ID) {\n            return false;\n        }\n        return true;\n    }\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // can not nullify references to help GC since running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Iterator;\n\n/**\n * This implementation uses strong references to the elements.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class StrongConcurrentSet<T> extends AbstractConcurrentSet<T>{\n\n\n    public StrongConcurrentSet() {\n        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n        super(new ConcurrentHashMapV8<T, ISetEntry<T>>());\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private ISetEntry<T> current = head;\n\n            public boolean hasNext() {\n                return current != null;\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n               else {\n                    T value = current.getValue();\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) {\n                    return;\n                }\n                ISetEntry<T> newCurrent = current.next();\n                StrongConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n    @Override\n    protected Entry<T> createEntry(T value, Entry<T> next) {\n        return next != null ? new StrongEntry<T>(value, next) : new StrongEntry<T>(value);\n    }\n\n\n    public static class StrongEntry<T> extends Entry<T> {\n\n        private T value;\n\n        private StrongEntry(T value, Entry<T> next) {\n            super(next);\n            this.value = value;\n        }\n\n        private StrongEntry(T value) {\n            super();\n            this.value = value;\n        }\n\n        @Override\n        public T getValue() {\n            return value;\n        }\n\n\n\n\n    }\n}\n","src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.WeakConcurrentSet;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\n/**\n *\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class WeakConcurrentSetTest extends ConcurrentSetTest{\n\n\n\n\n\n    @Override\n    protected Collection createSet() {\n        return new WeakConcurrentSet();\n    }\n\n    @Test\n    public void testIteratorCleanup() {\n\n        // Assemble\n        final HashSet<Object> permanentElements = new HashSet<Object>();\n        final Collection testSetWeak = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                permanentElements.add(candidate);\n            }\n            testSetWeak.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of permanent candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSetWeak) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        // the set should have cleaned up the garbage collected elements\n        // it must still contain all of the permanent objects\n        // since different GC mechanisms can be used (not necessarily full, stop-the-world) not all dead objects\n        // must have been collected\n        assertTrue(permanentElements.size() <= testSetWeak.size() && testSetWeak.size() < numberOfElements);\n        for (Object test : testSetWeak) {\n            assertTrue(permanentElements.contains(test));\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread-safe container that manages exactly one message handler of all registered\n * message listeners of the same class, i.e. all subscribed instances (excluding subclasses) of a SingleMessageHandler.class\n * will be referenced in the subscription created for SingleMessageHandler.class.\n *\n * There will be as many unique subscription objects per message listener class as there are message handlers\n * defined in the message listeners class hierarchy.\n *\n * The subscription provides functionality for message publication by means of delegation to the respective\n * message dispatcher.\n *\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final Collection<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, Collection<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    /**\n     * Check whether this subscription manages a message handler of the given message listener class\n     *\n     * @param listener\n     * @return\n     */\n    public boolean belongsTo(Class listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    /**\n     * Check whether this subscriptions manages the given listener instance\n     * @param listener\n     * @return\n     */\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    /**\n     * Check whether this subscription manages a message handler\n     * @param messageType\n     * @return\n     */\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public Class[] getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(IMessagePublication publication, Object message){\n        if(listeners.size() > 0)\n            dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int byPriority = ((Integer)o2.getPriority()).compareTo(o1.getPriority());\n            return byPriority == 0 ? o2.id.compareTo(o1.id) : byPriority;\n        }\n    };\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ConcurrentHashMapV8;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage;\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener;\n\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n\n        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n        subscriptionsPerMessage = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n        subscriptionsPerListener = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandler messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        try{\n            readWriteLock.readLock().lock();\n\n            if (subscriptionsPerMessage.get(messageType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n            }\n            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (Subscription sub : subs) {\n                        if (sub.handlesMessageType(messageType)) {\n                            subscriptions.add(sub);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n\n    // associate a subscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java":[[15,15]],"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[47,47],[215,215],[247,247],[130,130],[39,39],[79,79],[177,177],[290,290]],"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":[[57,57],[31,31],[35,40]],"src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java":[[18,18]],"src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java":[[26,26],[35,35]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[98,98]]},"postChangeRange":{"src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java":[[16,16]],"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[46,46],[214,214],[246,246],[129,129],[38,38],[78,78],[176,176],[289,289]],"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":[[61,61],[65,65],[67,67],[38,38],[39,39],[42,42],[43,43],[44,44]],"src/main/java/net/engio/mbassy/common/StrongConcurrentSet.java":[[18,18]],"src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java":[[27,27],[36,36]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[58,58],[59,59],[103,103]]},"microChanges":[{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":35,"endLine":35}],"rightSideLocations":[]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java","startLine":35,"endLine":35}],"rightSideLocations":[]}],"refactorings":[]},{"repository":"mbassador","sha1":"d6aa291b8662849033a1d8ec0772babd6e3ef166","url":"https://github.com/bennidi/mbassador/commit/d6aa291b8662849033a1d8ec0772babd6e3ef166","preChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends AssertSupport {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n    \n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        Random rand = new Random();\n\n        // getAll set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSetWeak.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSetWeak.contains(uniqueObject));\n        }\n    }\n\n    @Test\n    public void testIterationWithConcurrentRemoval() {\n        final IConcurrentSet<AtomicInteger> testSetWeak = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            testSetWeak.add(new AtomicInteger());\n        }\n\n        Runnable incrementer = new Runnable() {\n            @Override\n            public void run() {\n                while(testSetWeak.size() > 100){\n                    for(AtomicInteger element : testSetWeak)\n                        element.incrementAndGet();\n                }\n\n            }\n        };\n\n        Runnable remover = new Runnable() {\n            @Override\n            public void run() {\n                while(testSetWeak.size() > 100){\n                    for(AtomicInteger element : testSetWeak)\n                        if(rand.nextInt() % 3 == 0)\n                            testSetWeak.remove(element);\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(20, incrementer, incrementer, remover);\n\n        Set<Integer> counts = new HashSet<Integer>();\n        for (AtomicInteger count : testSetWeak) {\n            counts.add(count.get());\n        }\n        assertEquals(1, counts.size());\n    }\n\n\n\n    @Test\n    public void testRandomRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // getAll set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalOfHead() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                    if (toRemove.contains(src))\n                        testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet setUnderTest = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            setUnderTest.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = setUnderTest.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, setUnderTest.size());\n        for(Object src : source){\n            assertFalse(setUnderTest.contains(src));\n        }\n    }\n\n\n    /**\n     * In this test HashMap will cross capacity threshold multiple times in\n     * different directions which will trigger rehashing. Because rehashing\n     * requires modification of Entry class for all hash map entries some keys\n     * may temporarily disappear from the map.\n     * <p>\n     * For more information please take a look at transfer method in HashMap.\n     *\n     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n     */\n    @Test\n    public void testConcurrentAddRemove() {\n        final IConcurrentSet testSet = createSet();\n        // a set of unique integers that will stay permanently in the test set\n        final List permanentObjects = new ArrayList();\n        // a set of objects that will be added and removed at random to the test set to force rehashing\n        final List volatileObjects = new ArrayList();\n        permanentObjects.addAll(createWithRandomIntegers(80, null));\n        volatileObjects.addAll(createWithRandomIntegers(10000, permanentObjects));\n        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n        final int mutatorThreshold = 1000;\n\n        // Add elements that will not be touched by the constantly running mutating thread\n        for (Object permanent : permanentObjects) {\n            testSet.add(permanent);\n        }\n\n        // Adds and removes items\n        // thus forcing constant rehashing of the backing hashtable\n        Runnable rehasher = new Runnable() {\n            public void run() {\n                Random rand = new Random();\n                for(int times = 0; times < 1000 ; times++){\n                    HashSet elements = new HashSet(mutatorThreshold);\n\n                    for (int i = 0; i < mutatorThreshold; i++) {\n                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n                        testSet.add(volatileObject);\n                        elements.add(volatileObject);\n                    }\n                    for (Object volObj : elements) {\n                        testSet.remove(volObj);\n                    }\n                }\n            };\n        };\n\n        Runnable lookup = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++) {\n                    for (Object permanent : permanentObjects) {\n                        // permanent items are never touched,\n                        // --> set.contains(j) should always return true\n                        if(!testSet.contains(permanent))\n                            missing.add(permanent);\n                    }\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(rehasher, lookup, lookup, lookup);\n        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n\n    }\n\n\n    public Set createWithRandomIntegers(int size, List<Integer> excluding){\n        if(excluding == null) excluding = new ArrayList<Integer>();\n        Set<Integer> result = new HashSet<Integer>(size);\n        Random rand = new Random();\n        while(result.size() < size){\n            result.add(rand.nextInt());\n        }\n        for(Integer excluded : excluding)\n            result.remove(excluded);\n        return result;\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 10000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IMessageBus bus = getBus(BusConfiguration.Default()\n                .setNumberOfMessageDispatchers(6));\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        MessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IMessageBus bus = getBus(BusConfiguration.Default()\n                .setNumberOfMessageDispatchers(6));\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            bus.post(new Object()).asynchronously();\n        }\n\n        pause(10000);\n\n        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest<Bus extends ISyncMessageBus> extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            Assert.fail();\n        }\n    };\n\n\n    @Before\n    public void setUp(){\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public MBassador getBus(BusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n    public MBassador getBus(BusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MethodDispatchTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Very simple test to verify dispatch to correct message handler\n *\n * @author bennidi\n *         Date: 1/17/13\n */\npublic class MethodDispatchTest extends MessageBusTest{\n\n   private boolean listener1Called = false;\n   private boolean listener2Called = false;\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Handler\n        public void handleString(String s) {\n             listener1Called = true;\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n           listener2Called = true;\n        }\n\n    }\n\n    @Test\n    public void testDispatch1(){\n        IMessageBus bus = getBus(BusConfiguration.Default());\n        EventListener2 listener2 = new EventListener2();\n        bus.subscribe(listener2);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener2Called);\n        assertFalse(listener1Called);\n\n        EventListener1 listener1 = new EventListener1();\n        bus.subscribe(listener1);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener1Called);\n    }\n\n}\n","src/main/java/net/engio/mbassy/PublicationError.java":"package net.engio.mbassy;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are created when object publication fails\n * for some reason and contain details as to the cause and location\n * where they occurred.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n *         Time: 4:59 PM\n */\npublic class PublicationError {\n\n    // Internal state\n    private Throwable cause;\n    private String message;\n    private Method listener;\n    private Object listeningObject;\n    private Object publishedObject;\n\n    /**\n     * Compound constructor, creating a PublicationError from the supplied objects.\n     *\n     * @param cause           The Throwable giving rise to this PublicationError.\n     * @param message         The message to send.\n     * @param listener        The method where the error was created.\n     * @param listeningObject The object in which the PublicationError was generated.\n     * @param publishedObject The published object which gave rise to the error.\n     */\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final Method listener,\n                            final Object listeningObject,\n                            final Object publishedObject) {\n\n        this.cause = cause;\n        this.message = message;\n        this.listener = listener;\n        this.listeningObject = listeningObject;\n        this.publishedObject = publishedObject;\n    }\n\n    /**\n     * Default constructor.\n     */\n    public PublicationError() {\n        super();\n    }\n\n    /**\n     * @return The Throwable giving rise to this PublicationError.\n     */\n    public Throwable getCause() {\n        return cause;\n    }\n\n    /**\n     * Assigns the cause of this PublicationError.\n     *\n     * @param cause A Throwable which gave rise to this PublicationError.\n     * @return This PublicationError.\n     */\n    public PublicationError setCause(Throwable cause) {\n        this.cause = cause;\n        return this;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public PublicationError setMessage(String message) {\n        this.message = message;\n        return this;\n    }\n\n    public Method getListener() {\n        return listener;\n    }\n\n    public PublicationError setListener(Method listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    public Object getListeningObject() {\n        return listeningObject;\n    }\n\n    public PublicationError setListeningObject(Object listeningObject) {\n        this.listeningObject = listeningObject;\n        return this;\n    }\n\n    public Object getPublishedObject() {\n        return publishedObject;\n    }\n\n    public PublicationError setPublishedObject(Object publishedObject) {\n        this.publishedObject = publishedObject;\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n    \tString newLine = System.getProperty(\"line.separator\");\n        return \"PublicationError{\" +\n                newLine +\n                \"\\tcause=\" + cause +\n                newLine +\n                \"\\tmessage='\" + message + '\\'' +\n                newLine +\n                \"\\tlistener=\" + listener +\n                newLine +\n                \"\\tlisteningObject=\" + listeningObject +\n                newLine +\n                \"\\tpublishedObject=\" + publishedObject +\n                '}';\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * managed by the subscription manager.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext<Bus extends ISyncMessageBus> {\n\n    private Bus owningBus;\n\n    private MessageHandlerMetadata handlerMetadata;\n\n    public SubscriptionContext(Bus owningBus, MessageHandlerMetadata handlerMetadata) {\n        this.owningBus = owningBus;\n        this.handlerMetadata = handlerMetadata;\n    }\n\n    /**\n     * Get a reference to the message bus this context belongs to\n     *\n     * @return\n     */\n    public Bus getOwningBus() {\n        return owningBus;\n    }\n\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n}\n","src/test/java/net/engio/mbassy/MBassadorTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(new BusConfiguration(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(new BusConfiguration(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(new BusConfiguration(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final MBassador bus = new MBassador(new BusConfiguration());\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).asynchronously();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.*;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract ISyncMessageBus getSyncMessageBus();\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final ISyncMessageBus bus = getSyncMessageBus();\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                bus.post(new IncrementingMessage()).now();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new MBassador(BusConfiguration.Default());\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new SyncMessageBus(new SyncBusConfiguration());\n        }\n    }\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else Assert.fail(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.MessageBusException;\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    private ISyncMessageBus bus;\n\n    public SubscriptionFactory setBus(ISyncMessageBus bus) {\n        this.bus = bus;\n        return this;\n    }\n\n    public Subscription createSubscription(MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n        try {\n            SubscriptionContext context = new SubscriptionContext(bus, handlerMetadata);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static class Factory {\n\n        public MessagePublication createPublication(ISyncMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n        }\n\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Initial;\n\n    private boolean delivered = false;\n\n    private ISyncMessageBus bus;\n\n    protected MessagePublication(ISyncMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                bus.post(new FilteredMessage(message)).now();\n            } else if (!isDeadEvent()) {\n                bus.post(new DeadMessage(message)).now();\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (!state.equals(State.Initial)) {\n            return this;\n        }\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError() {\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/ISyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PubSubSupport;\n\nimport java.util.Collection;\n\n/**\n *\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic interface ISyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> extends PubSubSupport<T>{\n\n\n    /**\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     */\n    interface ISyncPostCommand {\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        void now();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n * <p/>\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic abstract class HandlerInvocation<Listener, Message> extends AbstractSubscriptionContextAware<ISyncMessageBus> implements IHandlerInvocation<Listener, Message,ISyncMessageBus>{\n\n\n    public HandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\n\n/**\n * Created with IntelliJ IDEA.\n * User: benjamin\n * Date: 4/3/13\n * Time: 9:02 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n\n\n    public SyncMessageBus(SyncBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements ISyncMessageBus.ISyncPostCommand{\n\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n * <p/>\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n * <p/>\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message     The message that should be delivered to the listeners\n     * @param listeners   The listeners that should receive the message\n     */\n    void dispatch(MessagePublication publication, Object message, Iterable listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the\n     * message to each listener.\n     *\n     * @return the handler invocation that will be used to deliver the\n     *         message to each listener\n     */\n    IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    public boolean belongsTo(Class listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public List<Class<?>> getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int byPriority = ((Integer)o1.getPriority()).compareTo(o2.getPriority());\n            return byPriority == 0 ? o1.id.compareTo(o2.id) : byPriority;\n        }\n    };\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.dispatch.ISubscriptionContextAware;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware<Bus extends ISyncMessageBus> implements ISubscriptionContextAware<Bus> {\n\n    private final SubscriptionContext<Bus> context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext<Bus> context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext<Bus> getContext() {\n        return context;\n    }\n\n    @Override\n    public Bus getBus() {\n        return context.getOwningBus();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends HandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error) {\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for (IPublicationErrorHandler handler : handlers) {\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler) {\n        try {\n            handler.invoke(listener, message);\n        } catch (IllegalAccessException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        } catch (IllegalArgumentException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        } catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        } catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware<IMessageBus> implements IHandlerInvocation<Object,Object,IMessageBus> {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\n\n/**\n *\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener(){\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener(){\n        ListenerFactory listeners = listeners(\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class,\n                MessagesListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener(){\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener,  sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers(){\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private ListenerFactory listeners(Class ...listeners){\n        ListenerFactory factory = new ListenerFactory();\n        for(Class listener : listeners){\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/SynchronizedHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * Synchronizes message handler invocations for all handlers that specify @Synchronized\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerInvocation extends AbstractSubscriptionContextAware<IMessageBus> implements IHandlerInvocation<Object,Object,IMessageBus>  {\n\n    private IHandlerInvocation delegate;\n\n    public SynchronizedHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        synchronized (listener){\n            delegate.invoke(listener, message);\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/common/TestUtil.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class TestUtil {\n\n\n    public static Runnable subscriber(final SubscriptionManager manager, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    manager.subscribe(next);\n                }\n            }\n        };\n    }\n\n    public static Runnable unsubscriber(final SubscriptionManager manager, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    manager.unsubscribe(next);\n                }\n            }\n        };\n    }\n\n    public static Runnable subscriber(final ISyncMessageBus bus, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    bus.subscribe(next);\n                }\n            }\n        };\n    }\n\n    public static Runnable unsubscriber(final ISyncMessageBus bus, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    bus.unsubscribe(next);\n                }\n            }\n        };\n    }\n\n    public static void setup(final ISyncMessageBus bus, final List<Object> listeners, int numberOfThreads) {\n        Runnable[] setupUnits = new Runnable[numberOfThreads];\n        int partitionSize;\n        if(listeners.size() >= numberOfThreads){\n          partitionSize =  (int)Math.floor(listeners.size() / numberOfThreads);\n        }\n        else{\n            partitionSize = 1;\n            numberOfThreads = listeners.size();\n        }\n\n        for(int i = 0; i < numberOfThreads; i++){\n            final int partitionStart = i * partitionSize;\n            final int partitionEnd = (i+1 < numberOfThreads)\n                    ? partitionStart + partitionSize + 1\n                    : listeners.size();\n            setupUnits[i] = new Runnable() {\n\n                private List<Object> listenerSubset = listeners.subList(partitionStart, partitionEnd);\n\n                public void run() {\n                   for(Object listener : listenerSubset){\n                       bus.subscribe(listener);\n                   }\n                }\n            };\n\n        }\n\n        ConcurrentExecutor.runConcurrent(setupUnits);\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible and using a write lock from the beginning with will dramatically decrease performance\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        readWriteLock.readLock().lock();\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        readWriteLock.readLock().unlock();\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n * <p/>\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private final IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(final MessagePublication publication, final Object message, final Iterable listeners) {\n        publication.markDelivered();\n        for (Object listener : listeners) {\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n}\n","src/test/java/net/engio/mbassy/common/AssertSupport.java":"package net.engio.mbassy.common;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.TestName;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.ref.WeakReference;\n\n/**\n * @author bennidi\n */\npublic class AssertSupport {\n\n    private Runtime runtime = Runtime.getRuntime();\n    protected Logger logger = LoggerFactory.getLogger(getClass().getSimpleName());\n    private long testExecutionStart;\n\n    @Rule\n    public TestName name = new TestName();\n\n\n    @Before\n    public void beforeTest(){\n        logger.info(\"Running test \" + getTestName());\n        testExecutionStart = System.currentTimeMillis();\n    }\n\n    @After\n    public void afterTest(){\n        logger.info(String.format(\"Finished \" + getTestName() + \": \" + (System.currentTimeMillis() - testExecutionStart) + \" ms\"));\n    }\n\n\n    public void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void pause() {\n        pause(10);\n    }\n\n    public String getTestName(){\n        return getClass().getSimpleName() + \".\" + name.getMethodName();\n    }\n\n    public void runGC() {\n        WeakReference ref = new WeakReference<Object>(new Object());\n        pause(100);\n        while(ref.get() != null) {\n            pause(10);\n            runtime.gc();\n        }\n    }\n\n    public void fail(String message) {\n        Assert.fail(message);\n    }\n\n    public void fail() {\n        Assert.fail();\n    }\n\n    public void assertTrue(Boolean condition) {\n        Assert.assertTrue(condition);\n    }\n\n    public void assertTrue(String message, Boolean condition) {\n        Assert.assertTrue(message, condition);\n    }\n\n    public void assertFalse(Boolean condition) {\n        Assert.assertFalse(condition);\n    }\n\n    public void assertNull(Object object) {\n        Assert.assertNull(object);\n    }\n\n    public void assertNotNull(Object object) {\n        Assert.assertNotNull(object);\n    }\n\n    public void assertFalse(String message, Boolean condition) {\n        Assert.assertFalse(message, condition);\n    }\n\n    public void assertEquals(Object expected, Object actual) {\n        Assert.assertEquals(expected, actual);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyncMessageBus<T,P> {\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n    /**\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n\n    interface IPostCommand extends ISyncPostCommand {\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        MessagePublication asynchronously();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout is reached.\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        MessagePublication asynchronously(long timeout, TimeUnit unit);\n    }\n\n}\n","src/test/java/net/engio/mbassy/DeadMessageTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadMessageTest extends MessageBusTest{\n\n\n    @Test\n    public void testDeadMessage(){\n        final MBassador bus = getBus(BusConfiguration.Default());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, DeadMessagHandler.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishUnhandledMessage = new Runnable() {\n            @Override\n            public void run() {\n                for(int i=0; i < IterationsPerThread; i++){\n                    int variation = i % 3;\n                    switch (variation){\n                        case 0:bus.publish(new Object());break;\n                        case 1:bus.publish(i);break;\n                        case 2:bus.publish(String.valueOf(i));break;\n                    }\n                }\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishUnhandledMessage, ConcurrentUnits);\n\n        assertEquals(InstancesPerListener * IterationsPerThread * ConcurrentUnits, DeadMessagHandler.deadMessages.get());\n    }\n\n    public static class DeadMessagHandler {\n\n        private static final AtomicInteger deadMessages = new AtomicInteger(0);\n\n\n        @Handler\n         public void handle(DeadMessage message){\n             deadMessages.incrementAndGet();\n         }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (IMessageFilter aFilter : filter) {\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners) {\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.common.ListenerFactory;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation<Listener, Message, Bus extends ISyncMessageBus> extends ISubscriptionContextAware<Bus> {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    void invoke(Listener listener, Message message);\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * The base class for all async message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends IMessageBus.IPostCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    private static final AtomicInteger threadID = new AtomicInteger();\n    \n    public AbstractSyncAsyncMessageBus(BusConfiguration configuration) {\n        super(configuration);\n        this.executor = configuration.getExecutor();\n        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n         dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\", null, null, null));\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatcher.setName(\"MBassyDispatch-\" + threadID.incrementAndGet());\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method queues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        if(executor != null) executor.shutdown();\n    }\n\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Random;\n\n/**\n *\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class WeakConcurrentSetTest extends ConcurrentSetTest{\n\n    @Override\n    protected IConcurrentSet createSet() {\n        return new WeakConcurrentSet();\n    }\n\n    @Test\n    public void testIteratorCleanup() {\n\n        // Assemble\n        final HashSet<Object> permanentElements = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                permanentElements.add(candidate);\n            }\n            testSetWeak.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of permanent candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSetWeak) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        // the set should have cleaned up the garbage collected elements\n        // it must still contain all of the permanent objects\n        // since different GC mechanisms can be used (not necessarily full, stop-the-world) not all dead objects\n        // must have been collected\n        assertTrue(permanentElements.size() <= testSetWeak.size() && testSetWeak.size() < numberOfElements);\n        for (Object test : testSetWeak) {\n            assertTrue(permanentElements.contains(test));\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\n\nimport net.engio.mbassy.common.DeadMessage;\n\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncMessageBus<T, P extends ISyncMessageBus.ISyncPostCommand> implements ISyncMessageBus<T, P> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n\n    public AbstractSyncMessageBus(SyncBusConfiguration configuration) {\n        this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n                configuration.getSubscriptionFactory().setBus(this));\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        synchronized (this){\n            errorHandlers.add(handler);\n        }\n    }\n\n\n    protected MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(this, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends AssertSupport {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n\n    protected Set gcProtector = new HashSet();\n\n    @Before\n    public void beforeTest(){\n        super.beforeTest();\n        gcProtector = new HashSet();\n    }\n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSet = createSet();\n        Random rand = new Random();\n\n        // getAll set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n    }\n\n    @Test()\n    public void testIterationWithConcurrentRemoval() {\n        final IConcurrentSet<AtomicInteger> testSet = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            AtomicInteger element = new AtomicInteger();\n            testSet.add(element);\n            gcProtector.add(element);\n        }\n\n        Runnable incrementer = new Runnable() {\n            @Override\n            public void run() {\n                while(testSet.size() > 100){\n                    for(AtomicInteger element : testSet)\n                        element.incrementAndGet();\n                }\n\n            }\n        };\n\n        Runnable remover = new Runnable() {\n            @Override\n            public void run() {\n                while(testSet.size() > 100){\n                    for(AtomicInteger element : testSet)\n                        if(rand.nextInt() % 3 == 0 && testSet.size() > 100)\n                            testSet.remove(element);\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(20, incrementer, incrementer, remover);\n\n        Set<Integer> counts = new HashSet<Integer>();\n        for (AtomicInteger count : testSet) {\n            counts.add(count.get());\n        }\n        // all atomic integers should have been visited by the the incrementer\n        // the same number of times\n        // in other words: they have either been removed at some point or incremented in each\n        // iteration such that all remaining atomic integers must share the same value\n        assertEquals(1, counts.size());\n    }\n\n\n\n    @Test\n    public void testRandomRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSet = createSet();\n        // getAll set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalOfHead() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSet = createSet();\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSet = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet setUnderTest = createSet();\n\n        // getAll set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            setUnderTest.add(candidate);\n        }\n\n        // getAll test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = setUnderTest.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, setUnderTest.size());\n        for(Object src : source){\n            assertFalse(setUnderTest.contains(src));\n        }\n    }\n\n\n    /**\n     * In this test HashMap will cross capacity threshold multiple times in\n     * different directions which will trigger rehashing. Because rehashing\n     * requires modification of Entry class for all hash map entries some keys\n     * may temporarily disappear from the map.\n     * <p>\n     * For more information please take a look at transfer method in HashMap.\n     *\n     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n     */\n    @Test\n    public void testConcurrentAddRemove() {\n        final IConcurrentSet testSet = createSet();\n        // a set of unique integers that will stay permanently in the test set\n        final List permanentObjects = new ArrayList();\n        // a set of objects that will be added and removed at random to the test set to force rehashing\n        final List volatileObjects = new ArrayList();\n        permanentObjects.addAll(createWithRandomIntegers(80, null));\n        volatileObjects.addAll(createWithRandomIntegers(10000, permanentObjects));\n        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n        final int mutatorThreshold = 1000;\n\n        // Add elements that will not be touched by the constantly running mutating thread\n        for (Object permanent : permanentObjects) {\n            testSet.add(permanent);\n        }\n\n        // Adds and removes items\n        // thus forcing constant rehashing of the backing hashtable\n        Runnable rehasher = new Runnable() {\n            public void run() {\n                Random rand = new Random();\n                for(int times = 0; times < 1000 ; times++){\n                    HashSet elements = new HashSet(mutatorThreshold);\n\n                    for (int i = 0; i < mutatorThreshold; i++) {\n                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n                        testSet.add(volatileObject);\n                        elements.add(volatileObject);\n                    }\n                    for (Object volObj : elements) {\n                        testSet.remove(volObj);\n                    }\n                }\n            };\n        };\n\n        Runnable lookup = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++) {\n                    for (Object permanent : permanentObjects) {\n                        // permanent items are never touched,\n                        // --> set.contains(j) should always return true\n                        if(!testSet.contains(permanent))\n                            missing.add(permanent);\n                    }\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(rehasher, lookup, lookup, lookup);\n        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n\n    }\n\n\n    public Set createWithRandomIntegers(int size, List<Integer> excluding){\n        if(excluding == null) excluding = new ArrayList<Integer>();\n        Set<Integer> result = new HashSet<Integer>(size);\n        Random rand = new Random();\n        while(result.size() < size){\n            result.add(rand.nextInt());\n        }\n        for(Integer excluded : excluding)\n            result.remove(excluded);\n        return result;\n    }\n\n    protected void protectFromGarbageCollector(Set elements){\n        for(Object element : elements)\n            gcProtector.add(element);\n    }\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 10000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IMessageBus bus = getBus(BusConfiguration.Default()\n                .setNumberOfMessageDispatchers(6));\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        MessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IMessageBus bus = getBus(BusConfiguration.Default()\n                .setNumberOfMessageDispatchers(6));\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            bus.post(new Object()).asynchronously();\n        }\n\n        pause(10000);\n\n        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            Assert.fail();\n        }\n    };\n\n\n    @Before\n    public void setUp(){\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public MBassador getBus(BusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n    public MBassador getBus(BusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMBassador<T> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    @Override\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    @Override\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MethodDispatchTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Very simple test to verify dispatch to correct message handler\n *\n * @author bennidi\n *         Date: 1/17/13\n */\npublic class MethodDispatchTest extends MessageBusTest{\n\n   private boolean listener1Called = false;\n   private boolean listener2Called = false;\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Handler\n        public void handleString(String s) {\n             listener1Called = true;\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n           listener2Called = true;\n        }\n\n    }\n\n    @Test\n    public void testDispatch1(){\n        IMessageBus bus = getBus(BusConfiguration.Default());\n        EventListener2 listener2 = new EventListener2();\n        bus.subscribe(listener2);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener2Called);\n        assertFalse(listener1Called);\n\n        EventListener1 listener1 = new EventListener1();\n        bus.subscribe(listener1);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener1Called);\n    }\n\n}\n","src/main/java/net/engio/mbassy/PublicationError.java":"package net.engio.mbassy;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are created when object publication fails\n * for some reason and contain details as to the cause and location\n * where they occurred.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n *         Time: 4:59 PM\n */\npublic class PublicationError{\n\n    // Internal state\n    private Throwable cause;\n    private String message;\n    private Method handler;\n    private Object listener;\n    private Object publishedObject;\n\n\n    /**\n     * Compound constructor, creating a PublicationError from the supplied objects.\n     *\n     * @param cause           The Throwable giving rise to this PublicationError.\n     * @param message         The message to send.\n     * @param handler        The method where the error was created.\n     * @param listener The object in which the PublicationError was generated.\n     * @param publishedObject The published object which gave rise to the error.\n     */\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final Method handler,\n                            final Object listener,\n                            final Object publishedObject) {\n\n        this.cause = cause;\n        this.message = message;\n        this.handler = handler;\n        this.listener = listener;\n        this.publishedObject = publishedObject;\n    }\n\n    /**\n     * Default constructor.\n     */\n    public PublicationError() {\n        super();\n    }\n\n    /**\n     * @return The Throwable giving rise to this PublicationError.\n     */\n    public Throwable getCause() {\n        return cause;\n    }\n\n    /**\n     * Assigns the cause of this PublicationError.\n     *\n     * @param cause A Throwable which gave rise to this PublicationError.\n     * @return This PublicationError.\n     */\n    public PublicationError setCause(Throwable cause) {\n        this.cause = cause;\n        return this;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public PublicationError setMessage(String message) {\n        this.message = message;\n        return this;\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public PublicationError setHandler(Method handler) {\n        this.handler = handler;\n        return this;\n    }\n\n    public Object getListener() {\n        return listener;\n    }\n\n    public PublicationError setListener(Object listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    public Object getPublishedObject() {\n        return publishedObject;\n    }\n\n    public PublicationError setPublishedObject(Object publishedObject) {\n        this.publishedObject = publishedObject;\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n    \tString newLine = System.getProperty(\"line.separator\");\n        return \"PublicationError{\" +\n                newLine +\n                \"\\tcause=\" + cause +\n                newLine +\n                \"\\tmessage='\" + message + '\\'' +\n                newLine +\n                \"\\thandler=\" + handler +\n                newLine +\n                \"\\tlistener=\" + listener +\n                newLine +\n                \"\\tpublishedObject=\" + publishedObject +\n                '}';\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.RuntimeProvider;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\nimport java.util.Collection;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * managed by the subscription manager.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext implements RuntimeProvider {\n\n    // the handler's metadata -> for each handler in a listener, a unique subscription context is created\n    private final MessageHandlerMetadata handlerMetadata;\n\n    // error handling is first-class functionality\n    private final Collection<IPublicationErrorHandler> errorHandlers;\n\n    private BusRuntime runtime;\n\n    public SubscriptionContext(BusRuntime runtime, MessageHandlerMetadata handlerMetadata,\n                               Collection<IPublicationErrorHandler> errorHandlers) {\n        this.runtime = runtime;\n        this.handlerMetadata = handlerMetadata;\n        this.errorHandlers = errorHandlers;\n    }\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n    /**\n     * Get the error handlers registered with the enclosing bus.\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getErrorHandlers(){\n        return errorHandlers;\n    }\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n}\n","src/test/java/net/engio/mbassy/MBassadorTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(BusConfiguration.Default(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final MBassador bus = new MBassador(BusConfiguration.Default());\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).asynchronously();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract ISyncMessageBus getSyncMessageBus();\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final ISyncMessageBus bus = getSyncMessageBus();\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                bus.post(new IncrementingMessage()).now();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new MBassador(BusConfiguration.Default());\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new SyncMessageBus(BusConfiguration.Default());\n        }\n    }\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else Assert.fail(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.MessageBusException;\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    private static final String ErrorHandlers = \"error.handlers\";\n\n    public Subscription createSubscription(BusRuntime runtime, MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n        try {\n            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(ErrorHandlers);\n            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication {\n\n    private final Collection<Subscription> subscriptions;\n    private final Object message;\n    // message publications can be referenced by multiple threads to query publication progress\n    private volatile State state = State.Initial;\n    private volatile boolean delivered = false;\n    private final BusRuntime runtime;\n\n    protected MessagePublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.runtime = runtime;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n           sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                runtime.getProvider().publish(new FilteredMessage(message));\n            } else if (!isDeadEvent()) {\n                runtime.getProvider().publish(new DeadMessage(message));\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (state.equals(State.Initial)) {\n            state = State.Scheduled;\n        }\n        return this;\n    }\n\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error\n    }\n\n    public static class Factory {\n\n        public MessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(runtime, subscriptions, message, State.Initial);\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/ISyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * @author bennidi\n *         Date: 3/29/13\n */\npublic interface ISyncMessageBus<T, P extends IPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P>{\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n * <p/>\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.util.Collection;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic abstract class HandlerInvocation<HANDLER, MESSAGE> extends AbstractSubscriptionContextAware implements IHandlerInvocation<HANDLER, MESSAGE>{\n\n\n    private final Collection<IPublicationErrorHandler> errorHandlers;\n\n    public HandlerInvocation(SubscriptionContext context) {\n        super(context);\n        errorHandlers = context.getErrorHandlers();\n    }\n\n    protected void handlePublicationError(PublicationError error){\n        for(IPublicationErrorHandler handler : errorHandlers)\n            handler.handleError(error);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * Created with IntelliJ IDEA.\n * User: benjamin\n * Date: 4/3/13\n * Time: 9:02 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SyncMessageBus<T> extends AbstractSyncMessageBus<T, SyncMessageBus.SyncPostCommand>{\n\n\n    public SyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements IPublicationCommand {\n\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.subscription.ISubscriptionContextAware;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n * <p/>\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n * <p/>\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message     The message that should be delivered to the listeners\n     * @param listeners   The listeners that should receive the message\n     */\n    void dispatch(MessagePublication publication, Object message, Iterable listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the\n     * message to each listener.\n     *\n     * @return the handler invocation that will be used to deliver the\n     *         message to each listener\n     */\n    IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    public boolean belongsTo(Class listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public List<Class<?>> getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(MessagePublication publication, Object message){\n        if(listeners.size() > 0)\n            dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int byPriority = ((Integer)o1.getPriority()).compareTo(o2.getPriority());\n            return byPriority == 0 ? o1.id.compareTo(o2.id) : byPriority;\n        }\n    };\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware implements ISubscriptionContextAware {\n\n    private final SubscriptionContext context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext getContext() {\n        return context;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends HandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler){\n        try {\n            handler.invoke(listener, message);\n        } catch (IllegalAccessException e) {\n            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        } catch (IllegalArgumentException e) {\n            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        } catch (InvocationTargetException e) {\n            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        } catch (Throwable e) {\n            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"The handler code threw an exception\",\n                            handler, listener, message));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\nimport java.util.concurrent.ExecutorService;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private final IHandlerInvocation delegate;\n\n    private final ExecutorService executor;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n        this.executor = delegate.getContext().getRuntime().get(\"handler.async-service\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                    delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n *\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener(){\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener(){\n        ListenerFactory listeners = listeners(\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class,\n                MessagesListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener(){\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener,  sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers(){\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private BusRuntime mockedRuntime(){\n        return new BusRuntime(null)\n                .add(\"error.handlers\", Collections.EMPTY_SET)\n                .add(\"handler.async-service\", null);\n    }\n\n    private ListenerFactory listeners(Class ...listeners){\n        ListenerFactory factory = new ListenerFactory();\n        for(Class listener : listeners){\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/SynchronizedHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * Synchronizes message handler invocations for all handlers that specify @Synchronized\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation<Object,Object>  {\n\n    private IHandlerInvocation delegate;\n\n    public SynchronizedHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        synchronized (listener){\n            delegate.invoke(listener, message);\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/common/TestUtil.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.PubSubSupport;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class TestUtil {\n\n\n    public static Runnable subscriber(final SubscriptionManager manager, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    manager.subscribe(next);\n                }\n            }\n        };\n    }\n\n    public static Runnable unsubscriber(final SubscriptionManager manager, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    manager.unsubscribe(next);\n                }\n            }\n        };\n    }\n\n    public static Runnable subscriber(final PubSubSupport bus, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    bus.subscribe(next);\n                }\n            }\n        };\n    }\n\n    public static Runnable unsubscriber(final PubSubSupport bus, final ListenerFactory listeners){\n        final Iterator source = listeners.iterator();\n        return new Runnable() {\n            @Override\n            public void run() {\n                Object next;\n                while((next = source.next()) != null){\n                    bus.unsubscribe(next);\n                }\n            }\n        };\n    }\n\n    public static void setup(final PubSubSupport bus, final List<Object> listeners, int numberOfThreads) {\n        Runnable[] setupUnits = new Runnable[numberOfThreads];\n        int partitionSize;\n        if(listeners.size() >= numberOfThreads){\n          partitionSize =  (int)Math.floor(listeners.size() / numberOfThreads);\n        }\n        else{\n            partitionSize = 1;\n            numberOfThreads = listeners.size();\n        }\n\n        for(int i = 0; i < numberOfThreads; i++){\n            final int partitionStart = i * partitionSize;\n            final int partitionEnd = (i+1 < numberOfThreads)\n                    ? partitionStart + partitionSize + 1\n                    : listeners.size();\n            setupUnits[i] = new Runnable() {\n\n                private List<Object> listenerSubset = listeners.subList(partitionStart, partitionEnd);\n\n                public void run() {\n                   for(Object listener : listenerSubset){\n                       bus.subscribe(listener);\n                   }\n                }\n            };\n\n        }\n\n        ConcurrentExecutor.runConcurrent(setupUnits);\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * The subscription managers primary task is consistently handle new and existing subscriptions\n * and to synchronize concurrent access to them efficiently. It takes care of properly registering and\n * unregistering message listeners and is a core component of each bus implementation\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        readWriteLock.readLock().lock();\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        readWriteLock.readLock().unlock();\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n * <p/>\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private final IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(final MessagePublication publication, final Object message, final Iterable listeners){\n        publication.markDelivered();\n        for (Object listener : listeners) {\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n}\n","src/test/java/net/engio/mbassy/common/AssertSupport.java":"package net.engio.mbassy.common;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.TestName;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.ref.WeakReference;\n\n/**\n * @author bennidi\n */\npublic class AssertSupport {\n\n    private Runtime runtime = Runtime.getRuntime();\n    protected Logger logger = LoggerFactory.getLogger(getClass().getSimpleName());\n    private volatile long testExecutionStart;\n\n    @Rule\n    public TestName name = new TestName();\n\n\n    @Before\n    public void beforeTest(){\n        logger.info(\"Running test \" + getTestName());\n        testExecutionStart = System.currentTimeMillis();\n    }\n\n    @After\n    public void afterTest(){\n        logger.info(String.format(\"Finished \" + getTestName() + \": \" + (System.currentTimeMillis() - testExecutionStart) + \" ms\"));\n    }\n\n\n    public void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void pause() {\n        pause(10);\n    }\n\n    public String getTestName(){\n        return getClass().getSimpleName() + \".\" + name.getMethodName();\n    }\n\n    public void runGC() {\n        WeakReference ref = new WeakReference<Object>(new Object());\n        pause(100);\n        while(ref.get() != null) {\n            pause(10);\n            runtime.gc();\n        }\n    }\n\n    public void fail(String message) {\n        Assert.fail(message);\n    }\n\n    public void fail() {\n        Assert.fail();\n    }\n\n    public void assertTrue(Boolean condition) {\n        Assert.assertTrue(condition);\n    }\n\n    public void assertTrue(String message, Boolean condition) {\n        Assert.assertTrue(message, condition);\n    }\n\n    public void assertFalse(Boolean condition) {\n        Assert.assertFalse(condition);\n    }\n\n    public void assertNull(Object object) {\n        Assert.assertNull(object);\n    }\n\n    public void assertNotNull(Object object) {\n        Assert.assertNotNull(object);\n    }\n\n    public void assertFalse(String message, Boolean condition) {\n        Assert.assertFalse(message, condition);\n    }\n\n    public void assertEquals(Object expected, Object actual) {\n        Assert.assertEquals(expected, actual);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.concurrent.Executor;\n\n/**\n * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n * A message publication starts when an object is send to the bus using one of the its publication methods.\n *\n * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n *\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n * in a synchronized fashion using @Synchronized annotation\n *\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n *\n * <p/>\n * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n *\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the respective message handlers.\n *\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n *\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n *\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends ISyncAsyncPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P> {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    P post(T message);\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n\n}\n","src/test/java/net/engio/mbassy/DeadMessageTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.listeners.ObjectListener;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadMessageTest extends MessageBusTest{\n\n    @Before\n    public void beforeTest(){\n        DeadMessagHandler.deadMessages.set(0);\n    }\n\n\n    @Test\n    public void testDeadMessage(){\n        final MBassador bus = getBus(BusConfiguration.Default());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, DeadMessagHandler.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishUnhandledMessage = new Runnable() {\n            @Override\n            public void run() {\n                for(int i=0; i < IterationsPerThread; i++){\n                    int variation = i % 3;\n                    switch (variation){\n                        case 0:bus.publish(new Object());break;\n                        case 1:bus.publish(i);break;\n                        case 2:bus.publish(String.valueOf(i));break;\n                    }\n                }\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishUnhandledMessage, ConcurrentUnits);\n\n        assertEquals(InstancesPerListener * IterationsPerThread * ConcurrentUnits, DeadMessagHandler.deadMessages.get());\n    }\n\n\n\n    @Test\n    public void testUnsubscribingAllListeners() {\n        final MBassador bus = getBus(BusConfiguration.Default());\n        ListenerFactory deadMessageListener = new ListenerFactory()\n                .create(InstancesPerListener, DeadMessagHandler.class)\n                .create(InstancesPerListener, Object.class);\n        ListenerFactory objectListener = new ListenerFactory()\n                .create(InstancesPerListener, ObjectListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, deadMessageListener), ConcurrentUnits);\n\n        // Only dead message handlers available\n        bus.post(new Object()).now();\n\n        // The message should be caught as dead message since there are no subscribed listeners\n        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n\n        // Clear deadmessage for future tests\n        DeadMessagHandler.deadMessages.set(0);\n\n        // Add object listeners and publish again\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, objectListener), ConcurrentUnits);\n        bus.post(new Object()).now();\n\n        // verify that no dead message events were produced\n        assertEquals(0, DeadMessagHandler.deadMessages.get());\n\n        // Unsubscribe all object listeners\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(bus, objectListener), ConcurrentUnits);\n\n        // Only dead message handlers available\n        bus.post(new Object()).now();\n\n        // The message should be caught, as it's the only listener\n        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n    }\n\n    public static class DeadMessagHandler {\n\n        private static final AtomicInteger deadMessages = new AtomicInteger(0);\n\n        @Handler\n        public void handle(DeadMessage message){\n            deadMessages.incrementAndGet();\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (IMessageFilter aFilter : filter) {\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.common.ListenerFactory;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(BusConfiguration.Default());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(BusConfiguration.Default());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.ISubscriptionContextAware;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n *\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations by means of delegation (-> decorator pattern)\n *\n * If an exception is thrown during handler invocation it is wrapped and propagated\n * as a publication error\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation<HANDLER, MESSAGE> extends ISubscriptionContextAware {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param handler The listener that will receive the message. This can be a reference to a method object\n     *                 from the java reflection api or any other wrapper that can be used to invoke the handler\n     * @param message  The message to be delivered to the handler. This can be any object compatible with the object\n     *                 type that the handler consumes\n     */\n    void invoke(HANDLER handler, MESSAGE message);\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all async message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand> extends AbstractSyncMessageBus<T, P> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n        this.executor = configuration.getExecutorForAsynchronousHandlers();\n        getRuntime().add(\"handler.async-service\", executor);\n        pendingMessages = configuration.getPendingMessagesQueue();\n        dispatchers = new ArrayList<Thread>(configuration.getNumberOfMessageDispatchers());\n        initDispatcherThreads(configuration);\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(IBusConfiguration configuration) {\n        for (int i = 0; i < configuration.getNumberOfMessageDispatchers(); i++) {\n            // each thread will run forever and process incoming\n            // message publication requests\n\n            Thread dispatcher = configuration.getThreadFactoryForAsynchronousMessageDispatch().newThread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\", null, null, null));\n                        }\n                    }\n                }\n            });\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            // TODO: publication error\n            return request;\n        }\n    }\n\n    // this method queues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request;\n        } catch (InterruptedException e) {\n            // TODO: publication error\n            return request;\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    @Override\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        if(executor != null) executor.shutdown();\n    }\n\n    @Override\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/test/java/net/engio/mbassy/WeakConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\n/**\n *\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class WeakConcurrentSetTest extends ConcurrentSetTest{\n\n\n\n\n\n    @Override\n    protected IConcurrentSet createSet() {\n        return new WeakConcurrentSet();\n    }\n\n    @Test\n    public void testIteratorCleanup() {\n\n        // Assemble\n        final HashSet<Object> permanentElements = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                permanentElements.add(candidate);\n            }\n            testSetWeak.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of permanent candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSetWeak) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        // the set should have cleaned up the garbage collected elements\n        // it must still contain all of the permanent objects\n        // since different GC mechanisms can be used (not necessarily full, stop-the-world) not all dead objects\n        // must have been collected\n        assertTrue(permanentElements.size() <= testSetWeak.size() && testSetWeak.size() < numberOfElements);\n        for (Object test : testSetWeak) {\n            assertTrue(permanentElements.contains(test));\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncMessageBus<T, P extends IPublicationCommand> implements ISyncMessageBus<T, P>{\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n\n    public AbstractSyncMessageBus(IBusConfiguration configuration) {\n        this.runtime = new BusRuntime(this);\n        this.runtime.add(\"error.handlers\", getRegisteredErrorHandlers());\n        this.subscriptionManager = new SubscriptionManager(configuration.getMetadataReader(),\n                configuration.getSubscriptionFactory(), runtime);\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        synchronized (this){\n            errorHandlers.add(handler);\n        }\n    }\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[39,39],[57,57],[63,63],[65,65],[201,201],[207,207],[216,216],[224,224],[226,226],[116,116],[131,131],[141,141],[147,147],[152,152],[154,154],[69,69],[71,71],[75,75],[81,81],[82,82],[92,92],[93,93],[94,94],[95,95],[103,103],[163,163],[179,179],[181,181],[187,187],[192,192],[194,194]],"src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":[[35,35],[40,40],[46,46],[51,51],[52,52]],"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[26,26]],"src/main/java/net/engio/mbassy/PublicationError.java":[[29,29],[30,30],[35,35],[36,36],[42,42],[121,121],[80,80]],"src/test/java/net/engio/mbassy/MBassadorTest.java":[[63,63],[95,95],[133,133],[29,29]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[186,186]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[85,85],[86,86],[88,88],[60,60],[62,62]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[72,72],[73,73]],"src/test/java/net/engio/mbassy/FilterTest.java":[[34,34],[59,59]],"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[71,71],[80,80],[82,82]],"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":[[70,70],[72,72]],"src/main/java/net/engio/mbassy/subscription/Subscription.java":[[48,48]],"src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":[[20,20]]},"postChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[47,47],[65,65],[71,71],[73,73],[215,215],[221,221],[230,230],[238,238],[240,240],[130,130],[145,145],[155,155],[161,161],[166,166],[168,168],[77,77],[79,79],[83,83],[84,84],[85,85],[91,91],[92,92],[102,102],[103,103],[104,104],[105,105],[113,113],[177,177],[193,193],[195,195],[201,201],[206,206],[208,208]],"src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":[[25,25],[29,29],[34,34],[38,38],[39,39]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[191,191],[173,173],[216,216]],"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[30,30],[22,22]],"src/main/java/net/engio/mbassy/bus/MBassador.java":[[17,17],[22,22]],"src/main/java/net/engio/mbassy/PublicationError.java":[[30,30],[31,31],[36,36],[37,37],[42,42],[120,120],[122,122],[90,90]],"src/test/java/net/engio/mbassy/MBassadorTest.java":[[63,63],[95,95],[133,133],[29,29]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[189,189]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[100,100]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[74,74],[75,75],[49,49],[51,51]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[63,63],[65,65]],"src/main/java/net/engio/mbassy/dispatch/HandlerInvocation.java":[[23,23]],"src/test/java/net/engio/mbassy/FilterTest.java":[[34,34],[59,59]],"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[74,74],[104,104],[96,96],[83,83],[86,86]],"src/main/java/net/engio/mbassy/bus/AbstractSyncMessageBus.java":[[78,78],[80,80]],"src/main/java/net/engio/mbassy/subscription/Subscription.java":[[48,49]],"src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":[[17,17]]},"microChanges":[{"type":"ReverseConditional","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":85,"endLine":85}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":74,"endLine":74}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/Subscription.java","startLine":48,"endLine":48}]},{"type":"AddAdditionalCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":104,"endLine":104}]}],"refactorings":[{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":94,"endLine":94},{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":94,"endLine":94}],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":104,"endLine":104}]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":154,"endLine":154}],"rightSideLocations":[]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":194,"endLine":194}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"cca88c367be8fac8440527a36cb818af80bb3bc9","url":"https://github.com/bennidi/mbassador/commit/cca88c367be8fac8440527a36cb818af80bb3bc9","preChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n\t        return ReflectionUtils.getAnnotation(target, Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public MessageListener getMessageListener(Class target) {\n        MessageListener listenerMetadata = new MessageListener(target);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n                    handlerConfig, getFilter(handlerConfig), listenerMetadata);\n            MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n            listenerMetadata.addHandler(handlerMetadata);\n\n        }\n        return listenerMetadata;\n    }\n\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || ReflectionUtils.getAnnotation( handler, Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = ReflectionUtils.getAnnotation( handler, Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n\t\tList<Method> methods = new LinkedList<Method>();\n\t\ttry {\n\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n\t\t\t\tif ( condition.apply( method ) ) {\n\t\t\t\t\tmethods.add( method );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t//nop\n\t\t}\n\t\tif ( !target.equals( Object.class ) ) {\n\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/**\n\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n\t * for an override of the given methods -> finds the bottom most override of the given\n\t * method if any exists\n\t *\n\t * @param overridingMethod\n\t * @param subclass\n\t */\n\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n\t\tClass current = subclass;\n\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n\t\t\ttry {\n\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\tcurrent = current.getSuperclass();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n\tpublic static Set<Class> getSuperTypes(Class from) {\n\t\tSet<Class> superclasses = new HashSet<Class>();\n\t\tcollectInterfaces( from, superclasses );\n\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n\t\t\tsuperclasses.add( from.getSuperclass() );\n\t\t\tfrom = from.getSuperclass();\n\t\t\tcollectInterfaces( from, superclasses );\n\t\t}\n\t\treturn superclasses;\n\t}\n\n\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n\t\tfor ( Class intface : from.getInterfaces() ) {\n\t\t\taccumulator.add( intface );\n\t\t\tcollectInterfaces( intface, accumulator );\n\t\t}\n\t}\n\n\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n\t\tfor ( Method method : allMethods ) {\n\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\t/**\n\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n\t *\n\t * @param from AnnotatedElement (class, method...)\n\t * @param annotationType Annotation class to look for.\n\t * @param <A> Class of annotation type\n\t * @return Annotation instance or null\n\t */\n\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n\t\tif( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n\t}\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n\t\t// hierarchy of the given superclass method or the method names are not the same then\n\t\t// subclassMethod does not override superclassMethod\n\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n\t\t// method must specify the same number of parameters\n\t\t//the parameters must occur in the exact same order\n\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n\t        return ReflectionUtils.getAnnotation(target, Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public MessageListener getMessageListener(Class target) {\n        MessageListener listenerMetadata = new MessageListener(target);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        Collection<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n                    handlerConfig, getFilter(handlerConfig), listenerMetadata);\n            MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n            listenerMetadata.addHandler(handlerMetadata);\n\n        }\n        return listenerMetadata;\n    }\n\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || ReflectionUtils.getAnnotation( handler, Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = ReflectionUtils.getAnnotation( handler, Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n    public static Collection<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n        Collection<Method> methods = new ArrayDeque<Method>();\n        getMethods(condition, target, methods);\n        return methods;\n    }\n\n    private static void getMethods( IPredicate<Method> condition, Class<?> target, Collection<Method> methods ) {\n\t\ttry {\n\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n\t\t\t\tif ( condition.apply( method ) ) {\n\t\t\t\t\tmethods.add( method );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t//nop\n\t\t}\n\t\tif ( !target.equals( Object.class ) ) {\n            getMethods( condition, target.getSuperclass(), methods );\n\t\t}\n\t}\n\n\t/**\n\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n\t * for an override of the given methods -> finds the bottom most override of the given\n\t * method if any exists\n\t *\n\t * @param overridingMethod\n\t * @param subclass\n\t */\n\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n\t\tClass current = subclass;\n\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n\t\t\ttry {\n\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\tcurrent = current.getSuperclass();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n\tpublic static Set<Class> getSuperTypes(Class from) {\n\t\tSet<Class> superclasses = new HashSet<Class>();\n\t\tcollectInterfaces( from, superclasses );\n\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n\t\t\tsuperclasses.add( from.getSuperclass() );\n\t\t\tfrom = from.getSuperclass();\n\t\t\tcollectInterfaces( from, superclasses );\n\t\t}\n\t\treturn superclasses;\n\t}\n\n\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n\t\tfor ( Class intface : from.getInterfaces() ) {\n\t\t\taccumulator.add( intface );\n\t\t\tcollectInterfaces( intface, accumulator );\n\t\t}\n\t}\n\n    public static boolean containsOverridingMethod( final Collection<Method> allMethods, final Method methodToCheck ) {\n\t\tfor ( Method method : allMethods ) {\n\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\t/**\n\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n\t *\n\t * @param from AnnotatedElement (class, method...)\n\t * @param annotationType Annotation class to look for.\n\t * @param <A> Class of annotation type\n\t * @return Annotation instance or null\n\t */\n\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n\t\tif( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n\t}\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n\t\t// hierarchy of the given superclass method or the method names are not the same then\n\t\t// subclassMethod does not override superclassMethod\n\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n\t\t// method must specify the same number of parameters\n\t\t//the parameters must occur in the exact same order\n\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[60,60]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[19,19],[20,20],[21,30],[31,33]]},"postChangeRange":{"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[62,62]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[22,22],[23,23],[24,24]]},"microChanges":[{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":31,"endLine":31}],"rightSideLocations":[]}],"refactorings":[{"type":"\"Extract Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":31,"endLine":31},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":31,"endLine":31},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":31,"endLine":31}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"d08470c339d317693d86b3efc356e16b1f16ad97","url":"https://github.com/bennidi/mbassador/commit/d08470c339d317693d86b3efc356e16b1f16ad97","preChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/Mode.java":"package net.engio.mbassy.listener;\n\n/**\n* Created with IntelliJ IDEA.\n* @author bennidi\n* Date: 11/16/12\n* Time: 10:01 AM\n* To change this template use File | Settings | File Templates.\n*/\npublic enum Mode {\n    Synchronous,Asynchronous\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.events.TestEvent2;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Filter;\nimport net.engio.mbassy.listener.Filters;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Listener(dispatch = Mode.Synchronous)\n    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestEvent event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n            TestEvent2 event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n    }\n\n    @Listener(dispatch = Mode.Synchronous, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestEvent event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n            TestEvent2 event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.listener.*;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Listener\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, dispatch = Mode.Asynchronous)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Listener(\n            priority = 10,\n            dispatch = Mode.Synchronous,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<EventListener1> listener = reader.getMessageListener(EventListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<EventListener2> listener = reader.getMessageListener(EventListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<EventListener3> listener = reader.getMessageListener(EventListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Listener(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Listener\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Listener\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {}\n\n    public class EventListener3 extends EventListener2 {\n\n        // narrow the handler\n        @Listener(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        // remove this handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Listener(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Listener\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Listener\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Listener(dispatch = Mode.Synchronous)\n    public void handleSubTestEvent(SubTestEvent event) {\n        super.handleSubTestEvent(event);\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include overridden handlers)\n        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        List<MessageHandlerMetadata>  handlers = new LinkedList<MessageHandlerMetadata>();\n        for(Method handler : allMethods){\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            if(overriddenHandler == null && isValidMessageHandler(handler)){\n                // add the handler only if it has not been overridden because\n                // either the override in the subclass deactivates the handler (by not specifying the @Listener)\n                // or the handler defined in the subclass is part of the list and will be processed itself\n                handlers.add(getHandlerMetadata(handler));\n            }\n        }\n        return handlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !listenerConfig.rejectSubtypes();\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType){\n        for(Class<?> handledMessage : handledMessages){\n            if(handledMessage.equals(messageType))return true;\n            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes(){\n        return acceptsSubtypes;\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n        Class current = subclass;\n        while(!current.equals(overridingMethod.getDeclaringClass())){\n            try {\n                Method overridden = current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n                return overridden;\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) filtered.add(method);\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) return true;\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subbclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        if(subClassMethodParameters.length != subClassMethodParameters.length){\n            return false;\n        }\n        //the parameters must occur in the exact same order\n        for(int i = 0 ; i< subClassMethodParameters.length; i++){\n           if(!superClassMethodParameters[i].equals(subClassMethodParameters[i])){\n               return false;\n           }\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/NonListeningBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should not be considered a message listener\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Listener.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any object as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Listener {\n\n\n\tFilter[] filters() default {}; // no filters by default\n\n    Mode dispatch() default Mode.Synchronous;\n\n    int priority() default 0;\n\n    boolean rejectSubtypes() default false;\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, dispatch = Mode.Synchronous)\n    public void handleSubTestEventAgain(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/Mode.java":"package net.engio.mbassy.listener;\n\n/**\n* Created with IntelliJ IDEA.\n* @author bennidi\n* Date: 11/16/12\n* Time: 10:01 AM\n* To change this template use File | Settings | File Templates.\n*/\npublic enum Mode {\n    Sequential, Concurrent\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.events.TestEvent2;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Filter;\nimport net.engio.mbassy.listener.Filters;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Listener(delivery = Mode.Sequential)\n    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestEvent event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n            TestEvent2 event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n    }\n\n    @Listener(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestEvent.class, TestEvent2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestEvent.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestEvent event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestEvent2.class)){\n            TestEvent2 event = envelope.getMessage();\n            event.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.listener.*;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Listener\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, delivery = Mode.Concurrent)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Listener(\n            priority = 10,\n            delivery = Mode.Sequential,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport org.junit.Test;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.MessageListenerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListenerMetadata.ForMessage;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends UnitTest {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListenerMetadata<EventListener1> listener = reader.getMessageListener(EventListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListenerMetadata<EventListener2> listener = reader.getMessageListener(EventListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListenerMetadata<EventListener3> listener = reader.getMessageListener(EventListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListenerMetadata<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListenerMetadata<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListenerMetadata listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Listener(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Listener\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Listener\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EventListener3 extends EventListener2 {\n\n        // narrow the handler\n        @Listener(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Listener(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Listener(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Listener\n        @Enveloped(messages = {Number.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Listener\n        @Enveloped(messages = {Integer.class})\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Listener(delivery = Mode.Sequential)\n    public void handleSubTestEvent(SubTestEvent event) {\n        super.handleSubTestEvent(event);\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include all (inherited) methods directly annotated using @Listener)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for(Method handler : allHandlers){\n            if(!ReflectionUtils.containsOverridingMethod(allHandlers, handler)){\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n\n        List<MessageHandlerMetadata>  filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Listener annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for(Method handler : bottomMostHandlers){\n            Listener listener = handler.getAnnotation(Listener.class);\n            if(!listener.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(listener), listener);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if(handler == null || handler.getAnnotation(Listener.class) == null){\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !listenerConfig.rejectSubtypes();\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType){\n        for(Class<?> handledMessage : handledMessages){\n            if(handledMessage.equals(messageType))return true;\n            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes(){\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return listenerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n        Class current = subclass;\n        while(!current.equals(overridingMethod.getDeclaringClass())){\n            try {\n                Method overridden = current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n                return overridden;\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) filtered.add(method);\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) return true;\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        if(subClassMethodParameters.length != subClassMethodParameters.length){\n            return false;\n        }\n        //the parameters must occur in the exact same order\n        for(int i = 0 ; i< subClassMethodParameters.length; i++){\n           if(!superClassMethodParameters[i].equals(subClassMethodParameters[i])){\n               return false;\n           }\n        }\n        return true;\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/NonListeningBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.events.TestEvent;\nimport net.engio.mbassy.listener.Listener;\n\n/**\n * This bean overrides all the handlers defined in its superclass. Since it does not specify any annotations\n * it should not be considered a message listener\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class NonListeningBean extends EventingTestBean{\n\n\n    @Override\n    @Listener(enabled = false)\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Listener(enabled = false)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n\n    @Override\n    @Listener(enabled = false)\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();   // should never be called\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Listener.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any object as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Listener {\n\n\n\tFilter[] filters() default {}; // no filters by default\n\n    Mode delivery() default Mode.Sequential;\n\n    int priority() default 0;\n\n    boolean rejectSubtypes() default false;\n\n    boolean enabled() default true;\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestEvent;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, delivery = Mode.Sequential)\n    public void handleSubTestEventAgain(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":[[21,21],[34,34]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":[[32,32],[23,23]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":[[14,14]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[63,63],[64,64],[65,65],[67,72],[74,74]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[34,34]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":[[15,15]]},"postChangeRange":{"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":[[21,21],[34,34]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":[[23,23],[32,32]],"src/test/java/net/engio/mbassy/MetadataReaderTest.java":[[151,151]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":[[14,14]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[97,99],[63,63],[65,65],[66,70],[73,73],[76,76],[77,77],[78,78],[81,82],[83,83],[86,86]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[34,34]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[32,40]],"src/test/java/net/engio/mbassy/listeners/NonListeningBean.java":[[24,24],[18,18],[30,30]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":[[15,15]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":67,"endLine":67}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}]},{"type":"AddAdditionalCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}]},{"type":"SimplifyConditional","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":67,"endLine":67}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":67,"endLine":67}],"rightSideLocations":[]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":97,"endLine":97}]}],"refactorings":[{"type":"\"Extract Variable\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":67,"endLine":67}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":67,"endLine":67}]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":67,"endLine":67}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":67,"endLine":67}]}]},{"repository":"mbassador","sha1":"1ab19f84c9946a898115d96e222b56f2ae1d8192","url":"https://github.com/bennidi/mbassador/commit/1ab19f84c9946a898115d96e222b56f2ae1d8192","preChangeSourceCode":{"src/test/java/net/engio/mbassy/ConditionalHandlers.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/*****************************************************************************\n * Some unit tests for the \"condition\" filter.\n ****************************************************************************/\n\npublic class ConditionalHandlers extends MessageBusTest {\n\n\tpublic static class TestEvent {\n\n\t\tprivate Set<String> handledBy = new HashSet<String>();\n\t\tprivate String type;\n\t\tprivate int size;\n\n\t\tpublic TestEvent(String type, int size) {\n\t\t\tsuper();\n\t\t\tthis.type = type;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String getType() {\n\t\t\treturn type;\n\t\t}\n\n\t\tpublic int getSize() {\n\t\t\treturn size;\n\t\t}\n\n        public boolean wasHandledBy(String ...handlers){\n            for(String handler : handlers){\n                if (!handledBy.contains(handler)) return false;\n            }\n            return true;\n        }\n\n        public void handledBy(String handler){\n            handledBy.add(handler);\n        }\n\t\t\n\t}\n\n    @Listener(references = References.Strong)\n\tpublic static class ConditionalMessageListener {\n\n\t\t@Handler(condition = \"msg.type == 'TEST'\")\n\t\tpublic void handleTypeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleTypeMessage\");\n\t\t}\n\n\t\t@Handler(condition = \"msg.size > 4\")\n\t\tpublic void handleSizeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleSizeMessage\");\n\t\t}\n\n        @Handler(condition = \"msg.foo > 4\")\n        public void handleInvalidEL(TestEvent message) {\n            message.handledBy(\"handleInvalidEL\");\n        }\n\t\t\n\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\n\t\tpublic void handleCombinedEL(TestEvent message) {\n\t\t\tmessage.handledBy( \"handleCombinedEL\");\n\t\t}\n\t\t\n\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n\t\tpublic void handleMethodAccessEL(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\n\t\t}\n\n        @Handler(condition = \"msg.type == 'TEST'\")\n        @Enveloped(messages = {TestEvent.class, Object.class})\n        public void handleEnvelopedMessage(MessageEnvelope envelope) {\n            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\n        }\n\t\t\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleStringCondition() throws Exception {\n\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"TEST\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleNumberCondition() throws Exception {\n\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 5);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleCombinedEL() throws Exception {\n\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 3);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testNotMatchingAnyCondition() throws Exception {\n\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.handledBy.isEmpty());\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleMethodAccessEL() throws Exception {\n\t\tMBassador bus = getBus(BusConfiguration.SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 10000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = BusConfiguration.SyncAsync();\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = getBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        MessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = BusConfiguration.SyncAsync();\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = getBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            bus.post(new Object()).asynchronously();\n        }\n\n        // TODO: wait for publication to finish\n        pause(10000);\n\n        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            error.getCause().printStackTrace();\n            Assert.fail();\n        }\n    };\n\n\n    private StrongConcurrentSet<MessagePublication> issuedPublications = new StrongConcurrentSet<MessagePublication>();\n\n    @Before\n    public void setUp(){\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public MBassador getBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n    public MBassador getBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(MessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(MessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousPublication(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MethodDispatchTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Very simple test to verify dispatch to correct message handler\n *\n * @author bennidi\n *         Date: 1/17/13\n */\npublic class MethodDispatchTest extends MessageBusTest{\n\n   private boolean listener1Called = false;\n   private boolean listener2Called = false;\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Handler\n        public void handleString(String s) {\n             listener1Called = true;\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n           listener2Called = true;\n        }\n\n    }\n\n    @Test\n    public void testDispatch1(){\n        IMessageBus bus = getBus(BusConfiguration.SyncAsync());\n        EventListener2 listener2 = new EventListener2();\n        bus.subscribe(listener2);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener2Called);\n        assertFalse(listener1Called);\n\n        EventListener1 listener1 = new EventListener1();\n        bus.subscribe(listener1);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener1Called);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MBassadorTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = getBus(BusConfiguration.SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final MBassador bus = new MBassador(BusConfiguration.SyncAsync());\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).asynchronously();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusFactory;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.ISyncMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract ISyncMessageBus getSyncMessageBus();\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final ISyncMessageBus bus = getSyncMessageBus();\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final ISyncMessageBus bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                bus.post(new IncrementingMessage()).now();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return new MBassador(BusConfiguration.SyncAsync());\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected ISyncMessageBus getSyncMessageBus() {\n            return BusFactory.SynchronousOnly();\n        }\n    }\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else Assert.fail(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * This interface is meant to be implemented by different bus implementations to offer a consistent way\n * to plugin different flavors of message publication.\n *\n * The parametrization of the IPostCommand influences which publication flavours are available.\n *\n */\npublic interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> {\n\n    /**\n     * Publish a message to the bus using on of its supported message publication mechanisms. The supported\n     * mechanisms depend on the available implementation and are exposed as subclasses of IPublicationCommand.\n     * The standard mechanism is the synchronous dispatch which will publish the message in the current thread\n     * and returns after every matching handler has been invoked. @See IPublicationCommand.\n     *\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandler messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        try{\n            readWriteLock.readLock().lock();\n\n            if (subscriptionsPerMessage.get(messageType) != null) {\n\t            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n            }\n            for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (Subscription sub : subs) {\n                        if (sub.handlesMessageType(messageType)) {\n                            subscriptions.add(sub);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n\n    // associate a subscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/BusFactory.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.common.ISyncMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\n\n/**\n * The bus factory provides convenient factory methods for the most common bus use cases.\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class BusFactory {\n\n    /**\n     * Create a message bus supporting only synchronous message publication.\n     * All message publications will run in the calling thread, no bus internal\n     * multi-threading will occur.\n     *\n     * @return\n     */\n    public static ISyncMessageBus SynchronousOnly(){\n        BusConfiguration syncPubSubCfg = new BusConfiguration();\n        syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n        return new SyncMessageBus(syncPubSubCfg);\n    }\n\n    /**\n     * Create a message bus supporting synchronous and asynchronous message publication.\n     * Asynchronous message publication will be handled by a single thread such that FIFO\n     * order of message processing is guaranteed.\n     *\n     *\n     * @return\n     */\n    public static IMessageBus AsynchronousSequentialFIFO(){\n        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n        return new MBassador(asyncFIFOConfig);\n    }\n}\n","src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport org.junit.Test;\n\nimport java.lang.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Tests a custom handler annotation with a @Handler meta annotation and a default filter.\n */\npublic class CustomHandlerAnnotationTest extends MessageBusTest\n{\n\t/**\n\t * Handler annotation that adds a default filter on the NamedMessage.\n\t * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Synchronized\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\tstatic @interface NamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n\t/**\n\t * Test enveloped meta annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Enveloped(messages = NamedMessage.class)\n\tstatic @interface EnvelopedNamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n\t/**\n\t * Searches for a NamedMessageHandler annotation on the handler method.\n\t * The annotation specifies the supported message names.\n\t */\n\tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n\t{\n\t\t@Override\n\t\tpublic boolean accepts( NamedMessage message, MessageHandler metadata ) {\n\t\t\tNamedMessageHandler namedMessageHandler =\n\t\t\t\t\tReflectionUtils.getAnnotation( metadata.getHandler(), NamedMessageHandler.class );\n\n\t\t\tif ( namedMessageHandler != null ) {\n\t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n\t\t\t}\n\n\t\t\tEnvelopedNamedMessageHandler envelopedHandler =\n\t\t\t\t\tReflectionUtils.getAnnotation( metadata.getHandler(), EnvelopedNamedMessageHandler.class );\n\n\t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n\n\t\t}\n\t}\n\n\tstatic class NamedMessage\n\t{\n\t\tprivate String name;\n\n\t\tNamedMessage( String name ) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tstatic class NamedMessageListener\n\t{\n\t\tfinal Set<NamedMessage> handledByOne = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByTwo = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByThree = new HashSet<NamedMessage>();\n\n\t\t@NamedMessageHandler({ \"messageOne\", \"messageTwo\" })\n\t\tvoid handlerOne( NamedMessage message ) {\n\t\t\thandledByOne.add( message );\n\t\t}\n\n\t\t@EnvelopedNamedMessageHandler({ \"messageTwo\", \"messageThree\" })\n\t\tvoid handlerTwo( MessageEnvelope envelope ) {\n\t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n\t\t}\n\n\t\t@NamedMessageHandler(\"messageThree\")\n\t\tvoid handlerThree( NamedMessage message ) {\n\t\t\thandledByThree.add( message );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMetaHandlerFiltering() {\n\t\tMBassador bus = getBus( BusConfiguration.SyncAsync() );\n\n\t\tNamedMessageListener listener = new NamedMessageListener();\n\t\tbus.subscribe( listener );\n\n\t\tNamedMessage messageOne = new NamedMessage( \"messageOne\" );\n\t\tNamedMessage messageTwo = new NamedMessage( \"messageTwo\" );\n\t\tNamedMessage messageThree = new NamedMessage( \"messageThree\" );\n\n\t\tbus.publish( messageOne );\n\t\tbus.publish( messageTwo );\n\t\tbus.publish( messageThree );\n\n\t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n\t\tassertTrue( listener.handledByOne.contains( messageTwo ) );\n\t\tassertFalse( listener.handledByOne.contains( messageThree ) );\n\n\t\tassertFalse( listener.handledByTwo.contains( messageOne ) );\n\t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n\t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n\n\t\tassertFalse( listener.handledByThree.contains( messageOne ) );\n\t\tassertFalse( listener.handledByThree.contains( messageTwo ) );\n\t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n\t}\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.common.ReflectionUtils;\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\nimport net.engio.mbassy.dispatch.el.ElFilter;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n * defines such a message listener.\r\n *\r\n * @author bennidi\r\n *         Date: 11/14/12\r\n */\r\npublic class MessageHandler {\r\n\r\n    public static final class Properties{\r\n\r\n        public static final String HandlerMethod = \"handler\";\r\n        public static final String InvocationMode = \"invocationMode\";\r\n        public static final String Filter = \"filter\";\r\n        public static final String Condition = \"condition\";\r\n        public static final String Enveloped = \"envelope\";\r\n        public static final String HandledMessages = \"messages\";\r\n        public static final String IsSynchronized = \"synchronized\";\r\n        public static final String Listener = \"listener\";\r\n        public static final String AcceptSubtypes = \"subtypes\";\r\n        public static final String Priority = \"priority\";\r\n        public static final String Invocation = \"invocation\";\r\n\r\n        /**\r\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n         *\r\n         * @param handler  The handler annotated method of the listener\r\n         * @param handlerConfig The annotation that configures the handler\r\n         * @param filter   The set of preconfigured filters if any\r\n         * @param listenerConfig The listener metadata\r\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n         */\r\n        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n            if(handler == null){\r\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n            }\r\n            if(filter == null){\r\n                filter = new IMessageFilter[]{};\r\n            }\r\n            net.engio.mbassy.listener.Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n            Class[] handledMessages = enveloped != null\r\n                    ? enveloped.messages()\r\n                    : handler.getParameterTypes();\r\n            handler.setAccessible(true);\r\n            Map<String, Object> properties = new HashMap<String, Object>();\r\n            properties.put(HandlerMethod, handler);\r\n            // add EL filter if a condition is present\r\n            if(handlerConfig.condition().length() > 0){\r\n                if (!ElFilter.isELAvailable()) {\r\n                    throw new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n                }\r\n\r\n                IMessageFilter[] expandedFilter = new IMessageFilter[filter.length + 1];\r\n                for(int i = 0; i < filter.length ; i++){\r\n                   expandedFilter[i] = filter[i];\r\n                }\r\n                expandedFilter[filter.length] = new ElFilter();\r\n                filter = expandedFilter;\r\n            }\r\n            properties.put(Filter, filter);\r\n            properties.put(Condition, cleanEL(handlerConfig.condition()));\r\n            properties.put(Priority, handlerConfig.priority());\r\n            properties.put(Invocation, handlerConfig.invocation());\r\n            properties.put(InvocationMode, handlerConfig.delivery());\r\n            properties.put(Enveloped, enveloped != null);\r\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n            properties.put(Listener, listenerConfig);\r\n            properties.put(IsSynchronized, ReflectionUtils.getAnnotation( handler, Synchronized.class) != null);\r\n            properties.put(HandledMessages, handledMessages);\r\n            return properties;\r\n        }\r\n\r\n        private static String cleanEL(String expression) {\r\n\r\n            if (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n                expression = \"${\"+expression+\"}\";\r\n            }\r\n            return expression;\r\n        }\r\n    }\r\n\r\n\r\n    private final Method handler;\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n\tprivate String condition;\r\n    \r\n    private final int priority;\r\n\r\n    private final Class<? extends HandlerInvocation> invocation;\r\n\r\n    private final Invoke invocationMode;\r\n\r\n    private final boolean isEnvelope;\r\n\r\n    private final Class[] handledMessages;\r\n\r\n    private final boolean acceptsSubtypes;\r\n\r\n    private final MessageListener listenerConfig;\r\n\r\n    private final boolean isSynchronized;\r\n\r\n\r\n    public MessageHandler(Map<String, Object> properties){\r\n        super();\r\n        validate(properties);\r\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n        this.condition = (String)properties.get(Properties.Condition);\r\n        this.priority = (Integer)properties.get(Properties.Priority);\r\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n    }\r\n\r\n    private void validate(Map<String, Object> properties){\r\n        Object[][] expectedProperties = new Object[][]{\r\n                new Object[]{Properties.HandlerMethod, Method.class },\r\n                new Object[]{Properties.Priority, Integer.class },\r\n                new Object[]{Properties.Invocation, Class.class },\r\n                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n                new Object[]{Properties.Condition, String.class },\r\n                new Object[]{Properties.Enveloped, Boolean.class },\r\n                new Object[]{Properties.HandledMessages, Class[].class },\r\n                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n                new Object[]{Properties.Listener, MessageListener.class },\r\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n        };\r\n        for(Object[] property : expectedProperties){\r\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                        + \" but was: \" + properties.get(property[0]));\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public boolean isSynchronized(){\r\n        return isSynchronized;\r\n    }\r\n\r\n    public boolean useStrongReferences(){\r\n        return listenerConfig.useStrongReferences();\r\n    }\r\n\r\n    public boolean isFromListener(Class listener){\r\n        return listenerConfig.isFromListener(listener);\r\n    }\r\n\r\n    public boolean isAsynchronous() {\r\n        return invocationMode.equals(Invoke.Asynchronously);\r\n    }\r\n\r\n    public boolean isFiltered() {\r\n        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n    }\r\n\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    public Method getHandler() {\r\n        return handler;\r\n    }\r\n\r\n    public IMessageFilter[] getFilter() {\r\n        return filter;\r\n    }\r\n    \r\n    public String getCondition() {\r\n    \treturn this.condition;\r\n    }\r\n\r\n    public Class[] getHandledMessages() {\r\n        return handledMessages;\r\n    }\r\n\r\n    public boolean isEnveloped() {\r\n        return isEnvelope;\r\n    }\r\n\r\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n        return invocation;\r\n    }\r\n\r\n    public boolean handlesMessage(Class<?> messageType) {\r\n        for (Class<?> handledMessage : handledMessages) {\r\n            if (handledMessage.equals(messageType)) {\r\n                return true;\r\n            }\r\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean acceptsSubtypes() {\r\n        return acceptsSubtypes;\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/bus/common/IMessageBus.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.concurrent.Executor;\n\n/**\n * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n * A message publication starts when an object is send to the bus using one of the its publication methods.\n *\n * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n *\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n * in a synchronized fashion using @Synchronized annotation\n *\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n *\n * <p/>\n * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n *\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the respective message handlers.\n *\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n *\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n *\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, P>, ISyncMessageBus<T,P> {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    P post(T message);\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * Note: The executor can be obtained from the run time. See\n     * @return\n     */\n    @Deprecated\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return true if any unfinished message publications are found\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n\n}\n","src/test/java/net/engio/mbassy/DeadMessageTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.listeners.ObjectListener;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadMessageTest extends MessageBusTest{\n\n    @Before\n    public void beforeTest(){\n        DeadMessagHandler.deadMessages.set(0);\n    }\n\n\n    @Test\n    public void testDeadMessage(){\n        final MBassador bus = getBus(BusConfiguration.SyncAsync());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, DeadMessagHandler.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishUnhandledMessage = new Runnable() {\n            @Override\n            public void run() {\n                for(int i=0; i < IterationsPerThread; i++){\n                    int variation = i % 3;\n                    switch (variation){\n                        case 0:bus.publish(new Object());break;\n                        case 1:bus.publish(i);break;\n                        case 2:bus.publish(String.valueOf(i));break;\n                    }\n                }\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishUnhandledMessage, ConcurrentUnits);\n\n        assertEquals(InstancesPerListener * IterationsPerThread * ConcurrentUnits, DeadMessagHandler.deadMessages.get());\n    }\n\n\n\n    @Test\n    public void testUnsubscribingAllListeners() {\n        final MBassador bus = getBus(BusConfiguration.SyncAsync());\n        ListenerFactory deadMessageListener = new ListenerFactory()\n                .create(InstancesPerListener, DeadMessagHandler.class)\n                .create(InstancesPerListener, Object.class);\n        ListenerFactory objectListener = new ListenerFactory()\n                .create(InstancesPerListener, ObjectListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, deadMessageListener), ConcurrentUnits);\n\n        // Only dead message handlers available\n        bus.post(new Object()).now();\n\n        // The message should be caught as dead message since there are no subscribed listeners\n        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n\n        // Clear deadmessage for future tests\n        DeadMessagHandler.deadMessages.set(0);\n\n        // Add object listeners and publish again\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, objectListener), ConcurrentUnits);\n        bus.post(new Object()).now();\n\n        // verify that no dead message events were produced\n        assertEquals(0, DeadMessagHandler.deadMessages.get());\n\n        // Unsubscribe all object listeners\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(bus, objectListener), ConcurrentUnits);\n\n        // Only dead message handlers available\n        bus.post(new Object()).now();\n\n        // The message should be caught, as it's the only listener\n        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n    }\n\n    public static class DeadMessagHandler {\n\n        private static final AtomicInteger deadMessages = new AtomicInteger(0);\n\n        @Handler\n        public void handle(DeadMessage message){\n            deadMessages.incrementAndGet();\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.FilteredMessage;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(BusConfiguration.SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(BusConfiguration.SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n    }\n\n    @Test\n    public void testSubtypesOnly(){\n        MBassador bus = getBus(BusConfiguration.SyncAsync());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(100, TestMessageHandler.class);\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage supertype = new TestMessage();\n        TestMessage subtype = new SubTestMessage();\n\n        bus.publish(supertype);\n        bus.publish(subtype);\n\n        assertEquals(100, subtype.counter.get());\n        assertEquals(0, supertype.counter.get());\n\n    }\n\n    public static class TestMessageHandler{\n\n        @Handler(filters = @Filter(Filters.SubtypesOnly.class))\n        public void handle(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandler metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandler metadata) {\n            return false;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n\t\tList<Method> methods = new LinkedList<Method>();\n\t\ttry {\n\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n\t\t\t\tif ( condition.apply( method ) ) {\n\t\t\t\t\tmethods.add( method );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t//nop\n\t\t}\n\t\tif ( !target.equals( Object.class ) ) {\n\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/**\n\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n\t * for an override of the given methods -> finds the bottom most override of the given\n\t * method if any exists\n\t *\n\t * @param overridingMethod\n\t * @param subclass\n\t * @return\n\t */\n\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n\t\tClass current = subclass;\n\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n\t\t\ttry {\n\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\tcurrent = current.getSuperclass();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Set<Class> getSuperclasses( Class from ) {\n\t\tSet<Class> superclasses = new HashSet<Class>();\n\t\tcollectInterfaces( from, superclasses );\n\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n\t\t\tsuperclasses.add( from.getSuperclass() );\n\t\t\tfrom = from.getSuperclass();\n\t\t\tcollectInterfaces( from, superclasses );\n\t\t}\n\t\treturn superclasses;\n\t}\n\n\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n\t\tfor ( Class intface : from.getInterfaces() ) {\n\t\t\taccumulator.add( intface );\n\t\t\tcollectInterfaces( intface, accumulator );\n\t\t}\n\t}\n\n\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n\t\tfor ( Method method : allMethods ) {\n\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static <A extends Annotation> A getAnnotation( Method method, Class<A> annotationType ) {\n\t\treturn getAnnotation( (AnnotatedElement) method, annotationType );\n\t}\n\n\tpublic static <A extends Annotation> A getAnnotation( Class from, Class<A> annotationType ) {\n\t\treturn getAnnotation( (AnnotatedElement) from, annotationType );\n\t}\n\n\t/**\n\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n\t *\n\t * @param from AnnotatedElement (class, method...)\n\t * @param annotationType Annotation class to look for.\n\t * @param <A> Annotation class\n\t * @return Annotation instance or null\n\t */\n\tpublic static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType ) {\n\t\tA ann = from.getAnnotation( annotationType );\n\t\tif ( ann == null ) {\n\t\t\tfor ( Annotation metaAnn : from.getAnnotations() ) {\n\t\t\t\tann = metaAnn.annotationType().getAnnotation( annotationType );\n\t\t\t\tif ( ann != null ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ann;\n\t}\n\n\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n\t\t// hierarchy of the given superclass method or the method names are not the same then\n\t\t// subclassMethod does not override superclassMethod\n\t\tif ( superclassMethod.getDeclaringClass().equals(\n\t\t\t\tsubclassMethod.getDeclaringClass() ) || !superclassMethod.getDeclaringClass().isAssignableFrom(\n\t\t\t\tsubclassMethod.getDeclaringClass() ) || !superclassMethod.getName().equals(\n\t\t\t\tsubclassMethod.getName() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n\t\t// method must specify the same number of parameters\n\t\t//the parameters must occur in the exact same order\n\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.ISyncMessageBus;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * A message bus implementation that offers only synchronous message publication. Using this bus\n * will not create any new threads.\n *\n */\npublic class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements ISyncMessageBus<T, SyncMessageBus.SyncPostCommand> {\n\n\n    public SyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    @Override\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements IPublicationCommand {\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    /**\n     * Creates a new instance, using the default settings of 2 dispatchers, and\n     * asynchronous handlers with an initial count equal to the number of\n     * available processors in the machine, with maximum count equal to\n     * 2 * the number of available processors. Uses {@link Runtime#availableProcessors()} to\n     * determine the number of available processors\n     *\n     * @deprecated Use feature driven configuration instead\n     **/\n    @Deprecated()\n    public static BusConfiguration SyncAsync() {\n        BusConfiguration defaultConfig = new BusConfiguration();\n        defaultConfig.addFeature(Feature.SyncPubSub.Default());\n        defaultConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default());\n        defaultConfig.addFeature(Feature.AsynchronousMessageDispatch.Default());\n        return defaultConfig;\n    }\n\n    // the registered features\n    private Map<Class<? extends Feature>, Feature> features = new HashMap<Class<? extends Feature>, Feature>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T)features.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        features.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler) {\n        return null;  //To change body of implemented methods use File | Settings | File Templates.\n    }\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/ConditionalHandlers.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/*****************************************************************************\n * Some unit tests for the \"condition\" filter.\n ****************************************************************************/\n\npublic class ConditionalHandlers extends MessageBusTest {\n\n\tpublic static class TestEvent {\n\n\t\tprivate Set<String> handledBy = new HashSet<String>();\n\t\tprivate String type;\n\t\tprivate int size;\n\n\t\tpublic TestEvent(String type, int size) {\n\t\t\tsuper();\n\t\t\tthis.type = type;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String getType() {\n\t\t\treturn type;\n\t\t}\n\n\t\tpublic int getSize() {\n\t\t\treturn size;\n\t\t}\n\n        public boolean wasHandledBy(String ...handlers){\n            for(String handler : handlers){\n                if (!handledBy.contains(handler)) return false;\n            }\n            return true;\n        }\n\n        public void handledBy(String handler){\n            handledBy.add(handler);\n        }\n\t\t\n\t}\n\n    @Listener(references = References.Strong)\n\tpublic static class ConditionalMessageListener {\n\n\t\t@Handler(condition = \"msg.type == 'TEST'\")\n\t\tpublic void handleTypeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleTypeMessage\");\n\t\t}\n\n\t\t@Handler(condition = \"msg.size > 4\")\n\t\tpublic void handleSizeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleSizeMessage\");\n\t\t}\n\n        @Handler(condition = \"msg.foo > 4\")\n        public void handleInvalidEL(TestEvent message) {\n            message.handledBy(\"handleInvalidEL\");\n        }\n\t\t\n\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\n\t\tpublic void handleCombinedEL(TestEvent message) {\n\t\t\tmessage.handledBy( \"handleCombinedEL\");\n\t\t}\n\t\t\n\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n\t\tpublic void handleMethodAccessEL(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\n\t\t}\n\n        @Handler(condition = \"msg.type == 'TEST'\")\n        @Enveloped(messages = {TestEvent.class, Object.class})\n        public void handleEnvelopedMessage(MessageEnvelope envelope) {\n            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\n        }\n\t\t\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleStringCondition() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"TEST\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleNumberCondition() throws Exception {\n\t\tMBassador bus = new MBassador();\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 5);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleCombinedEL() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 3);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testNotMatchingAnyCondition() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.handledBy.isEmpty());\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleMethodAccessEL() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 10000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = SyncAsync();\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        MessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = SyncAsync();\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            track(bus.post(new Object()).asynchronously());\n        }\n\n        pause(10000);\n\n        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            error.getCause().printStackTrace();\n            Assert.fail();\n        }\n    };\n\n\n    private StrongConcurrentSet<MessagePublication> issuedPublications = new StrongConcurrentSet<MessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<MessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(MessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(MessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(MessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    public MBassador(){\n        super(new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousPublication(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MethodDispatchTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Very simple test to verify dispatch to correct message handler\n *\n * @author bennidi\n *         Date: 1/17/13\n */\npublic class MethodDispatchTest extends MessageBusTest{\n\n   private boolean listener1Called = false;\n   private boolean listener2Called = false;\n\n\n\n    // a simple event listener\n    public class EventListener1 {\n\n        @Handler\n        public void handleString(String s) {\n             listener1Called = true;\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class EventListener2 extends EventListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n           listener2Called = true;\n        }\n\n    }\n\n    @Test\n    public void testDispatch1(){\n        IMessageBus bus = createBus(SyncAsync());\n        EventListener2 listener2 = new EventListener2();\n        bus.subscribe(listener2);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener2Called);\n        assertFalse(listener1Called);\n\n        EventListener1 listener1 = new EventListener1();\n        bus.subscribe(listener1);\n        bus.post(\"jfndf\").now();\n        assertTrue(listener1Called);\n    }\n\n}\n","src/test/java/net/engio/mbassy/MBassadorTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final MBassador bus = new MBassador(SyncAsync());\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).asynchronously();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusFactory;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus();\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                bus.post(new IncrementingMessage()).now();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus() {\n            return new MBassador();\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus() {\n            return BusFactory.SynchronousOnly();\n        }\n    }\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else Assert.fail(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * This interface is meant to be implemented by different bus implementations to offer a consistent way\n * to plugin different flavors of message publication.\n *\n * The parametrization of the IPostCommand influences which publication flavours are available.\n *\n */\npublic interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport{\n\n    /**\n     * Publish a message to the bus using on of its supported message publication mechanisms. The supported\n     * mechanisms depend on the available implementation and are exposed as subclasses of IPublicationCommand.\n     * The standard mechanism is the synchronous dispatch which will publish the message in the current thread\n     * and returns after every matching handler has been invoked. @See IPublicationCommand.\n     *\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener\n            = new HashMap<Class, Collection<Subscription>>(50);\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandler messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        try{\n            readWriteLock.readLock().lock();\n\n            if (subscriptionsPerMessage.get(messageType) != null) {\n\t            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n            }\n            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (Subscription sub : subs) {\n                        if (sub.handlesMessageType(messageType)) {\n                            subscriptions.add(sub);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n\n    // associate a subscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/BusFactory.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\n\n/**\n * The bus factory provides convenient factory methods for the most common bus use cases.\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class BusFactory {\n\n    /**\n     * Create a message bus supporting only synchronous message publication.\n     * All message publications will run in the calling thread, no bus internal\n     * multi-threading will occur.\n     *\n     * @return\n     */\n    public static SyncMessageBus SynchronousOnly(){\n        BusConfiguration syncPubSubCfg = new BusConfiguration();\n        syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n        return new SyncMessageBus(syncPubSubCfg);\n    }\n\n    /**\n     * Create a message bus supporting synchronous and asynchronous message publication.\n     * Asynchronous message publication will be handled by a single thread such that FIFO\n     * order of message processing is guaranteed.\n     *\n     *\n     * @return\n     */\n    public static IMessageBus AsynchronousSequentialFIFO(){\n        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n        return new MBassador(asyncFIFOConfig);\n    }\n}\n","src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport org.junit.Test;\n\nimport java.lang.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Tests a custom handler annotation with a @Handler meta annotation and a default filter.\n */\npublic class CustomHandlerAnnotationTest extends MessageBusTest\n{\n\t/**\n\t * Handler annotation that adds a default filter on the NamedMessage.\n\t * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Synchronized\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\tstatic @interface NamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n    /**\n     * Handler annotation that adds a default filter on the NamedMessage.\n     * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n     */\n    @Retention(value = RetentionPolicy.RUNTIME)\n    @Inherited\n    @NamedMessageHandler(\"messageThree\")\n    static @interface MessageThree {}\n\n\n\n\t/**\n\t * Test enveloped meta annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Enveloped(messages = NamedMessage.class)\n\tstatic @interface EnvelopedNamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n\t/**\n\t * Searches for a NamedMessageHandler annotation on the handler method.\n\t * The annotation specifies the supported message names.\n\t */\n\tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n\t{\n\t\t@Override\n\t\tpublic boolean accepts( NamedMessage message, MessageHandler metadata ) {\n\t\t\tNamedMessageHandler namedMessageHandler = metadata.getAnnotation(NamedMessageHandler.class);\n\t\t\tif ( namedMessageHandler != null ) {\n\t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n\t\t\t}\n\n\t\t\tEnvelopedNamedMessageHandler envelopedHandler = metadata.getAnnotation(EnvelopedNamedMessageHandler.class);\n\t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n\n\t\t}\n\t}\n\n\tstatic class NamedMessage\n\t{\n\t\tprivate String name;\n\n\t\tNamedMessage( String name ) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tstatic class NamedMessageListener\n\t{\n\t\tfinal Set<NamedMessage> handledByOne = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByTwo = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByThree = new HashSet<NamedMessage>();\n\n\t\t@NamedMessageHandler({ \"messageOne\", \"messageTwo\" })\n\t\tvoid handlerOne( NamedMessage message ) {\n\t\t\thandledByOne.add( message );\n\t\t}\n\n\t\t@EnvelopedNamedMessageHandler({ \"messageTwo\", \"messageThree\" })\n\t\tvoid handlerTwo( MessageEnvelope envelope ) {\n\t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n\t\t}\n\n\t\t@MessageThree\n\t\tvoid handlerThree( NamedMessage message ) {\n\t\t\thandledByThree.add( message );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMetaHandlerFiltering() {\n\t\tMBassador bus = createBus(SyncAsync());\n\n\t\tNamedMessageListener listener = new NamedMessageListener();\n\t\tbus.subscribe( listener );\n\n\t\tNamedMessage messageOne = new NamedMessage( \"messageOne\" );\n\t\tNamedMessage messageTwo = new NamedMessage( \"messageTwo\" );\n\t\tNamedMessage messageThree = new NamedMessage( \"messageThree\" );\n\n\t\tbus.publish( messageOne );\n\t\tbus.publish( messageTwo );\n\t\tbus.publish( messageThree );\n\n        assertEquals(2, listener.handledByOne.size());\n\t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n\t\tassertTrue(listener.handledByOne.contains(messageTwo));\n\n        assertEquals(2, listener.handledByTwo.size());\n\t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n\t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n\n        assertEquals(1, listener.handledByThree.size());\n\t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n\t}\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.common.ReflectionUtils;\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\nimport net.engio.mbassy.dispatch.el.ElFilter;\r\n\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n * defines such a message listener.\r\n *\r\n * @author bennidi\r\n *         Date: 11/14/12\r\n */\r\npublic class MessageHandler {\r\n\r\n    public static final class Properties{\r\n\r\n        public static final String HandlerMethod = \"handler\";\r\n        public static final String InvocationMode = \"invocationMode\";\r\n        public static final String Filter = \"filter\";\r\n        public static final String Condition = \"condition\";\r\n        public static final String Enveloped = \"envelope\";\r\n        public static final String HandledMessages = \"messages\";\r\n        public static final String IsSynchronized = \"synchronized\";\r\n        public static final String Listener = \"listener\";\r\n        public static final String AcceptSubtypes = \"subtypes\";\r\n        public static final String Priority = \"priority\";\r\n        public static final String Invocation = \"invocation\";\r\n\r\n        /**\r\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n         *\r\n         * @param handler  The handler annotated method of the listener\r\n         * @param handlerConfig The annotation that configures the handler\r\n         * @param filter   The set of preconfigured filters if any\r\n         * @param listenerConfig The listener metadata\r\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n         */\r\n        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n            if(handler == null){\r\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n            }\r\n            if(filter == null){\r\n                filter = new IMessageFilter[]{};\r\n            }\r\n            Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n            Class[] handledMessages = enveloped != null\r\n                    ? enveloped.messages()\r\n                    : handler.getParameterTypes();\r\n            handler.setAccessible(true);\r\n            Map<String, Object> properties = new HashMap<String, Object>();\r\n            properties.put(HandlerMethod, handler);\r\n            // add EL filter if a condition is present\r\n            if(handlerConfig.condition().length() > 0){\r\n                if (!ElFilter.isELAvailable()) {\r\n                    throw new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n                }\r\n\r\n                IMessageFilter[] expandedFilter = new IMessageFilter[filter.length + 1];\r\n                for(int i = 0; i < filter.length ; i++){\r\n                   expandedFilter[i] = filter[i];\r\n                }\r\n                expandedFilter[filter.length] = new ElFilter();\r\n                filter = expandedFilter;\r\n            }\r\n            properties.put(Filter, filter);\r\n            properties.put(Condition, cleanEL(handlerConfig.condition()));\r\n            properties.put(Priority, handlerConfig.priority());\r\n            properties.put(Invocation, handlerConfig.invocation());\r\n            properties.put(InvocationMode, handlerConfig.delivery());\r\n            properties.put(Enveloped, enveloped != null);\r\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n            properties.put(Listener, listenerConfig);\r\n            properties.put(IsSynchronized, ReflectionUtils.getAnnotation( handler, Synchronized.class) != null);\r\n            properties.put(HandledMessages, handledMessages);\r\n            return properties;\r\n        }\r\n\r\n        private static String cleanEL(String expression) {\r\n\r\n            if (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n                expression = \"${\"+expression+\"}\";\r\n            }\r\n            return expression;\r\n        }\r\n    }\r\n\r\n\r\n    private final Method handler;\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n\tprivate final String condition;\r\n    \r\n    private final int priority;\r\n\r\n    private final Class<? extends HandlerInvocation> invocation;\r\n\r\n    private final Invoke invocationMode;\r\n\r\n    private final boolean isEnvelope;\r\n\r\n    private final Class[] handledMessages;\r\n\r\n    private final boolean acceptsSubtypes;\r\n\r\n    private final MessageListener listenerConfig;\r\n\r\n    private final boolean isSynchronized;\r\n\r\n\r\n    public MessageHandler(Map<String, Object> properties){\r\n        super();\r\n        validate(properties);\r\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n        this.condition = (String)properties.get(Properties.Condition);\r\n        this.priority = (Integer)properties.get(Properties.Priority);\r\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n    }\r\n\r\n    private void validate(Map<String, Object> properties){\r\n        Object[][] expectedProperties = new Object[][]{\r\n                new Object[]{Properties.HandlerMethod, Method.class },\r\n                new Object[]{Properties.Priority, Integer.class },\r\n                new Object[]{Properties.Invocation, Class.class },\r\n                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n                new Object[]{Properties.Condition, String.class },\r\n                new Object[]{Properties.Enveloped, Boolean.class },\r\n                new Object[]{Properties.HandledMessages, Class[].class },\r\n                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n                new Object[]{Properties.Listener, MessageListener.class },\r\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n        };\r\n        for(Object[] property : expectedProperties){\r\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                        + \" but was: \" + properties.get(property[0]));\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public <A extends Annotation> A getAnnotation(Class<A> annotationType){\r\n        return ReflectionUtils.getAnnotation(handler,annotationType);\r\n    }\r\n\r\n    public boolean isSynchronized(){\r\n        return isSynchronized;\r\n    }\r\n\r\n    public boolean useStrongReferences(){\r\n        return listenerConfig.useStrongReferences();\r\n    }\r\n\r\n    public boolean isFromListener(Class listener){\r\n        return listenerConfig.isFromListener(listener);\r\n    }\r\n\r\n    public boolean isAsynchronous() {\r\n        return invocationMode.equals(Invoke.Asynchronously);\r\n    }\r\n\r\n    public boolean isFiltered() {\r\n        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n    }\r\n\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    public Method getHandler() {\r\n        return handler;\r\n    }\r\n\r\n    public IMessageFilter[] getFilter() {\r\n        return filter;\r\n    }\r\n    \r\n    public String getCondition() {\r\n    \treturn this.condition;\r\n    }\r\n\r\n    public Class[] getHandledMessages() {\r\n        return handledMessages;\r\n    }\r\n\r\n    public boolean isEnveloped() {\r\n        return isEnvelope;\r\n    }\r\n\r\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n        return invocation;\r\n    }\r\n\r\n    public boolean handlesMessage(Class<?> messageType) {\r\n        for (Class<?> handledMessage : handledMessages) {\r\n            if (handledMessage.equals(messageType)) {\r\n                return true;\r\n            }\r\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean acceptsSubtypes() {\r\n        return acceptsSubtypes;\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/bus/common/IMessageBus.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.concurrent.Executor;\n\n/**\n * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n * A message publication starts when an object is send to the bus using one of the its publication methods.\n *\n * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n *\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n * in a synchronized fashion using @Synchronized annotation\n *\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n *\n * <p/>\n * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n *\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the respective message handlers.\n *\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n *\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n *\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends GenericMessagePublicationSupport<T, P>{\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    P post(T message);\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * Note: The executor can be obtained from the run time. See\n     * @return\n     */\n    @Deprecated\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return true if any unfinished message publications are found\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n\n}\n","src/test/java/net/engio/mbassy/DeadMessageTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.listeners.ObjectListener;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadMessageTest extends MessageBusTest{\n\n    @Before\n    public void beforeTest(){\n        DeadMessagHandler.deadMessages.set(0);\n    }\n\n\n    @Test\n    public void testDeadMessage(){\n        final MBassador bus = createBus(SyncAsync());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.AsyncListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.AsyncListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, DeadMessagHandler.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishUnhandledMessage = new Runnable() {\n            @Override\n            public void run() {\n                for(int i=0; i < IterationsPerThread; i++){\n                    int variation = i % 3;\n                    switch (variation){\n                        case 0:bus.publish(new Object());break;\n                        case 1:bus.publish(i);break;\n                        case 2:bus.publish(String.valueOf(i));break;\n                    }\n                }\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishUnhandledMessage, ConcurrentUnits);\n\n        assertEquals(InstancesPerListener * IterationsPerThread * ConcurrentUnits, DeadMessagHandler.deadMessages.get());\n    }\n\n\n\n    @Test\n    public void testUnsubscribingAllListeners() {\n        final MBassador bus = createBus(SyncAsync());\n        ListenerFactory deadMessageListener = new ListenerFactory()\n                .create(InstancesPerListener, DeadMessagHandler.class)\n                .create(InstancesPerListener, Object.class);\n        ListenerFactory objectListener = new ListenerFactory()\n                .create(InstancesPerListener, ObjectListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, deadMessageListener), ConcurrentUnits);\n\n        // Only dead message handlers available\n        bus.post(new Object()).now();\n\n        // The message should be caught as dead message since there are no subscribed listeners\n        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n\n        // Clear deadmessage for future tests\n        DeadMessagHandler.deadMessages.set(0);\n\n        // Add object listeners and publish again\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, objectListener), ConcurrentUnits);\n        bus.post(new Object()).now();\n\n        // verify that no dead message events were produced\n        assertEquals(0, DeadMessagHandler.deadMessages.get());\n\n        // Unsubscribe all object listeners\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(bus, objectListener), ConcurrentUnits);\n\n        // Only dead message handlers available\n        bus.post(new Object()).now();\n\n        // The message should be caught, as it's the only listener\n        assertEquals(InstancesPerListener, DeadMessagHandler.deadMessages.get());\n    }\n\n    public static class DeadMessagHandler {\n\n        private static final AtomicInteger deadMessages = new AtomicInteger(0);\n\n        @Handler\n        public void handle(DeadMessage message){\n            deadMessages.incrementAndGet();\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.FilteredMessage;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n    }\n\n    @Test\n    public void testSubtypesOnly(){\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(100, TestMessageHandler.class);\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage supertype = new TestMessage();\n        TestMessage subtype = new SubTestMessage();\n\n        bus.publish(supertype);\n        bus.publish(subtype);\n\n        assertEquals(100, subtype.counter.get());\n        assertEquals(0, supertype.counter.get());\n\n    }\n\n    public static class TestMessageHandler{\n\n        @Handler(filters = @Filter(Filters.SubtypesOnly.class))\n        public void handle(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandler metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandler metadata) {\n            return false;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n\t\tList<Method> methods = new LinkedList<Method>();\n\t\ttry {\n\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n\t\t\t\tif ( condition.apply( method ) ) {\n\t\t\t\t\tmethods.add( method );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t//nop\n\t\t}\n\t\tif ( !target.equals( Object.class ) ) {\n\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/**\n\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n\t * for an override of the given methods -> finds the bottom most override of the given\n\t * method if any exists\n\t *\n\t * @param overridingMethod\n\t * @param subclass\n\t * @return\n\t */\n\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n\t\tClass current = subclass;\n\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n\t\t\ttry {\n\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\tcurrent = current.getSuperclass();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n\tpublic static Set<Class> getSuperTypes(Class from) {\n\t\tSet<Class> superclasses = new HashSet<Class>();\n\t\tcollectInterfaces( from, superclasses );\n\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n\t\t\tsuperclasses.add( from.getSuperclass() );\n\t\t\tfrom = from.getSuperclass();\n\t\t\tcollectInterfaces( from, superclasses );\n\t\t}\n\t\treturn superclasses;\n\t}\n\n\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n\t\tfor ( Class intface : from.getInterfaces() ) {\n\t\t\taccumulator.add( intface );\n\t\t\tcollectInterfaces( intface, accumulator );\n\t\t}\n\t}\n\n\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n\t\tfor ( Method method : allMethods ) {\n\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\t/**\n\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n\t *\n\t * @param from AnnotatedElement (class, method...)\n\t * @param annotationType Annotation class to look for.\n\t * @param <A> Class of annotation type\n\t * @return Annotation instance or null\n\t */\n\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n\t\tif( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n\t}\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n\t\t// hierarchy of the given superclass method or the method names are not the same then\n\t\t// subclassMethod does not override superclassMethod\n\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n\t\t// method must specify the same number of parameters\n\t\t//the parameters must occur in the exact same order\n\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.ErrorHandlingSupport;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * A message bus implementation that offers only synchronous message publication. Using this bus\n * will not create any new threads.\n *\n */\npublic class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, SyncMessageBus.SyncPostCommand>{\n\n\n    public SyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    @Override\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements IPublicationCommand {\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    // the registered features\n    private Map<Class<? extends Feature>, Feature> features = new HashMap<Class<? extends Feature>, Feature>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T)features.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        features.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler) {\n        return null;  // TODO: implement configuration validation\n    }\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":[[114,114],[129,129],[131,131],[135,135],[136,136],[106,106],[63,63],[70,70]],"src/test/java/net/engio/mbassy/ConditionalHandlers.java":[[157,157],[97,97],[128,128],[143,143],[113,113]],"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":[[33,33],[36,36],[61,61],[64,64],[72,72]],"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[52,52]],"src/test/java/net/engio/mbassy/DeadMessageTest.java":[[73,73],[35,35]],"src/test/java/net/engio/mbassy/FilterTest.java":[[34,34],[59,59],[105,105]],"src/test/java/net/engio/mbassy/MethodDispatchTest.java":[[44,44]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[94,101],[103,103],[104,111],[112,112]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[180,180],[181,181],[35,35],[40,40],[190,190],[117,117],[151,151],[91,91]],"src/test/java/net/engio/mbassy/MBassadorTest.java":[[65,65],[97,97],[135,135],[31,31]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[168,168]],"src/main/java/net/engio/mbassy/bus/BusFactory.java":[[23,23]]},"postChangeRange":{"src/test/java/net/engio/mbassy/ConditionalHandlers.java":[[156,156],[96,96],[127,127],[142,142],[112,112]],"src/test/java/net/engio/mbassy/common/MessageBusTest.java":[[44,44]],"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":[[35,35],[63,63],[71,71]],"src/test/java/net/engio/mbassy/MethodDispatchTest.java":[[44,44]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[179,179],[34,34],[39,39],[189,189],[116,116],[150,150],[90,90]],"src/test/java/net/engio/mbassy/MBassadorTest.java":[[65,65],[97,97],[31,31]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[168,168]],"src/main/java/net/engio/mbassy/bus/BusFactory.java":[[22,22]],"src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":[[119,119],[132,132],[136,136],[140,140],[111,111],[71,71],[76,76]],"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[53,53]],"src/test/java/net/engio/mbassy/DeadMessageTest.java":[[72,72],[34,34]],"src/test/java/net/engio/mbassy/FilterTest.java":[[33,33],[58,58],[104,104]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[118,118]]},"microChanges":[],"refactorings":[{"type":"\"Extract Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":104,"endLine":104},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":107,"endLine":107},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":107,"endLine":107},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":107,"endLine":107},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":104,"endLine":104},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":107,"endLine":107},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":107,"endLine":107},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":107,"endLine":107}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"c6565f3cfd5a6b3b807e4198690ae4daf9a10a0c","url":"https://github.com/bennidi/mbassador/commit/c6565f3cfd5a6b3b807e4198690ae4daf9a10a0c","preChangeSourceCode":{"src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.listener.MessageListener;\nimport net.engio.mbassy.listeners.SimpleHandler;\nimport org.junit.Test;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListener.ForMessage;\n\n/**\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends AssertSupport {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListener<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    /*\n    public void testInterfaced() {\n        MessageListener listener = reader.getMessageListener(InterfacedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, Object.class);\n        validator.check(listener);\n    }  WIP */\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListener<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListener<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListener<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testAnonymousListener() {\n       SimpleHandler anonymousSimpleHandler = new SimpleHandler() {\n           @Override\n           @Handler\n           public void onMessage(Object msg) {\n               // nop\n           }\n       };\n        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(anonymousSimpleHandler.getClass());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, Object.class);\n        validator.check(listener);\n\n\n    }\n\n\n    // Define and assert expectations on handlers in a listener\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListener listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n    // a simple event listener\n    public class MessageListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class MessageListener2 extends MessageListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class MessageListener3 extends MessageListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = Number.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = Integer.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public static interface ListenerInterface{\n\n        @Handler\n        @Enveloped(messages = Object.class)\n        void handle(MessageEnvelope envelope);\n    }\n\n    public class InterfacedListener implements  ListenerInterface{\n\n        @Override\n        public void handle(MessageEnvelope envelope) {\n            //\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n    public static Method[] getMethods(IPredicate<Method> condition, Class<?> target) {\n        ArrayList<Method> methods = new ArrayList<Method>();\n\n        getMethods(condition, target, methods);\n\n        final Method[] array = new Method[methods.size()];\n        methods.toArray(array);\n        return array;\n    }\n\n    public static void getMethods(IPredicate<Method> condition, Class<?> target, ArrayList<Method> methods) {\n        try {\n            for ( Method method : target.getDeclaredMethods() ) {\n                if ( condition.apply( method ) ) {\n                    methods.add( method );\n                }\n            }\n        }\n        catch ( Exception e ) {\n            //nop\n        }\n        if ( !target.equals( Object.class ) ) {\n            getMethods(condition, target.getSuperclass(), methods);\n        }\n    }\n    \n    /**\n    * Traverses the class hierarchy upwards, starting at the given subclass, looking\n    * for an override of the given methods -> finds the bottom most override of the given\n    * method if any exists\n    *\n    * @param overridingMethod\n    * @param subclass\n    */\n    public static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n        Class current = subclass;\n        while ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n            try {\n                return current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n            }\n            catch ( NoSuchMethodException e ) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n    public static Class[] getSuperTypes(Class from) {\n        ArrayList<Class> superclasses = new ArrayList<Class>();\n\n        collectInterfaces( from, superclasses );\n        while ( !from.equals( Object.class ) && !from.isInterface() ) {\n            superclasses.add( from.getSuperclass() );\n            from = from.getSuperclass();\n            collectInterfaces( from, superclasses );\n        }\n\n        final Class[] classes = new Class[superclasses.size()];\n        superclasses.toArray(classes);\n        return classes;\n    }\n\n    public static void collectInterfaces( Class from, Collection<Class> accumulator ) {\n        for ( Class intface : from.getInterfaces() ) {\n            accumulator.add( intface );\n            collectInterfaces( intface, accumulator );\n        }\n    }\n\n    public static boolean containsOverridingMethod( final Method[] allMethods, final Method methodToCheck ) {\n        final int length = allMethods.length;\n        Method method;\n        for (int i = 0; i < length; i++) {\n            method = allMethods[i];\n\n            if ( isOverriddenBy( methodToCheck, method ) ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n\n    /**\n    * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n    *\n    * @param from AnnotatedElement (class, method...)\n    * @param annotationType Annotation class to look for.\n    * @param <A> Class of annotation type\n    * @return Annotation instance or null\n    */\n    private static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n        if( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n    }\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n    private static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = subclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n            if ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/MetadataReaderTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.AssertSupport;\nimport net.engio.mbassy.listener.MessageListener;\nimport net.engio.mbassy.listeners.SimpleHandler;\nimport org.junit.Test;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.io.BufferedReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static net.engio.mbassy.listener.MessageListener.ForMessage;\n\n/**\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MetadataReaderTest extends AssertSupport {\n\n    private MetadataReader reader = new MetadataReader();\n\n    @Test\n    public void testListenerWithoutInheritance() {\n        MessageListener<MessageListener1> listener = reader.getMessageListener(MessageListener1.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testInterfaced() {\n        MessageListener listener = reader.getMessageListener(InterfacedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class);\n        validator.check(listener);\n    }\n\n    /*@Test\n    public void testInterfacedEnveloped() {\n        MessageListener listener = reader.getMessageListener(EnvelopedInterfacedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, Object.class);\n        validator.check(listener);\n    } WIP */\n\n\n    @Test\n    public void testListenerWithInheritance() {\n        MessageListener<MessageListener2> listener = reader.getMessageListener(MessageListener2.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(2, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(1, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testListenerWithInheritanceOverriding() {\n        MessageListener<MessageListener3> listener = reader.getMessageListener(MessageListener3.class);\n\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(0, String.class)\n                .expectHandlers(2, Object.class)\n                .expectHandlers(0, BufferedReader.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnveloped() {\n        MessageListener<EnvelopedListener> listener = reader.getMessageListener(EnvelopedListener.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(2, Long.class)\n                .expectHandlers(1, Double.class)\n                .expectHandlers(1, Number.class)\n                .expectHandlers(0, List.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testEnvelopedSubclass() {\n        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(EnvelopedListenerSubclass.class);\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, String.class)\n                .expectHandlers(2, Integer.class)\n                .expectHandlers(1, Long.class)\n                .expectHandlers(0, Double.class)\n                .expectHandlers(0, Number.class);\n        validator.check(listener);\n    }\n\n    @Test\n    public void testAnonymousListener() {\n       SimpleHandler anonymousSimpleHandler = new SimpleHandler() {\n           @Override\n           @Handler\n           public void onMessage(Object msg) {\n               // nop\n           }\n       };\n        MessageListener<EnvelopedListenerSubclass> listener = reader.getMessageListener(anonymousSimpleHandler.getClass());\n        ListenerValidator validator = new ListenerValidator()\n                .expectHandlers(1, Object.class);\n        validator.check(listener);\n\n\n    }\n\n\n    // Define and assert expectations on handlers in a listener\n    private class ListenerValidator {\n\n        private Map<Class<?>, Integer> handlers = new HashMap<Class<?>, Integer>();\n\n        public ListenerValidator expectHandlers(Integer count, Class<?> messageType){\n            handlers.put(messageType, count);\n            return this;\n        }\n\n        public void check(MessageListener listener){\n            for(Map.Entry<Class<?>, Integer> expectedHandler: handlers.entrySet()){\n                if(expectedHandler.getValue() > 0){\n                    assertTrue(listener.handles(expectedHandler.getKey()));\n                }\n                else{\n                    assertFalse(listener.handles(expectedHandler.getKey()));\n                }\n                assertEquals(expectedHandler.getValue(), listener.getHandlers(ForMessage(expectedHandler.getKey())).size());\n            }\n        }\n\n    }\n\n\n    // a simple event listener\n    public class MessageListener1 {\n\n        @Handler(rejectSubtypes = true)\n        public void handleObject(Object o) {\n\n        }\n\n        @Handler\n        public void handleAny(Object o) {\n\n        }\n\n\n        @Handler\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    // the same handlers as its super class\n    public class MessageListener2 extends MessageListener1 {\n\n        // redefine handler implementation (not configuration)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class MessageListener3 extends MessageListener2 {\n\n        // narrow the handler\n        @Handler(rejectSubtypes = true)\n        public void handleAny(Object o) {\n\n        }\n\n        @Handler(enabled = false)\n        public void handleString(String s) {\n\n        }\n\n    }\n\n    public class EnvelopedListener{\n\n\n        @Handler(rejectSubtypes = true)\n        @Enveloped(messages = {String.class, Integer.class, Long.class})\n        public void handleEnveloped(MessageEnvelope o) {\n\n        }\n\n        @Handler\n        @Enveloped(messages = Number.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public class EnvelopedListenerSubclass extends EnvelopedListener{\n\n        // narrow to integer\n        @Handler\n        @Enveloped(messages = Integer.class)\n        public void handleEnveloped2(MessageEnvelope o) {\n\n        }\n\n    }\n\n    public static interface EnvelopedListenerInterface {\n\n        @Handler\n        @Enveloped(messages = Object.class)\n        void handle(MessageEnvelope envelope);\n    }\n\n    public class EnvelopedInterfacedListener implements  EnvelopedListenerInterface {\n\n        @Override\n        public void handle(MessageEnvelope envelope) {\n            //\n        }\n    }\n\n    public static interface ListenerInterface {\n\n        @Handler\n        void handle(String str);\n    }\n\n    public class InterfacedListener implements  ListenerInterface{\n\n        @Override\n        public void handle(String str) {\n            //\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n    public static Method[] getMethods(IPredicate<Method> condition, Class<?> target) {\n        ArrayList<Method> methods = new ArrayList<Method>();\n\n        getMethods(condition, target, methods);\n\n        final Method[] array = new Method[methods.size()];\n        methods.toArray(array);\n        return array;\n    }\n\n    public static void getMethods(IPredicate<Method> condition, Class<?> target, ArrayList<Method> methods) {\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n\n            for (Class superType : getSuperTypes(target)) {\n                if (superType.equals(Object.class)) {\n                    continue;\n                }\n\n                for (Method superTypeMethod : superType.getDeclaredMethods()) {\n                    if (condition.apply(superTypeMethod )) {\n                        methods.add(superTypeMethod);\n                    }\n                }\n            }\n        }\n        catch (Exception e) {\n            //nop\n        }\n    }\n\n    /**\n    * Traverses the class hierarchy upwards, starting at the given subclass, looking\n    * for an override of the given methods -> finds the bottom most override of the given\n    * method if any exists\n    *\n    * @param overridingMethod\n    * @param subclass\n    */\n    public static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n        Class current = subclass;\n        while ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n            try {\n                return current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n            }\n            catch ( NoSuchMethodException e ) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n    public static Class[] getSuperTypes(Class from) {\n        ArrayList<Class> superclasses = new ArrayList<Class>();\n\n        collectInterfaces( from, superclasses );\n        while ( !from.equals( Object.class ) && !from.isInterface() ) {\n            superclasses.add( from.getSuperclass() );\n            from = from.getSuperclass();\n            collectInterfaces( from, superclasses );\n        }\n\n        final Class[] classes = new Class[superclasses.size()];\n        superclasses.toArray(classes);\n        return classes;\n    }\n\n    public static void collectInterfaces( Class from, Collection<Class> accumulator ) {\n        for ( Class intface : from.getInterfaces() ) {\n            accumulator.add( intface );\n            collectInterfaces( intface, accumulator );\n        }\n    }\n\n    public static boolean containsOverridingMethod( final Method[] allMethods, final Method methodToCheck ) {\n        final int length = allMethods.length;\n        Method method;\n        for (int i = 0; i < length; i++) {\n            method = allMethods[i];\n\n            if ( isOverriddenBy( methodToCheck, method ) ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n\n    /**\n    * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n    *\n    * @param from AnnotatedElement (class, method...)\n    * @param annotationType Annotation class to look for.\n    * @param <A> Class of annotation type\n    * @return Annotation instance or null\n    */\n    private static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n        if( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n    }\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n    private static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = subclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n            if ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[39,41]]},"postChangeRange":{"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[36,45]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":42,"endLine":42}]}],"refactorings":[]},{"repository":"mbassador","sha1":"cb949a219ee69600d85639ee5bee1c70e6a22628","url":"https://github.com/bennidi/mbassador/commit/cb949a219ee69600d85639ee5bee1c70e6a22628","preChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    private int numberOfElements = 100000;\n\n    private int numberOfThreads = 50;\n\n\n    @Test\n    public void testIteratorCleanup() {\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // this will remove all objects that have not been inserted into the set of persisting candidates\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n\n\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n\n\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSet.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.*;\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic class MessageBusTest extends UnitTest{\n\n    private static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            Assert.fail();\n        }\n    };\n\n    public MBassador getBus(BusConfiguration configuration){\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/BusConfiguration.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration {\n\n    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread thread = Executors.defaultThreadFactory().newThread(r);\n            thread.setDaemon(true);\n            return thread;\n        }\n    };\n\n    public static final BusConfiguration Default(){\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    private SubscriptionFactory subscriptionFactory;\n\n    private MetadataReader metadataReader;\n\n    private MessagePublication.Factory messagePublicationFactory;\n\n    public BusConfiguration() {\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.subscriptionFactory = new SubscriptionFactory();\n        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n        this.metadataReader = new MetadataReader();\n        this.messagePublicationFactory = new MessagePublication.Factory();\n    }\n\n    public MessagePublication.Factory getMessagePublicationFactory() {\n        return messagePublicationFactory;\n    }\n\n    public void setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n        this.messagePublicationFactory = messagePublicationFactory;\n    }\n\n    public MetadataReader getMetadataReader() {\n        return metadataReader;\n    }\n\n    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n        this.metadataReader = metadataReader;\n        return this;\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n    public SubscriptionFactory getSubscriptionFactory() {\n        return subscriptionFactory;\n    }\n\n    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n        this.subscriptionFactory = subscriptionFactory;\n        return this;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n    private MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n        }\n        else return getPublicationFactory().createPublication(this, subscriptions, message);\n    }\n\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\n/**\n * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n * If a filter is used the message will only be delivered if it passes the filter(s)\n *\n * NOTE: A message filter must provide either a no-arg constructor.\n *\n * @author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageFilter {\n\n    /**\n     * Evaluate the message to ensure that it matches the handler configuration\n     *\n     *\n     * @param message the message to be delivered\n     * @return\n     */\n\tpublic boolean accepts(Object message, MessageHandlerMetadata metadata);\n\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Handler config = messageHandler.getAnnotation(Handler.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for(Method handler : allHandlers){\n            if(!ReflectionUtils.containsOverridingMethod(allHandlers, handler)){\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n\n        List<MessageHandlerMetadata>  filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for(Method handler : bottomMostHandlers){\n            Handler handle = handler.getAnnotation(Handler.class);\n            if(!handle.enabled() || !isValidMessageHandler(handler)) continue; // disabled or invalid listeners are ignored\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handle), handle);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if(handler == null || handler.getAnnotation(Handler.class) == null){\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/IPublicationErrorHandler.java":"package net.engio.mbassy;\n\n/**\n * Publication error handlers are provided with a publication error every time an error occurs during message publication.\n * A handler might fail with an exception, not be accessible because of the presence of a security manager\n * or other reasons might lead to failures during the message publication process.\n *\n * <p/>\n * @author bennidi\n * Date: 2/22/12\n */\npublic interface IPublicationErrorHandler {\n\n    /**\n     * Handle the given publication error.\n     *\n     * @param error\n     */\n\tpublic void handleError(PublicationError error);\n\n    // This is the default error handler it will simply log to standard out and\n    // print stack trace if available\n    static final class ConsoleLogger implements IPublicationErrorHandler {\n        @Override\n        public void handleError(PublicationError error) {\n            System.out.println(error);\n            if (error.getCause() != null) error.getCause().printStackTrace();\n        }\n    }\n\n    ;\n}\n","src/main/java/net/engio/mbassy/common/ConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T>{\n\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) return this;\n        synchronized (this) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element){\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) return;\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size(){\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (this) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) return this;\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) return false;\n        synchronized (this) {\n            Entry<T> listelement = entries.get(element);\n            if(listelement == null)return false; //removed by other thread\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                Entry<T> oldHead = head;\n                head = head.next();\n                oldHead.next = null; // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) return null;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) return;\n                Entry<T> newCurrent = current.next();\n                ConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if(next != null)next.predecessor = predecessor;\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n\n    }\n}\n","src/main/java/net/engio/mbassy/PublicationError.java":"package net.engio.mbassy;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are created when object publication fails for some reason and contain details\n * as to the cause and location where they occured.\n * <p/>\n * @author bennidi\n * Date: 2/22/12\n * Time: 4:59 PM\n */\npublic class PublicationError {\n\n\tprivate Throwable cause;\n\n\tprivate String message;\n\n\tprivate Method listener;\n\n\tprivate Object listeningObject;\n\n\tprivate Object publishedObject;\n\n\n\tpublic PublicationError(Throwable cause, String message, Method listener, Object listeningObject, Object publishedObject) {\n\t\tthis.cause = cause;\n\t\tthis.message = message;\n\t\tthis.listener = listener;\n\t\tthis.listeningObject = listeningObject;\n\t\tthis.publishedObject = publishedObject;\n\t}\n\n\tpublic PublicationError(){\n\t\tsuper();\n\t}\n\n\tpublic Throwable getCause() {\n\t\treturn cause;\n\t}\n\n\tpublic PublicationError setCause(Throwable cause) {\n\t\tthis.cause = cause;\n\t\treturn this;\n\t}\n\n\tpublic String getMessage() {\n\t\treturn message;\n\t}\n\n\tpublic PublicationError setMessage(String message) {\n\t\tthis.message = message;\n\t\treturn this;\n\t}\n\n\tpublic Method getListener() {\n\t\treturn listener;\n\t}\n\n\tpublic PublicationError setListener(Method listener) {\n\t\tthis.listener = listener;\n\t\treturn this;\n\t}\n\n\tpublic Object getListeningObject() {\n\t\treturn listeningObject;\n\t}\n\n\tpublic PublicationError setListeningObject(Object listeningObject) {\n\t\tthis.listeningObject = listeningObject;\n\t\treturn this;\n\t}\n\n\tpublic Object getPublishedObject() {\n\t\treturn publishedObject;\n\t}\n\n\tpublic PublicationError setPublishedObject(Object publishedObject) {\n\t\tthis.publishedObject = publishedObject;\n\t\treturn this;\n\t}\n\n    @Override\n    public String toString() {\n        return \"PublicationError{\" +\n                \"\\n\" +\n                \"\\tcause=\" + cause +\n                \"\\n\" +\n                \"\\tmessage='\" + message + '\\'' +\n                \"\\n\" +\n                \"\\tlistener=\" + listener +\n                \"\\n\" +\n                \"\\tlisteningObject=\" + listeningObject +\n                \"\\n\" +\n                \"\\tpublishedObject=\" + publishedObject +\n                '}';\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * that lives inside a message bus.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext {\n\n    private IMessageBus owningBus;\n\n    private MessageHandlerMetadata handlerMetadata;\n\n    public SubscriptionContext(IMessageBus owningBus, MessageHandlerMetadata handlerMetadata) {\n        this.owningBus = owningBus;\n        this.handlerMetadata = handlerMetadata;\n    }\n\n    /**\n     * Get a reference to the message bus this context belongs to\n     * @return\n     */\n    public IMessageBus getOwningBus() {\n        return owningBus;\n    }\n\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.dispatch.*;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isEnveloped()){\n          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n       }\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n *\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static class Factory{\n\n        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message){\n            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n        }\n\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private boolean delivered = false;\n\n    private IMessageBus bus;\n\n    public MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute(){\n        state = State.Running;\n        for(Subscription sub : subscriptions){\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if(!delivered){\n            if(!isFilteredEvent() && !isDeadEvent()){\n                bus.post(new FilteredMessage(message)).now();\n            }else if(!isDeadEvent()){\n                bus.post(new DeadMessage(message)).now();\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered(){\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled(){\n        if(!state.equals(State.Initial))\n            return this;\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError(){\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent(){\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent(){\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State{\n        Initial,Scheduled,Running,Finished,Error;\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final MessagePublication.Factory publicationFactory;\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n        pendingMessages  = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    protected MessagePublication.Factory getPublicationFactory(){\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request){\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit){\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for(Subscription sub : subs){\n                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/Enveloped.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Configure a handler to receive an enveloped message as a wrapper around the source\n * message. An enveloped message can contain any type of message\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Enveloped {\n\n    /**\n     * The set of messages that should be dispatched to the message handler\n     */\n\tClass[] messages();\n\n\n}\n","src/main/java/net/engio/mbassy/listener/Filter.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * The filter annotation is used to add filters to message listeners.\n * It references a class that implements the IMessageFilter interface.\n * The filter will be used to check whether a message should be delivered\n * to the listener or not.\n *\n * <p/>\n * @author  bennidi\n * Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n    /**\n     * The class that implements the filter.\n     * Note: A filter always needs to provide a non-arg constructor\n     * @return\n     */\n\tClass<? extends IMessageFilter> value();\n}\n","src/main/java/net/engio/mbassy/listener/Mode.java":"package net.engio.mbassy.listener;\n\n/**\n* Created with IntelliJ IDEA.\n* @author bennidi\n* Date: 11/16/12\n* Time: 10:01 AM\n* To change this template use File | Settings | File Templates.\n*/\npublic enum Mode {\n    Sequential, Concurrent\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n *\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher{\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(Method overridingMethod, Class subclass) {\n        Class current = subclass;\n        while(!current.equals(overridingMethod.getDeclaringClass())){\n            try {\n                Method overridden = current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n                return overridden;\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) filtered.add(method);\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(List<Method> allMethods, Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) return true;\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        if(subClassMethodParameters.length != subClassMethodParameters.length){\n            return false;\n        }\n        //the parameters must occur in the exact same order\n        for(int i = 0 ; i< subClassMethodParameters.length; i++){\n           if(!superClassMethodParameters[i].equals(subClassMethodParameters[i])){\n               return false;\n           }\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * This interface marks components that have access to the subscription context.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface ISubscriptionContextAware extends IMessageBusAware {\n\n    /**\n     * Get the subscription context associated with this object\n     *\n     * @return\n     */\n    public SubscriptionContext getContext();\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n *\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n *\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message The message that should be delivered to the listeners\n     * @param listeners The listeners that should receive the message\n     */\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the message to each\n     * listener\n     * @return\n     */\n    public IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private SubscriptionContext context;\n\n    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType){\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message){\n          dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.dispatch.ISubscriptionContextAware;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware implements ISubscriptionContextAware{\n\n    private SubscriptionContext context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext getContext() {\n        return context;\n    }\n\n    @Override\n    public IMessageBus getBus() {\n        return context.getOwningBus();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error){\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for(IPublicationErrorHandler handler : handlers){\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler){\n        try {\n            handler.invoke(listener, message);\n        }catch(IllegalAccessException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        }\n        catch(IllegalArgumentException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        }\n        catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        }\n        catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Filters.java":"package net.engio.mbassy.listener;\n\n/**\n * Some sample filters that are not particularly useful in production environment\n * but illustrate how filters are meant to be used.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class Filters {\n\n    public static final class AllowAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return false;\n        }\n    }\n\n\n    public static final class RejectSubtypes implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            for(Class handledMessage : metadata.getHandledMessages()){\n                if(handledMessage.equals(event.getClass()))return true;\n            }\n            return false;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static final IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType){\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers;\n\n    private Class<T> listenerDefinition;\n\n    public MessageListenerMetadata(List<MessageHandlerMetadata> handlers, Class<T> listenerDefinition) {\n        this.handlers = handlers;\n        this.listenerDefinition = listenerDefinition;\n    }\n\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter){\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for(MessageHandlerMetadata handler : handlers){\n            if(filter.apply(handler))matching.add(handler);\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType){\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition(){\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/MessageEnvelope.java":"package net.engio.mbassy.subscription;\n\nimport java.sql.Timestamp;\n\n/**\n * A message envelope is used to wrap messages of arbitrary type such that a handler\n * my receive messages of different types.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MessageEnvelope {\n\n    private Timestamp tsCreated = new Timestamp(System.currentTimeMillis());\n\n    private Object message;\n\n\n    public MessageEnvelope(Object message) {\n        this.message = message;\n    }\n\n\n    public <T> T getMessage(){\n        return (T)message;\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/DelegatingMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * A delegating dispatcher wraps additional logic around a given delegate. Essentially its\n * an implementation of the decorator pattern.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher{\n\n    private IMessageDispatcher delegate;\n\n\n    public DelegatingMessageDispatcher(IMessageDispatcher delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    protected IMessageDispatcher getDelegate() {\n        return delegate;\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return delegate.getInvocation();\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Handler.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any object(=listener) as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Handler {\n\n    /**\n     * Add any numbers of filters to the handler. All filters are evaluated before the handler\n     * is actually invoked, which is only if all the filters accept the message.\n     */\n\tFilter[] filters() default {};\n\n    /**\n     * Define the mode in which a message is delivered to each listener. Listeners can be notified\n     * sequentially or concurrently.\n     *\n     */\n    Mode delivery() default Mode.Sequential;\n\n    /**\n     * Handlers are ordered by priority and handlers with higher priority are processed before\n     * those with lower priority, i.e. Influence the order in which different handlers that consume\n     * the same message type are invoked.\n     */\n    int priority() default 0;\n\n    /**\n     * Define whether or not the handler accepts sub types of the message type it declares in its\n     * signature.\n     */\n    boolean rejectSubtypes() default false;\n\n\n    /**\n     * Enable or disable the handler. Disabled handlers do not receive any messages.\n     * This property is useful for quick changes in configuration and necessary to disable\n     * handlers that have been declared by a superclass but do not apply to the subclass\n     */\n    boolean enabled() default true;\n\n}\n","src/test/java/net/engio/mbassy/common/UnitTest.java":"package net.engio.mbassy.common;\n\nimport org.junit.Assert;\n\nimport java.lang.ref.WeakReference;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/12/12\n * Time: 3:16 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class UnitTest {\n\n\n    public void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n    }\n\n    public void pause() {\n        pause(10);\n    }\n\n\n    public void runGC() {\n        WeakReference ref = new WeakReference<Object>(new Object());\n        while(ref.get() != null) {\n            System.gc();\n        }\n    }\n\n    public void fail(String message) {\n        Assert.fail(message);\n    }\n\n    public void fail() {\n        Assert.fail();\n    }\n\n    public void assertTrue(Boolean condition) {\n        Assert.assertTrue(condition);\n    }\n\n    public void assertTrue(String message, Boolean condition) {\n        Assert.assertTrue(message, condition);\n    }\n\n    public void assertFalse(Boolean condition) {\n        Assert.assertFalse(condition);\n    }\n\n    public void assertNull(Object object) {\n        Assert.assertNull(object);\n    }\n\n    public void assertNotNull(Object object) {\n        Assert.assertNotNull(object);\n    }\n\n    public void assertFalse(String message, Boolean condition) {\n        Assert.assertFalse(message, condition);\n    }\n\n    public void assertEquals(Object expected, Object actual) {\n        Assert.assertEquals(expected, actual);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n *\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        publication.markDelivered();\n        for(Object listener: listeners){\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    public void subscribe(Object listener);\n\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     *\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return  true, if the listener was found and successfully removed\n     *          false otherwise\n     */\n    public boolean unsubscribe(Object listener);\n\n    /**\n     *\n     * @param message\n     * @return\n     */\n    public P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    public Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    public boolean hasPendingMessages();\n\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     *\n     */\n    public static interface IPostCommand<T>{\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        public void now();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        public MessagePublication asynchronously();\n\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout is reached.\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        public MessagePublication asynchronously(long timeout, TimeUnit unit);\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/IPredicate.java":"package net.engio.mbassy.common;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 10/22/12\n * Time: 9:33 AM\n * To change this template use File | Settings | File Templates.\n */\npublic interface IPredicate<T> {\n\n    public boolean apply(T target);\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        }\n        else {\n            for (int i = 0; i < filter.length; i++) {\n                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) return false;\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n         if(passesFilter(message)){\n             getDelegate().dispatch(publication, message, listeners);\n         }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation extends ISubscriptionContextAware {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    public void invoke(final Object listener, final Object message);\n\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Handler handlerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType){\n        for(Class<?> handledMessage : handledMessages){\n            if(handledMessage.equals(messageType))return true;\n            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes(){\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.IMessageBus;\n\n/**\n * This interface marks components that have access to the message bus that they belong to.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface IMessageBusAware {\n\n    public IMessageBus getBus();\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    private int numberOfElements = 100000;\n    private int numberOfThreads = 50;\n\n    @Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n    @Test\n    public void testIteratorCleanup() {\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of persisting candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n\n\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSet.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic class MessageBusTest extends UnitTest {\n\n    private static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            Assert.fail();\n        }\n    };\n\n    public MBassador getBus(BusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/BusConfiguration.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration {\n\n    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread thread = Executors.defaultThreadFactory().newThread(r);\n            thread.setDaemon(true);\n            return thread;\n        }\n    };\n\n    public static BusConfiguration Default() {\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    private SubscriptionFactory subscriptionFactory;\n\n    private MetadataReader metadataReader;\n\n    private MessagePublication.Factory messagePublicationFactory;\n\n    public BusConfiguration() {\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.subscriptionFactory = new SubscriptionFactory();\n        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n        this.metadataReader = new MetadataReader();\n        this.messagePublicationFactory = new MessagePublication.Factory();\n    }\n\n    public MessagePublication.Factory getMessagePublicationFactory() {\n        return messagePublicationFactory;\n    }\n\n    public void setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n        this.messagePublicationFactory = messagePublicationFactory;\n    }\n\n    public MetadataReader getMetadataReader() {\n        return metadataReader;\n    }\n\n    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n        this.metadataReader = metadataReader;\n        return this;\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n    public SubscriptionFactory getSubscriptionFactory() {\n        return subscriptionFactory;\n    }\n\n    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n        this.subscriptionFactory = subscriptionFactory;\n        return this;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n    private MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(this, subscriptions, message);\n        }\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\n/**\n * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n * If a filter is used the message will only be delivered if it passes the filter(s)\n * <p/>\n * NOTE: A message filter must provide either a no-arg constructor.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic interface IMessageFilter {\n\n    /**\n     * Evaluate the message to ensure that it matches the handler configuration\n     *\n     * @param message the message to be delivered\n     * @return\n     */\n    boolean accepts(Object message, MessageHandlerMetadata metadata);\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) {\n        Handler config = messageHandler.getAnnotation(Handler.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n\n        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handle = handler.getAnnotation(Handler.class);\n            if (!handle.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handle), handle);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/IPublicationErrorHandler.java":"package net.engio.mbassy;\n\n/**\n * Publication error handlers are provided with a publication error every time an\n * error occurs during message publication.\n * A handler might fail with an exception, not be accessible because of the presence\n * of a security manager or other reasons might lead to failures during the message publication process.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n */\n@SuppressWarnings(\"PMD.UnusedModifier\")\npublic interface IPublicationErrorHandler {\n\n    /**\n     * Handle the given publication error.\n     *\n     * @param error The PublicationError to handle.\n     */\n    void handleError(PublicationError error);\n\n    /**\n     * The default error handler will simply log to standard out and\n     * print the stack trace if available.\n     */\n    static final class ConsoleLogger implements IPublicationErrorHandler {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void handleError(final PublicationError error) {\n\n            // Printout the error itself\n            System.out.println(error);\n\n            // Printout the stacktrace from the cause.\n            if (error.getCause() != null) {\n                error.getCause().printStackTrace();\n            }\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/common/ConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T> {\n\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) {\n            return this;\n        }\n        synchronized (this) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element) {\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) {\n            return;\n        }\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size() {\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (this) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) {\n                    return this;\n                }\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) {\n            return false;\n        }\n        synchronized (this) {\n            Entry<T> listelement = entries.get(element);\n            if (listelement == null) {\n                return false; //removed by other thread\n            }\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                Entry<T> oldHead = head;\n                head = head.next();\n                oldHead.next = null; // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) {\n                    return false;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) {\n                    return;\n                }\n                Entry<T> newCurrent = current.next();\n                ConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n\n    }\n}\n","src/main/java/net/engio/mbassy/PublicationError.java":"package net.engio.mbassy;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are created when object publication fails\n * for some reason and contain details as to the cause and location\n * where they occurred.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n *         Time: 4:59 PM\n */\npublic class PublicationError {\n\n    // Internal state\n    private Throwable cause;\n    private String message;\n    private Method listener;\n    private Object listeningObject;\n    private Object publishedObject;\n\n    /**\n     * Compound constructor, creating a PublicationError from the supplied objects.\n     *\n     * @param cause           The Throwable giving rise to this PublicationError.\n     * @param message         The message to send.\n     * @param listener        The method where the error was created.\n     * @param listeningObject The object in which the PublicationError was generated.\n     * @param publishedObject The published object which gave rise to the error.\n     */\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final Method listener,\n                            final Object listeningObject,\n                            final Object publishedObject) {\n\n        this.cause = cause;\n        this.message = message;\n        this.listener = listener;\n        this.listeningObject = listeningObject;\n        this.publishedObject = publishedObject;\n    }\n\n    /**\n     * Default constructor.\n     */\n    public PublicationError() {\n        super();\n    }\n\n    /**\n     * @return The Throwable giving rise to this PublicationError.\n     */\n    public Throwable getCause() {\n        return cause;\n    }\n\n    /**\n     * Assigns the cause of this PublicationError.\n     *\n     * @param cause A Throwable which gave rise to this PublicationError.\n     * @return This PublicationError.\n     */\n    public PublicationError setCause(Throwable cause) {\n        this.cause = cause;\n        return this;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public PublicationError setMessage(String message) {\n        this.message = message;\n        return this;\n    }\n\n    public Method getListener() {\n        return listener;\n    }\n\n    public PublicationError setListener(Method listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    public Object getListeningObject() {\n        return listeningObject;\n    }\n\n    public PublicationError setListeningObject(Object listeningObject) {\n        this.listeningObject = listeningObject;\n        return this;\n    }\n\n    public Object getPublishedObject() {\n        return publishedObject;\n    }\n\n    public PublicationError setPublishedObject(Object publishedObject) {\n        this.publishedObject = publishedObject;\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        return \"PublicationError{\" +\n                \"\\n\" +\n                \"\\tcause=\" + cause +\n                \"\\n\" +\n                \"\\tmessage='\" + message + '\\'' +\n                \"\\n\" +\n                \"\\tlistener=\" + listener +\n                \"\\n\" +\n                \"\\tlisteningObject=\" + listeningObject +\n                \"\\n\" +\n                \"\\tpublishedObject=\" + publishedObject +\n                '}';\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * that lives inside a message bus.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext {\n\n    private IMessageBus owningBus;\n\n    private MessageHandlerMetadata handlerMetadata;\n\n    public SubscriptionContext(IMessageBus owningBus, MessageHandlerMetadata handlerMetadata) {\n        this.owningBus = owningBus;\n        this.handlerMetadata = handlerMetadata;\n    }\n\n    /**\n     * Get a reference to the message bus this context belongs to\n     *\n     * @return\n     */\n    public IMessageBus getOwningBus() {\n        return owningBus;\n    }\n\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.dispatch.AsynchronousHandlerInvocation;\nimport net.engio.mbassy.dispatch.EnvelopedMessageDispatcher;\nimport net.engio.mbassy.dispatch.FilteredMessageDispatcher;\nimport net.engio.mbassy.dispatch.IHandlerInvocation;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\nimport net.engio.mbassy.dispatch.MessageDispatcher;\nimport net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author bennidi\n *         Date: 11/16/12\n *         Time: 10:39 AM\n *         To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context) {\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) {\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static class Factory {\n\n        public MessagePublication createPublication(IMessageBus owningBus, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(owningBus, subscriptions, message, State.Initial);\n        }\n\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private boolean delivered = false;\n\n    private IMessageBus bus;\n\n    public MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                bus.post(new FilteredMessage(message)).now();\n            } else if (!isDeadEvent()) {\n                bus.post(new DeadMessage(message)).now();\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (!state.equals(State.Initial)) {\n            return this;\n        }\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError() {\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error;\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    private final MessagePublication.Factory publicationFactory;\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        this.publicationFactory = configuration.getMessagePublicationFactory();\n        pendingMessages = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass)) {\n                return; // early reject of known classes that do not participate in eventing\n            }\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for (Class<?> messageType : messageTypes) {\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener) {\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request) {\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for (Subscription sub : subs) {\n                    if (sub.handlesMessageType(messageType)) {\n                        subscriptions.add(sub);\n                    }\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/Enveloped.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Configure a handler to receive an enveloped message as a wrapper around the source\n * message. An enveloped message can contain any type of message\n *\n * @author bennidi\n *         Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Enveloped {\n\n    /**\n     * The set of messages that should be dispatched to the message handler\n     */\n    Class[] messages();\n\n\n}\n","src/main/java/net/engio/mbassy/listener/Filter.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * The filter annotation is used to add filters to message listeners.\n * It references a class that implements the IMessageFilter interface.\n * The filter will be used to check whether a message should be delivered\n * to the listener or not.\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n    /**\n     * The class that implements the filter.\n     * Note: A filter always needs to provide a non-arg constructor\n     *\n     * @return\n     */\n    Class<? extends IMessageFilter> value();\n}\n","src/main/java/net/engio/mbassy/listener/Mode.java":"package net.engio.mbassy.listener;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author bennidi\n *         Date: 11/16/12\n *         Time: 10:01 AM\n *         To change this template use File | Settings | File Templates.\n */\npublic enum Mode {\n    Sequential, Concurrent\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n * <p/>\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils {\n\n    public static List<Method> getMethods(IPredicate<Method> condition, Class<?> target) {\n        List<Method> methods = new LinkedList<Method>();\n        try {\n            for (Method method : target.getDeclaredMethods()) {\n                if (condition.apply(method)) {\n                    methods.add(method);\n                }\n            }\n        } catch (Exception e) {\n            //nop\n        }\n        if (!target.equals(Object.class)) {\n            methods.addAll(getMethods(condition, target.getSuperclass()));\n        }\n        return methods;\n    }\n\n    /**\n     * Traverses the class hierarchy upwards, starting at the given subclass, looking\n     * for an override of the given methods -> finds the bottom most override of the given\n     * method if any exists\n     *\n     * @param overridingMethod\n     * @param subclass\n     * @return\n     */\n    public static Method getOverridingMethod(final Method overridingMethod, final Class subclass) {\n        Class current = subclass;\n        while (!current.equals(overridingMethod.getDeclaringClass())) {\n            try {\n                return current.getDeclaredMethod(overridingMethod.getName(), overridingMethod.getParameterTypes());\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    public static List<Method> withoutOverridenSuperclassMethods(final List<Method> allMethods) {\n        List<Method> filtered = new LinkedList<Method>();\n        for (Method method : allMethods) {\n            if (!containsOverridingMethod(allMethods, method)) {\n                filtered.add(method);\n            }\n        }\n        return filtered;\n    }\n\n    public static Collection<Class> getSuperclasses(Class from) {\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while (!from.equals(Object.class)) {\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n    public static boolean containsOverridingMethod(final List<Method> allMethods, final Method methodToCheck) {\n        for (Method method : allMethods) {\n            if (isOverriddenBy(methodToCheck, method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isOverriddenBy(Method superclassMethod, Method subclassMethod) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if (superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getDeclaringClass().isAssignableFrom(subclassMethod.getDeclaringClass())\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = superclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        if (subClassMethodParameters.length != subClassMethodParameters.length) {\n            return false;\n        }\n        //the parameters must occur in the exact same order\n        for (int i = 0; i < subClassMethodParameters.length; i++) {\n            if (!superClassMethodParameters[i].equals(subClassMethodParameters[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * This interface marks components that have access to the subscription context.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface ISubscriptionContextAware extends IMessageBusAware {\n\n    /**\n     * Get the subscription context associated with this object\n     *\n     * @return the subscription context associated with this object\n     */\n    SubscriptionContext getContext();\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n * <p/>\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n * <p/>\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message     The message that should be delivered to the listeners\n     * @param listeners   The listeners that should receive the message\n     */\n    void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the\n     * message to each listener.\n     *\n     * @return the handler invocation that will be used to deliver the\n     *         message to each listener\n     */\n    IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private SubscriptionContext context;\n\n    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.dispatch.ISubscriptionContextAware;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware implements ISubscriptionContextAware {\n\n    private SubscriptionContext context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext getContext() {\n        return context;\n    }\n\n    @Override\n    public IMessageBus getBus() {\n        return context.getOwningBus();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error) {\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for (IPublicationErrorHandler handler : handlers) {\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler) {\n        try {\n            handler.invoke(listener, message);\n        } catch (IllegalAccessException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        } catch (IllegalArgumentException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        } catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        } catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Filters.java":"package net.engio.mbassy.listener;\n\n/**\n * Some sample filters that are not particularly useful in production environment\n * but illustrate how filters are meant to be used.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class Filters {\n\n    public static final class AllowAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return false;\n        }\n    }\n\n\n    public static final class RejectSubtypes implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            for (Class handledMessage : metadata.getHandledMessages()) {\n                if (handledMessage.equals(event.getClass())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static final IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers;\n\n    private Class<T> listenerDefinition;\n\n    public MessageListenerMetadata(List<MessageHandlerMetadata> handlers, Class<T> listenerDefinition) {\n        this.handlers = handlers;\n        this.listenerDefinition = listenerDefinition;\n    }\n\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for (MessageHandlerMetadata handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/MessageEnvelope.java":"package net.engio.mbassy.subscription;\n\nimport java.sql.Timestamp;\n\n/**\n * A message envelope is used to wrap messages of arbitrary type such that a handler\n * my receive messages of different types.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MessageEnvelope {\n\n    // Internal state\n    private Object message;\n\n    public MessageEnvelope(Object message) {\n        this.message = message;\n    }\n\n    public <T> T getMessage() {\n        return (T) message;\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/DelegatingMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * A delegating dispatcher wraps additional logic around a given delegate. Essentially its\n * an implementation of the decorator pattern.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IMessageDispatcher delegate;\n\n\n    public DelegatingMessageDispatcher(IMessageDispatcher delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    protected IMessageDispatcher getDelegate() {\n        return delegate;\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return delegate.getInvocation();\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Handler.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Mark any method of any object(=listener) as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Handler {\n\n    /**\n     * Add any numbers of filters to the handler. All filters are evaluated before the handler\n     * is actually invoked, which is only if all the filters accept the message.\n     */\n    Filter[] filters() default {};\n\n    /**\n     * Define the mode in which a message is delivered to each listener. Listeners can be notified\n     * sequentially or concurrently.\n     */\n    Mode delivery() default Mode.Sequential;\n\n    /**\n     * Handlers are ordered by priority and handlers with higher priority are processed before\n     * those with lower priority, i.e. Influence the order in which different handlers that consume\n     * the same message type are invoked.\n     */\n    int priority() default 0;\n\n    /**\n     * Define whether or not the handler accepts sub types of the message type it declares in its\n     * signature.\n     */\n    boolean rejectSubtypes() default false;\n\n\n    /**\n     * Enable or disable the handler. Disabled handlers do not receive any messages.\n     * This property is useful for quick changes in configuration and necessary to disable\n     * handlers that have been declared by a superclass but do not apply to the subclass\n     */\n    boolean enabled() default true;\n\n}\n","src/test/java/net/engio/mbassy/common/UnitTest.java":"package net.engio.mbassy.common;\n\nimport org.junit.Assert;\n\nimport java.lang.ref.WeakReference;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/12/12\n * Time: 3:16 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class UnitTest {\n\n    // Internal state\n    private Runtime runtime = Runtime.getRuntime();\n\n    public void pause(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void pause() {\n        pause(10);\n    }\n\n\n    public void runGC() {\n        WeakReference ref = new WeakReference<Object>(new Object());\n        while(ref.get() != null) {\n            runtime.gc();\n        }\n    }\n\n    public void fail(String message) {\n        Assert.fail(message);\n    }\n\n    public void fail() {\n        Assert.fail();\n    }\n\n    public void assertTrue(Boolean condition) {\n        Assert.assertTrue(condition);\n    }\n\n    public void assertTrue(String message, Boolean condition) {\n        Assert.assertTrue(message, condition);\n    }\n\n    public void assertFalse(Boolean condition) {\n        Assert.assertFalse(condition);\n    }\n\n    public void assertNull(Object object) {\n        Assert.assertNull(object);\n    }\n\n    public void assertNotNull(Object object) {\n        Assert.assertNotNull(object);\n    }\n\n    public void assertFalse(String message, Boolean condition) {\n        Assert.assertFalse(message, condition);\n    }\n\n    public void assertEquals(Object expected, Object actual) {\n        Assert.assertEquals(expected, actual);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n * <p/>\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        publication.markDelivered();\n        for (Object listener : listeners) {\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    void subscribe(Object listener);\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     * <p/>\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return true, if the listener was found and successfully removed\n     *         false otherwise\n     */\n    boolean unsubscribe(Object listener);\n\n    /**\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     */\n    interface IPostCommand<T> {\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        void now();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        MessagePublication asynchronously();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout is reached.\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        MessagePublication asynchronously(long timeout, TimeUnit unit);\n    }\n}\n","src/main/java/net/engio/mbassy/common/IPredicate.java":"package net.engio.mbassy.common;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author bennidi\n *         Date: 10/22/12\n *         Time: 9:33 AM\n *         To change this template use File | Settings | File Templates.\n */\npublic interface IPredicate<T> {\n\n    boolean apply(T target);\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (int i = 0; i < filter.length; i++) {\n                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation extends ISubscriptionContextAware {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    void invoke(Object listener, Object message);\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Handler handlerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        if (this.envelope != null) {\n            for (Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        } else {\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous() {\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered() {\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority() {\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.IMessageBus;\n\n/**\n * This interface marks components that have access to the message bus that they belong to.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface IMessageBusAware {\n\n    IMessageBus getBus();\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/bus/BusConfiguration.java":[[25,25]],"src/main/java/net/engio/mbassy/bus/MBassador.java":[[33,33]],"src/main/java/net/engio/mbassy/listener/IMessageFilter.java":[[21,21]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[32,32],[78,78]],"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":[[43,43],[59,59],[149,149],[30,30],[90,90],[101,101],[113,113],[68,68],[71,71]],"src/main/java/net/engio/mbassy/IPublicationErrorHandler.java":[[19,19],[27,27]],"src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":[[41,41]],"src/main/java/net/engio/mbassy/listener/Filters.java":[[34,34]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[86,86]],"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java":[[117,117],[102,102],[104,104],[195,195]],"src/test/java/net/engio/mbassy/common/UnitTest.java":[[33,33]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[108,108],[99,99],[60,60],[141,141],[154,154],[130,130],[115,115],[92,92],[82,82],[72,72],[75,75]],"src/main/java/net/engio/mbassy/common/IPredicate.java":[[12,12]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[31,31]],"src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":[[20,20]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[78,78],[79,79]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[45,45],[46,46],[57,57],[73,73]],"src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":[[18,18]],"src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":[[13,13]],"src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":[[35,35],[36,36],[39,39],[29,29],[30,30],[32,32]]},"postChangeRange":{"src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":[[58,60]],"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[32,32]],"src/main/java/net/engio/mbassy/bus/MBassador.java":[[32,34]],"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[20,22]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[34,36],[81,83]],"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":[[45,47],[63,65],[165,167],[30,32],[100,102],[113,115],[127,129],[74,76],[79,81]],"src/main/java/net/engio/mbassy/IPublicationErrorHandler.java":[[19,19],[29,31],[33,33],[39,41]],"src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":[[40,42]],"src/main/java/net/engio/mbassy/listener/Filters.java":[[34,36]],"src/main/java/net/engio/mbassy/PublicationError.java":[[24,32],[33,33],[34,34],[35,35],[36,36],[37,37],[107,109],[60,65],[53,55],[46,48]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[85,86],[87,87]],"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java":[[176,176],[134,135],[136,136],[116,118],[120,122],[214,216]],"src/test/java/net/engio/mbassy/common/UnitTest.java":[[35,35]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[129,129],[140,140],[65,65],[70,70]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[30,32]],"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":[[75,77],[78,80]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[41,41],[45,45],[53,53],[56,58],[72,72],[74,76]],"src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":[[16,16]],"src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":[[35,35],[36,36],[38,38],[39,39],[29,29],[30,30]]},"microChanges":[{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/IPublicationErrorHandler.java","startLine":27,"endLine":27}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/IPublicationErrorHandler.java","startLine":39,"endLine":39}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java","startLine":195,"endLine":195}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java","startLine":214,"endLine":214}]},{"type":"AddCurlyBrace","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java","startLine":134,"endLine":134}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java","startLine":102,"endLine":102}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java","startLine":116,"endLine":116}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java","startLine":104,"endLine":104}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractMessageBus.java","startLine":120,"endLine":120}]},{"type":"AddCurlyBrace","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":85,"endLine":85}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":30,"endLine":30}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":30,"endLine":30}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":59,"endLine":59}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":63,"endLine":63}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":43,"endLine":43}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":45,"endLine":45}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":90,"endLine":90}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":100,"endLine":100}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":101,"endLine":101}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":113,"endLine":113}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":113,"endLine":113}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":127,"endLine":127}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":68,"endLine":68}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":74,"endLine":74}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":71,"endLine":71}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":79,"endLine":79}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":149,"endLine":149}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":165,"endLine":165}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":73,"endLine":73}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":74,"endLine":74}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":57,"endLine":57}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":56,"endLine":56}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java","startLine":31,"endLine":31}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java","startLine":30,"endLine":30}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/Filters.java","startLine":34,"endLine":34}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/Filters.java","startLine":34,"endLine":34}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java","startLine":78,"endLine":78}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java","startLine":75,"endLine":75}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java","startLine":79,"endLine":79}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java","startLine":78,"endLine":78}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java","startLine":41,"endLine":41}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java","startLine":40,"endLine":40}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":32,"endLine":32}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":34,"endLine":34}]},{"type":"AddCurlyBrace","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":81,"endLine":81}]}],"refactorings":[]},{"repository":"mbassador","sha1":"0a7ed2e651b04756ff210eacb68671d5cd0c2f2b","url":"https://github.com/bennidi/mbassador/commit/0a7ed2e651b04756ff210eacb68671d5cd0c2f2b","preChangeSourceCode":{"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.messages.ITestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends UnitTest{\n\n\n    @Test\n    public void testSimpleSynchronousHandler(){\n        final SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n        final Set listeners = Collections.synchronizedSet(new HashSet());\n        final int concurrentUnits = 5;\n        final int numberOfLoops = 100;\n        final int numberOfListeners =  numberOfLoops * concurrentUnits * 2;\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(int i = 0 ; i < numberOfLoops ; i++){\n                    SimpleSynchronousMessageHandler\n                            listener1 = new SimpleSynchronousMessageHandler();\n                    SimpleSynchronousMessageHandler2 listener2 = new SimpleSynchronousMessageHandler2();\n                    subMan.subscribe(listener1);\n                    subMan.subscribe(listener2);\n                    listeners.add(listener1);\n                    listeners.add(listener2);\n                }\n\n            }\n        }, concurrentUnits);\n\n\n        Collection<Subscription> subscriptions = subMan.getSubscriptionsByMessageType(TestMessage.class);\n        assertEquals(2, subscriptions.size());\n\n        for(Subscription sub : subscriptions){\n            assertEquals(numberOfListeners, sub.size());\n            for(Object listener : listeners){\n\n                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n            }\n        }\n\n        subscriptions = subMan.getSubscriptionsByMessageType(ITestMessage.class);\n        assertEquals(2, subscriptions.size());\n        for(Subscription sub : subscriptions){\n            assertEquals(numberOfListeners, sub.size());\n            for(Object listener : listeners){\n                if(sub.isFromListener(listener))assertTrue(sub.contains(listener));\n            }\n        }\n    }\n\n\n    class SubscriptionValidator{\n\n\n        private List<Entry> validations = new LinkedList<Entry>();\n        private Set<Class> messageTypes = new HashSet<Class>();\n        private Set<Class> subsribers = new HashSet<Class>();\n\n\n        public SubscriptionValidator expect(int numberOfSubscriber, Class subscriber, Class messageType){\n            validations.add(new Entry(messageType, numberOfSubscriber, subscriber));\n            messageTypes.add(messageType);\n            subsribers.add(subscriber);\n            return this;\n        }\n\n        public void validate(SubscriptionManager manager){\n            for(Class messageType : messageTypes){\n                Collection<Subscription> subscriptions = manager.getSubscriptionsByMessageType(messageType);\n                Collection<Entry> validationEntries = getEntries(EntriesByMessageType(messageType));\n                assertEquals(subscriptions.size(), validationEntries.size());\n                for(Entry validationEntry : validationEntries){\n                    Subscription matchingSub = null;\n                    for(Subscription sub : subscriptions){\n                        if(sub.isFromListener(validationEntry.subscriber));\n                    }\n                }\n            }\n\n\n        }\n\n\n        private Collection<Entry> getEntries(IPredicate<Entry> filter){\n            Collection<Entry> matching = new LinkedList<Entry>();\n            for (Entry validationEntry : validations){\n                if(filter.apply(validationEntry))matching.add(validationEntry);\n            }\n            return matching;\n        }\n\n        private IPredicate<Entry> EntriesByMessageType(final Class messageType){\n            return new IPredicate<Entry>() {\n                @Override\n                public boolean apply(Entry target) {\n                    return target.messageType.equals(messageType);\n                }\n            };\n        }\n\n        private IPredicate<Entry> EntriesBySubscriberType(final Class subscriberType){\n            return new IPredicate<Entry>() {\n                @Override\n                public boolean apply(Entry target) {\n                    return target.subscriber.equals(subscriberType);\n                }\n            };\n        }\n\n\n\n        private class Entry{\n\n            private int numberOfSubscribers;\n\n            private Class subscriber;\n\n            private Class messageType;\n\n            private Entry(Class messageType, int numberOfSubscribers, Class subscriber) {\n                this.messageType = messageType;\n                this.numberOfSubscribers = numberOfSubscribers;\n                this.subscriber = subscriber;\n            }\n\n\n        }\n\n    }\n\n\n    static class SimpleSynchronousMessageHandler{\n\n        @Handler\n        public void handle(TestMessage message) {\n        }\n\n        @Handler\n        public void handle(ITestMessage message) {\n        }\n    }\n\n\n    static class SimpleSynchronousMessageHandler2{\n\n        @Handler\n        public void handle(TestMessage message) {\n        }\n\n        @Handler\n        public void handle(ITestMessage message) {\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    public boolean isFromListener(Class listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public List<Class<?>> getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.messages.ITestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.*;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends UnitTest{\n\n\n    @Test\n    public void testSimpleSynchronousHandler(){\n        final SubscriptionManager subMan = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory());\n        final Set listeners = Collections.synchronizedSet(new HashSet());\n        final int concurrentUnits = 5;\n        final int numberOfLoops = 100;\n        final int numberOfListeners =  numberOfLoops * concurrentUnits;\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for(int i = 0 ; i < numberOfLoops ; i++){\n                    SimpleSynchronousMessageHandler\n                            listener1 = new SimpleSynchronousMessageHandler();\n                    SimpleSynchronousMessageHandler2 listener2 = new SimpleSynchronousMessageHandler2();\n                    subMan.subscribe(listener1);\n                    subMan.subscribe(listener2);\n                    listeners.add(listener1);\n                    listeners.add(listener2);\n                }\n\n            }\n        }, concurrentUnits);\n\n        SubscriptionValidator validator = new SubscriptionValidator();\n        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler.class, ITestMessage.class);\n        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler2.class, ITestMessage.class);\n        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler.class, TestMessage.class);\n        validator.expect(numberOfListeners, SimpleSynchronousMessageHandler2.class, TestMessage.class);\n\n        validator.validate(subMan);\n\n    }\n\n\n    class SubscriptionValidator{\n\n\n        private List<Entry> validations = new LinkedList<Entry>();\n        private Set<Class> messageTypes = new HashSet<Class>();\n        private Set<Class> subsribers = new HashSet<Class>();\n\n\n        public SubscriptionValidator expect(int numberOfSubscriber, Class subscriber, Class messageType){\n            validations.add(new Entry(messageType, numberOfSubscriber, subscriber));\n            messageTypes.add(messageType);\n            subsribers.add(subscriber);\n            return this;\n        }\n\n        public void validate(SubscriptionManager manager){\n            for(Class messageType : messageTypes){\n                Collection<Subscription> subscriptions = manager.getSubscriptionsByMessageType(messageType);\n                Collection<Entry> validationEntries = getEntries(EntriesByMessageType(messageType));\n                assertEquals(subscriptions.size(), validationEntries.size());\n                for(Entry validationEntry : validationEntries){\n                    Subscription matchingSub = null;\n                    // one of the subscriptions must belong to the subscriber type\n                    for(Subscription sub : subscriptions){\n                        if(sub.belongsTo(validationEntry.subscriber)){\n                            matchingSub = sub;\n                            break;\n                        }\n                    }\n                    assertNotNull(matchingSub);\n                    assertEquals(validationEntry.numberOfSubscribers, matchingSub.size());\n                }\n            }\n        }\n\n\n        private Collection<Entry> getEntries(IPredicate<Entry> filter){\n            Collection<Entry> matching = new LinkedList<Entry>();\n            for (Entry validationEntry : validations){\n                if(filter.apply(validationEntry))matching.add(validationEntry);\n            }\n            return matching;\n        }\n\n        private IPredicate<Entry> EntriesByMessageType(final Class messageType){\n            return new IPredicate<Entry>() {\n                @Override\n                public boolean apply(Entry target) {\n                    return target.messageType.equals(messageType);\n                }\n            };\n        }\n\n        private IPredicate<Entry> EntriesBySubscriberType(final Class subscriberType){\n            return new IPredicate<Entry>() {\n                @Override\n                public boolean apply(Entry target) {\n                    return target.subscriber.equals(subscriberType);\n                }\n            };\n        }\n\n\n\n        private class Entry{\n\n            private int numberOfSubscribers;\n\n            private Class subscriber;\n\n            private Class messageType;\n\n            private Entry(Class messageType, int numberOfSubscribers, Class subscriber) {\n                this.messageType = messageType;\n                this.numberOfSubscribers = numberOfSubscribers;\n                this.subscriber = subscriber;\n            }\n\n\n        }\n\n    }\n\n\n    static class SimpleSynchronousMessageHandler{\n\n        @Handler\n        public void handle(TestMessage message) {\n        }\n\n        @Handler\n        public void handle(ITestMessage message) {\n        }\n    }\n\n\n    static class SimpleSynchronousMessageHandler2{\n\n        @Handler\n        public void handle(TestMessage message) {\n        }\n\n        @Handler\n        public void handle(ITestMessage message) {\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    public boolean belongsTo(Class listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public List<Class<?>> getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[97,97],[33,33],[52,52],[53,53],[55,61],[63,63],[64,64],[65,70]]},"postChangeRange":{"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[85,88],[90,90],[91,91],[50,50],[51,51],[52,52],[53,53],[54,54],[56,56]]},"microChanges":[],"refactorings":[{"type":"\"Rename Method\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":97,"endLine":97}],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java","startLine":85,"endLine":85}]}]},{"repository":"mbassador","sha1":"eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53","url":"https://github.com/bennidi/mbassador/commit/eb50dbc96ec8f82cfdddd1a17f4106b62cbc3c53","preChangeSourceCode":{"src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport java.lang.reflect.Method;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends AbstractHandlerInvocation implements IHandlerInvocation {\n\n    public ReflectiveHandlerInvocation(MessagingContext context) {\n        super(context);\n    }\n\n    @Override\n    public void invoke(final Method handler, final Object listener, final Object message) {\n        invokeHandler(message, listener, handler);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport java.lang.reflect.Method;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation implements IHandlerInvocation {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super();\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void invoke(final Method handler, final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(handler, listener, message);\n            }\n        });\n    }\n\n    @Override\n    public MessagingContext getContext() {\n        return delegate.getContext();\n    }\n}\n","src/main/java/net/engio/mbassy/AbstractMessageBus.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.dispatch.MessagingContext;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request){\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit){\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for(Subscription sub : subs){\n                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/DeadEvent.java":"package net.engio.mbassy.common;\n\n/**\n * The DeadEvent is delivered to all subscribed handlers (if any) whenever no message\n * handlers could be found for a given message publication.\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEvent {\n\n    private Object event;\n\n    public DeadEvent(Object event) {\n        this.event = event;\n    }\n\n    public Object getEvent() {\n        return event;\n    }\n}\n","src/main/java/net/engio/mbassy/MessagePublication.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static  MessagePublication Create(Collection<Subscription> subscriptions, Object message){\n        return new MessagePublication(subscriptions, message, State.Initial);\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private MessagePublication(Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute(){\n        state = State.Running;\n        for(Subscription sub : subscriptions){\n            sub.publish(message);\n        }\n        state = State.Finished;\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public MessagePublication markScheduled(){\n        if(!state.equals(State.Initial))\n            return this;\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError(){\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent(){\n        return DeadEvent.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State{\n        Initial,Scheduled,Running,Finished,Error;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.dispatch.AsynchronousHandlerInvocation;\nimport net.engio.mbassy.dispatch.EnvelopedMessageDispatcher;\nimport net.engio.mbassy.dispatch.FilteredMessageDispatcher;\nimport net.engio.mbassy.dispatch.IHandlerInvocation;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\nimport net.engio.mbassy.dispatch.MessageDispatcher;\nimport net.engio.mbassy.dispatch.MessagingContext;\nimport net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(MessagingContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isEnveloped()){\n          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n       }\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport java.lang.reflect.Method;\n\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n *\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher implements IMessageDispatcher {\n\n    private MessagingContext context;\n\n    private IHandlerInvocation invocation;\n\n    public MessageDispatcher(MessagingContext context, IHandlerInvocation invocation) {\n        this.context = context;\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(Object message, ConcurrentSet listeners) {\n        Method handler = getContext().getHandlerMetadata().getHandler();\n        for(Object listener: listeners){\n            getInvocation().invoke(handler, listener, message);\n        }\n    }\n\n    public MessagingContext getContext() {\n        return context;\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n}\n","src/test/java/net/engio/mbassy/DeadEventTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Listener;\nimport org.junit.Test;\n\n/**\n * Verify correct behaviour in case of empty message publications\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEventTest extends UnitTest{\n\n\n    @Test\n    public void testDeadEvent(){\n        MBassador bus = new MBassador(BusConfiguration.Default());\n        DeadEventHandler deadEventHandler = new DeadEventHandler();\n        bus.subscribe(deadEventHandler);\n        assertEquals(0, deadEventHandler.getDeadEventCount());\n        bus.post(new Object()).now();\n        assertEquals(1, deadEventHandler.getDeadEventCount());\n        bus.post(323).now();\n        assertEquals(2, deadEventHandler.getDeadEventCount());\n        bus.publish(\"fkdfdk\");\n        assertEquals(3, deadEventHandler.getDeadEventCount());\n    }\n\n    public class DeadEventHandler{\n\n         private ConcurrentSet deadEvents = new ConcurrentSet();\n\n        @Listener\n         public void handle(DeadEvent event){\n             deadEvents.add(event);\n         }\n\n\n        public int getDeadEventCount(){\n            return deadEvents.size();\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher implements IMessageDispatcher {\n\n    private IMessageDispatcher del;\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        this.del = dispatcher;\n    }\n\n    @Override\n    public void dispatch(Object message, ConcurrentSet listeners) {\n        del.dispatch(new MessageEnvelope(message), listeners);\n    }\n\n    @Override\n    public MessagingContext getContext() {\n        return del.getContext();\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return del.getInvocation();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher implements IMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    private IMessageDispatcher del;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        this.del = dispatcher;\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        }\n        else {\n            for (int i = 0; i < filter.length; i++) {\n                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) return false;\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(Object message, ConcurrentSet listeners) {\n         if(passesFilter(message)){\n             del.dispatch(message, listeners);\n         }\n    }\n\n    @Override\n    public MessagingContext getContext() {\n        return del.getContext();\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return del.getInvocation();\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport java.lang.reflect.Method;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation {\n\n    /**\n     * Invoke the message delivery logic of this handler invocation\n     *\n     * @param handler The method that represents the actual message handler logic of the listener\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    public void invoke(final Method handler, final Object listener, final Object message);\n\n    /**\n     * Get the messaging context associated with this invocation\n     * @return\n     */\n    public MessagingContext getContext();\n\n}\n","src/main/java/net/engio/mbassy/MBassador.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n    private MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if (subscriptions == null || subscriptions.isEmpty()) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n            return MessagePublication.Create(subscriptions, new DeadEvent(message));\n        }\n        else return MessagePublication.Create(subscriptions, message);\n    }\n\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n\n            /*\n            final Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n            if (subscriptions == null || subscriptions.isEmpty()) {\n                // publish a DeadEvent since no subscriptions could be found\n                final Collection<Subscription> deadEventSubscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n                if (deadEventSubscriptions != null && !deadEventSubscriptions.isEmpty()) {\n                    for (Subscription subscription : deadEventSubscriptions) {\n                        subscription.publish(new DeadEvent(message));\n                    }\n                }\n            }\n            else{\n                for (Subscription subscription : subscriptions) {\n                    subscription.publish(message);\n                }\n            }*/\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n *\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n *\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers to achieve more complex\n * dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param message The message that should be delivered to the listeners\n     * @param listeners The listeners that should receive the message\n     */\n    public void dispatch(Object message, ConcurrentSet listeners);\n\n    /**\n     * Get the messaging context associated with this dispatcher\n     *\n     * @return\n     */\n    public MessagingContext getContext();\n\n    /**\n     * Get the handler invocation that will be used to deliver the message to each\n     * listener\n     * @return\n     */\n    public IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\nimport net.engio.mbassy.dispatch.MessagingContext;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private MessagingContext context;\n\n    public Subscription(MessagingContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType){\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(Object message){\n          dispatcher.dispatch(message, listeners);\n    }\n\n    public MessagingContext getContext(){\n        return context;\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error){\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for(IPublicationErrorHandler handler : handlers){\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler){\n        try {\n            handler.invoke(listener, message);\n        }catch(IllegalAccessException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        }\n        catch(IllegalArgumentException e){\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        }\n        catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        }\n        catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/main/java/net/engio/mbassy/AbstractMessageBus.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.dispatch.SubscriptionContext;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new SubscriptionContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request){\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit){\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for(Subscription sub : subs){\n                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/DeadEvent.java":"package net.engio.mbassy.common;\n\n/**\n * The DeadEvent is delivered to all subscribed handlers (if any) whenever no message\n * handlers could be found for a given message publication.\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEvent extends PublicationEvent {\n\n    public DeadEvent(Object message) {\n        super(message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/MessagePublication.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.common.FilteredEvent;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n *\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static  MessagePublication Create(IMessageBus bus, Collection<Subscription> subscriptions, Object message){\n        return new MessagePublication(bus,subscriptions, message, State.Initial);\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private boolean delivered = false;\n\n    private IMessageBus bus;\n\n    private MessagePublication(IMessageBus bus, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.bus = bus;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute(){\n        state = State.Running;\n        for(Subscription sub : subscriptions){\n            sub.publish(this, message);\n        }\n        state = State.Finished;\n        if(!delivered && !isFilteredEvent() && !isDeadEvent()){\n            bus.post(new FilteredEvent(message)).now();\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered(){\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled(){\n        if(!state.equals(State.Initial))\n            return this;\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError(){\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent(){\n        return DeadEvent.class.isAssignableFrom(message.getClass());\n    }\n\n    public boolean isFilteredEvent(){\n        return FilteredEvent.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State{\n        Initial,Scheduled,Running,Finished,Error;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.dispatch.SubscriptionContext;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isEnveloped()){\n          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n       }\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport java.lang.reflect.Method;\n\nimport net.engio.mbassy.IMessageBus;\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n *\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        publication.markDelivered();\n        for(Object listener: listeners){\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n\n}\n","src/test/java/net/engio/mbassy/DeadEventTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.common.UnitTest;\nimport net.engio.mbassy.listener.Listener;\nimport org.junit.Test;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEventTest extends UnitTest{\n\n\n    @Test\n    public void testDeadEvent(){\n        MBassador bus = new MBassador(BusConfiguration.Default());\n        DeadEventHandler deadEventHandler = new DeadEventHandler();\n        bus.subscribe(deadEventHandler);\n        assertEquals(0, deadEventHandler.getDeadEventCount());\n        bus.post(new Object()).now();\n        assertEquals(1, deadEventHandler.getDeadEventCount());\n        bus.post(323).now();\n        assertEquals(2, deadEventHandler.getDeadEventCount());\n        bus.publish(\"fkdfdk\");\n        assertEquals(3, deadEventHandler.getDeadEventCount());\n    }\n\n    public class DeadEventHandler{\n\n         private ConcurrentSet deadEvents = new ConcurrentSet();\n\n        @Listener\n         public void handle(DeadEvent event){\n             deadEvents.add(event);\n         }\n\n\n        public int getDeadEventCount(){\n            return deadEvents.size();\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n *\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher{\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        }\n        else {\n            for (int i = 0; i < filter.length; i++) {\n                if (!filter[i].accepts(message, getContext().getHandlerMetadata())) return false;\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n         if(passesFilter(message)){\n             getDelegate().dispatch(publication, message, listeners);\n         }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation extends ISubscriptionContextAware {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    public void invoke(final Object listener, final Object message);\n\n\n}\n","src/main/java/net/engio/mbassy/MBassador.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n    private MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if (subscriptions == null || subscriptions.isEmpty()) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n            return MessagePublication.Create(this, subscriptions, new DeadEvent(message));\n        }\n        else return MessagePublication.Create(this, subscriptions, message);\n    }\n\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n *\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n *\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message The message that should be delivered to the listeners\n     * @param listeners The listeners that should receive the message\n     */\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the message to each\n     * listener\n     * @return\n     */\n    public IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\nimport net.engio.mbassy.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\nimport net.engio.mbassy.dispatch.SubscriptionContext;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private SubscriptionContext context;\n\n    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType){\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message){\n          dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":[[17,17]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[21,21]],"src/main/java/net/engio/mbassy/AbstractMessageBus.java":[[125,125]],"src/main/java/net/engio/mbassy/common/DeadEvent.java":[[14,14],[15,15]]},"postChangeRange":{"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[17,17]],"src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":[[20,20]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[20,20]],"src/main/java/net/engio/mbassy/AbstractMessageBus.java":[[125,125]],"src/main/java/net/engio/mbassy/common/DeadEvent.java":[[12,12],[13,13]],"src/main/java/net/engio/mbassy/MessagePublication.java":[[50,50],[53,55]],"src/main/java/net/engio/mbassy/MBassador.java":[[30,30],[32,32]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/MessagePublication.java","startLine":53,"endLine":53}]}],"refactorings":[]},{"repository":"mbassador","sha1":"cebe1bab8d637c3b62c8414f7555ff8eea046abc","url":"https://github.com/bennidi/mbassador/commit/cebe1bab8d637c3b62c8414f7555ff8eea046abc","preChangeSourceCode":{"src/test/java/net/engio/mbassy/common/ListenerFactory.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * The factory can be used to declaratively specify how many instances of some given classes\n * should be created. It will create those instances using reflection and provide a list containing those instances.\n * The factory also holds strong references to the instances such that GC will not interfere with tests unless the\n * factory is explicitly cleared.\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class ListenerFactory {\n\n    private Map<Class, Integer> requiredBeans = new HashMap<Class, Integer>();\n    private volatile List generatedListeners;\n    private int requiredSize = 0;\n\n    public int getNumberOfListeners(Class listener){\n        return requiredBeans.containsKey(listener) ? requiredBeans.get(listener) : 0;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Class clazz){\n        requiredBeans.put(clazz, numberOfInstances);\n        requiredSize +=numberOfInstances;\n        return this;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Class ...classes){\n        for(Class clazz : classes)\n            create(numberOfInstances,clazz);\n        return this;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Collection<Class> classes){\n        for(Class clazz : classes)\n            create(numberOfInstances,clazz);\n        return this;\n    }\n\n\n    public synchronized List<Object> getAll(){\n        if(generatedListeners != null)\n            return generatedListeners;\n        List listeners = new ArrayList(requiredSize);\n        try {\n            for(Class clazz : requiredBeans.keySet()){\n                int numberOfRequiredBeans = requiredBeans.get(clazz);\n                for(int i = 0; i < numberOfRequiredBeans; i++){\n                    listeners.add(clazz.newInstance());\n                }\n            }\n        } catch (Exception e) {\n            // if instantiation fails, counts will be incorrect\n            // -> fail early here\n            Assert.fail(\"There was a problem instantiating a listener \" + e);\n        }\n        Collections.shuffle(listeners);\n        generatedListeners  = Collections.unmodifiableList(listeners);\n        return generatedListeners;\n    }\n\n    // not thread-safe but not yet used concurrently\n    public synchronized  void clear(){\n        generatedListeners = null;\n        requiredBeans.clear();\n    }\n\n    /**\n     * Create a thread-safe read-only iterator\n     *\n     * NOTE: Iterator is not perfectly synchronized with mutator methods of the list of generated listeners\n     * In theory, it is possible that the list is changed while iterators are still running which should be avoided.\n     * @return\n     */\n    public Iterator iterator(){\n        getAll();\n        final AtomicInteger current = new AtomicInteger(0);\n\n        return new Iterator() {\n            @Override\n            public boolean hasNext() {\n                return current.get() < generatedListeners.size();\n            }\n\n            @Override\n            public Object next() {\n                int index =  current.getAndIncrement();\n                return index < generatedListeners.size() ? generatedListeners.get(index) : null;\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Iterator is read only\");\n            }\n        };\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":"package net.engio.mbassy.bus.config;\n\n/**\n * The configuration of message bus instances is feature driven, e.g. configuration parameters\n * are grouped into {@link Feature}.\n *\n * Features can be added to a bus configuration to be used later in the instantiation process of the message bus.\n * Each bus will look for the features it requires and configure them according to the provided configuration. If a required feature is not found the bus will publish a {@link ConfigurationError}\n * to the {@link ConfigurationErrorHandler}\n *\n * @author bennidi.\n */\npublic interface IBusConfiguration{\n\n    /**\n     * Get a registered feature by its type (class).\n     *\n     * @param feature\n     * @param <T>\n     * @return\n     */\n    <T extends Feature> T getFeature(Class<T> feature);\n\n    IBusConfiguration addFeature(Feature feature);\n\n    IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler);\n\n\n\n}\n","src/test/java/net/engio/mbassy/ConditionalHandlers.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/*****************************************************************************\n * Some unit tests for the \"condition\" filter.\n ****************************************************************************/\n\npublic class ConditionalHandlers extends MessageBusTest {\n\n\tpublic static class TestEvent {\n\n\t\tprivate Set<String> handledBy = new HashSet<String>();\n\t\tprivate String type;\n\t\tprivate int size;\n\n\t\tpublic TestEvent(String type, int size) {\n\t\t\tsuper();\n\t\t\tthis.type = type;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String getType() {\n\t\t\treturn type;\n\t\t}\n\n\t\tpublic int getSize() {\n\t\t\treturn size;\n\t\t}\n\n        public boolean wasHandledBy(String ...handlers){\n            for(String handler : handlers){\n                if (!handledBy.contains(handler)) return false;\n            }\n            return true;\n        }\n\n        public void handledBy(String handler){\n            handledBy.add(handler);\n        }\n\t\t\n\t}\n\n    @Listener(references = References.Strong)\n\tpublic static class ConditionalMessageListener {\n\n\t\t@Handler(condition = \"msg.type == 'TEST'\")\n\t\tpublic void handleTypeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleTypeMessage\");\n\t\t}\n\n\t\t@Handler(condition = \"msg.size > 4\")\n\t\tpublic void handleSizeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleSizeMessage\");\n\t\t}\n\n        @Handler(condition = \"msg.foo > 4\")\n        public void handleInvalidEL(TestEvent message) {\n            message.handledBy(\"handleInvalidEL\");\n        }\n\t\t\n\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\n\t\tpublic void handleCombinedEL(TestEvent message) {\n\t\t\tmessage.handledBy( \"handleCombinedEL\");\n\t\t}\n\t\t\n\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n\t\tpublic void handleMethodAccessEL(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\n\t\t}\n\n        @Handler(condition = \"msg.type == 'TEST'\")\n        @Enveloped(messages = {TestEvent.class, Object.class})\n        public void handleEnvelopedMessage(MessageEnvelope envelope) {\n            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\n        }\n\t\t\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleStringCondition() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"TEST\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleNumberCondition() throws Exception {\n\t\tMBassador bus = new MBassador();\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 5);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleCombinedEL() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 3);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testNotMatchingAnyCondition() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.handledBy.isEmpty());\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleMethodAccessEL() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync());\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 10000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = SyncAsync();\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        IMessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = SyncAsync();\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            track(bus.post(new Object()).asynchronously());\n        }\n\n        pause(10000);\n\n        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            error.getCause().printStackTrace();\n            Assert.fail();\n        }\n    };\n\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    public MBassador(){\n        super(new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n    }\n\n\n    public IMessagePublication publishAsync(T message) {\n        return addAsynchronousPublication(createMessagePublication(message));\n    }\n\n    public IMessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\n/**\n * Message filters can be used to control what messages are delivered to a specific message handler.\n * Filters are attached to message handler using the @Listener annotation.\n * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n * The handler will be invoked only if each filter accepted the message.\n *\n * Example:\n *\n * @Lister\n * @Filters(Urlfilter.class)\n * public void someHandler(String message){...}\n *\n * class Urlfilter implements IMessageFilter<String>{\n *     public boolean accepts(String message, MessageHandler metadata){\n *         return message.startsWith(\"http\");\n *     }\n * }\n *\n * bus.post(\"http://www.infoq.com\"); // will be delivered\n * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n *\n * NOTE: A message filter must provide a no-arg constructor!!!\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic interface IMessageFilter<M> {\n\n    /**\n     * Check the message for whatever criteria\n     *\n     * @param message the message to be handled by the handler\n     * @param  metadata the metadata object which describes the message handler\n     * @return  true: if the message matches the criteria and should be delivered to the handler\n     *          false: otherwise\n     */\n    boolean accepts(M message, MessageHandler metadata);\n}\n","src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java":"package net.engio.mbassy.bus.config;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic class ConfigurationError {\n}\n","src/main/java/net/engio/mbassy/listener/Listener.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n *\n * This annotation is meant to carry configuration that is shared among all instances of the annotated\n * listener. Supported configurations are:\n *\n *  Reference type: The bus will use either strong or weak references to its registered listeners,\n *  depending on which reference type (@see References) is set\n *\n * @author bennidi\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n@Inherited\npublic @interface Listener {\n\n    /**\n     * By default, references to message listeners are weak to eliminate risks of memory leaks.\n     * It is possible to use strong references instead.\n     *\n     * @return\n     */\n    References references() default References.Weak;\n\n}\n","src/main/java/net/engio/mbassy/bus/BusRuntime.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.error.MissingPropertyException;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n * they expose. The runtime is a container for all those dynamic properties and components and is meant to be passed around\n * between collaborating objects such that they may access the different functionality provided by the bus implementation\n * they all belong to.\n *\n * It is the responsibility of the bus implementation to create and configure the runtime according to its capabilities,\n *\n */\npublic class BusRuntime {\n\n    public static class Properties{\n\n        public static final String ErrorHandlers = \"error.handlers\";\n        public static final String AsynchronousHandlerExecutor = \"handler.async.executor\";\n\n    }\n\n    private PubSubSupport provider;\n\n    private Map<String, Object> properties = new HashMap<String, Object>();\n\n    public BusRuntime(PubSubSupport provider) {\n        this.provider = provider;\n    }\n\n    public <T> T get(String key){\n         if(!contains(key))\n             throw new MissingPropertyException(\"The property \" + key + \" is not available in this runtime\");\n         else return (T) properties.get(key);\n     }\n\n    public PubSubSupport getProvider(){\n        return provider;\n    }\n\n    public Collection<String> getKeys(){\n        return properties.keySet();\n    }\n\n    public BusRuntime add(String key, Object property){\n        properties.put(key, property);\n        return this;\n    }\n\n    public boolean contains(String key){\n        return properties.containsKey(key);\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.RuntimeProvider;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.util.Collection;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * managed by the subscription manager.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext implements RuntimeProvider {\n\n    // the handler's metadata -> for each handler in a listener, a unique subscription context is created\n    private final MessageHandler handlerMetadata;\n\n    // error handling is first-class functionality\n    private final Collection<IPublicationErrorHandler> errorHandlers;\n\n    private BusRuntime runtime;\n\n    public SubscriptionContext(BusRuntime runtime, MessageHandler handlerMetadata,\n                               Collection<IPublicationErrorHandler> errorHandlers) {\n        this.runtime = runtime;\n        this.handlerMetadata = handlerMetadata;\n        this.errorHandlers = errorHandlers;\n    }\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandler getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n    /**\n     * Get the error handlers registered with the enclosing bus.\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getErrorHandlers(){\n        return errorHandlers;\n    }\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusFactory;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus();\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus();\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                bus.post(new IncrementingMessage()).now();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus() {\n            return new MBassador();\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus() {\n            return BusFactory.SynchronousOnly();\n        }\n    }\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else Assert.fail(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/config/ConfigurationErrorHandler.java":"package net.engio.mbassy.bus.config;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic interface ConfigurationErrorHandler {\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n        try {\n            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(BusRuntime.Properties.ErrorHandlers);\n            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/BusFactory.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\n\n/**\n * The bus factory provides convenient factory methods for the most common bus use cases.\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class BusFactory {\n\n    /**\n     * Create a message bus supporting only synchronous message publication.\n     * All message publications will run in the calling thread, no bus internal\n     * multi-threading will occur.\n     *\n     * @return\n     */\n    public static SyncMessageBus SynchronousOnly(){\n        BusConfiguration syncPubSubCfg = new BusConfiguration();\n        syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n        return new SyncMessageBus(syncPubSubCfg);\n    }\n\n    /**\n     * Create a message bus supporting synchronous and asynchronous message publication.\n     * Asynchronous message publication will be handled by a single thread such that FIFO\n     * order of message processing is guaranteed.\n     *\n     *\n     * @return\n     */\n    public static IMessageBus AsynchronousSequentialFIFO(){\n        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n        return new MBassador(asyncFIFOConfig);\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Filter.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * The filter annotation is used to add filters to message listeners.\n * It references a class that implements the IMessageFilter interface.\n * The filter will be used to check whether a message should be delivered\n * to the listener or not.\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n    /**\n     * The class that implements the filter.\n     * Note: A filter always needs to provide a non-arg constructor\n     *\n     * @return\n     */\n    Class<? extends IMessageFilter> value();\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        StrongConcurrentSetTest.class,\n        WeakConcurrentSetTest.class,\n        MBassadorTest.class,\n        SyncBusTest.MBassadorTest.class,\n        SyncBusTest.SyncMessageBusTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        MethodDispatchTest.class,\n        DeadMessageTest.class,\n        SynchronizedHandlerTest.class,\n        SubscriptionManagerTest.class,\n        AsyncFIFOBusTest.class,\n        ConditionalHandlers.class\n})\npublic class AllTests {\n}\n","src/main/java/net/engio/mbassy/bus/common/IMessageBus.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.concurrent.Executor;\n\n/**\n * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n * A message publication starts when an object is send to the bus using one of the its publication methods.\n *\n * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n *\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n * in a synchronized fashion using @Synchronized annotation\n *\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n *\n * <p/>\n * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n *\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the respective message handlers.\n *\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n *\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n *\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends GenericMessagePublicationSupport<T, P>{\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    P post(T message);\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * Note: The executor can be obtained from the run time. See\n     * @return\n     */\n    @Deprecated\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return true if any unfinished message publications are found\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n\n}\n","src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java":"package net.engio.mbassy.common;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\n/**\n * Run various tests concurrently. A given instance of runnable will be used to spawn and start\n * as many threads as specified by an additional parameter or (if multiple runnables have been\n * passed to the method) one thread for each runnable.\n * <p/>\n * Date: 2/14/12\n *\n * @Author bennidi\n */\npublic class ConcurrentExecutor {\n\n\n\tpublic static void runConcurrent(final Runnable unit, int numberOfConcurrentExecutions) {\n\t\tRunnable[] units = new Runnable[numberOfConcurrentExecutions];\n\t\t// create the tasks and schedule for execution\n\t\tfor (int i = 0; i < numberOfConcurrentExecutions; i++) {\n\t\t\tunits[i] = unit;\n\t\t}\n\t\trunConcurrent(units);\n\t}\n\n\n    public static void runConcurrent(int numberOfConcurrentExecutions, final Runnable... units) {\n        Runnable[] runnables = new Runnable[numberOfConcurrentExecutions * units.length];\n        // create the tasks and schedule for execution\n        for (int i = 0; i < numberOfConcurrentExecutions; i++) {\n            for(int k = 0; k < units.length; k++)\n                runnables[k * numberOfConcurrentExecutions +i] = units[k];\n        }\n        runConcurrent(runnables);\n    }\n\n\n    public static void runConcurrent(final Runnable... units) {\n\t\tExecutorService executor = Executors.newCachedThreadPool();\n\t\tList<Future<Long>> returnValues = new ArrayList<Future<Long>>();\n\n\t\t// create the tasks and schedule for execution\n\t\tfor (final Runnable unit : units) {\n\t\t\tCallable<Long> wrapper = new Callable<Long>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Long call() throws Exception {\n\t\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\t\tunit.run();\n\t\t\t\t\treturn System.currentTimeMillis() - start;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturnValues.add(executor.submit(wrapper));\n\t\t}\n\n\n\t\t// wait until all tasks have been executed\n\t\ttry {\n\t\t\texecutor.shutdown();// tells the thread pool to execute all waiting tasks\n\t\t\texecutor.awaitTermination(5, TimeUnit.MINUTES);\n\t\t} catch (InterruptedException e) {\n\t\t\t// unlikely that this will happen\n\t\t\te.printStackTrace();\n\t\t}\n\n        for(Future task : returnValues){\n            try {\n                task.get();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n\t}\n\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n\t\tList<Method> methods = new LinkedList<Method>();\n\t\ttry {\n\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n\t\t\t\tif ( condition.apply( method ) ) {\n\t\t\t\t\tmethods.add( method );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t//nop\n\t\t}\n\t\tif ( !target.equals( Object.class ) ) {\n\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/**\n\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n\t * for an override of the given methods -> finds the bottom most override of the given\n\t * method if any exists\n\t *\n\t * @param overridingMethod\n\t * @param subclass\n\t * @return\n\t */\n\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n\t\tClass current = subclass;\n\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n\t\t\ttry {\n\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\tcurrent = current.getSuperclass();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n\tpublic static Set<Class> getSuperTypes(Class from) {\n\t\tSet<Class> superclasses = new HashSet<Class>();\n\t\tcollectInterfaces( from, superclasses );\n\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n\t\t\tsuperclasses.add( from.getSuperclass() );\n\t\t\tfrom = from.getSuperclass();\n\t\t\tcollectInterfaces( from, superclasses );\n\t\t}\n\t\treturn superclasses;\n\t}\n\n\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n\t\tfor ( Class intface : from.getInterfaces() ) {\n\t\t\taccumulator.add( intface );\n\t\t\tcollectInterfaces( intface, accumulator );\n\t\t}\n\t}\n\n\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n\t\tfor ( Method method : allMethods ) {\n\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\t/**\n\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n\t *\n\t * @param from AnnotatedElement (class, method...)\n\t * @param annotationType Annotation class to look for.\n\t * @param <A> Class of annotation type\n\t * @return Annotation instance or null\n\t */\n\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n\t\tif( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n\t}\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n\t\t// hierarchy of the given superclass method or the method names are not the same then\n\t\t// subclassMethod does not override superclassMethod\n\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n\t\t// method must specify the same number of parameters\n\t\t//the parameters must occur in the exact same order\n\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.ErrorHandlingSupport;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * A message bus implementation that offers only synchronous message publication. Using this bus\n * will not create any new threads.\n *\n */\npublic class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, SyncMessageBus.SyncPostCommand>{\n\n\n    public SyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    @Override\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements IPublicationCommand {\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread-safe container that manages exactly one message handler of all registered\n * message listeners of the same class, i.e. all subscribed instances (exlcuding subclasses) of a SingleMessageHandler.class\n * will be referenced in the subscription created for SingleMessageHandler.class.\n *\n * There will be as many unique subscription objects per message listener class as there are message handlers\n * defined in the message listeners class hierarchy.\n *\n * The subscription provides functionality for message publication by means of delegation to the respective\n * message dispatcher.\n *\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    /**\n     * Check whether this subscription manages a message handler of the given message listener class\n     *\n     * @param listener\n     * @return\n     */\n    public boolean belongsTo(Class listener){\n        return context.getHandlerMetadata().isFromListener(listener);\n    }\n\n    /**\n     * Check whether this subscriptions manages the given listener instance\n     * @param listener\n     * @return\n     */\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    /**\n     * Check whether this subscription manages a message handler\n     * @param messageType\n     * @return\n     */\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n    public Class[] getHandledMessageTypes(){\n        return context.getHandlerMetadata().getHandledMessages();\n    }\n\n\n    public void publish(IMessagePublication publication, Object message){\n        if(listeners.size() > 0)\n            dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int byPriority = ((Integer)o2.getPriority()).compareTo(o1.getPriority());\n            return byPriority == 0 ? o2.id.compareTo(o1.id) : byPriority;\n        }\n    };\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n        this.runtime = new BusRuntime(this);\n        this.runtime.add(BusRuntime.Properties.ErrorHandlers, getRegisteredErrorHandlers());\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                .createManager(pubSubFeature.getMetadataReader(),\n                        pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        synchronized (this){\n            errorHandlers.add(handler);\n        }\n    }\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends HandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler){\n        try {\n            handler.invoke(listener, message);\n        } catch (IllegalAccessException e) {\n            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        } catch (IllegalArgumentException e) {\n            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        } catch (InvocationTargetException e) {\n            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        } catch (Throwable e) {\n            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"The handler code threw an exception\",\n                            handler, listener, message));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/Feature.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.ISubscriptionManagerProvider;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManagerProvider;\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * A feature defines the configuration of a specific functionality of a message bus.\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic interface Feature {\n\n\n    class SyncPubSub implements Feature{\n\n        public static final SyncPubSub Default(){\n            return new SyncPubSub()\n                    .setMetadataReader(new MetadataReader())\n                    .setPublicationFactory(new MessagePublication.Factory())\n                    .setSubscriptionFactory(new SubscriptionFactory())\n                    .setSubscriptionManagerProvider(new SubscriptionManagerProvider());\n        }\n\n        private MessagePublication.Factory publicationFactory;\n        private MetadataReader metadataReader;\n        private SubscriptionFactory subscriptionFactory;\n        private ISubscriptionManagerProvider subscriptionManagerProvider;\n\n        public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n            return subscriptionManagerProvider;\n        }\n\n        public SyncPubSub setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n            this.subscriptionManagerProvider = subscriptionManagerProvider;\n            return this;\n        }\n\n        public SubscriptionFactory getSubscriptionFactory() {\n            return subscriptionFactory;\n        }\n\n        public SyncPubSub setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n            this.subscriptionFactory = subscriptionFactory;\n            return this;\n        }\n\n        public MetadataReader getMetadataReader() {\n            return metadataReader;\n        }\n\n        public SyncPubSub setMetadataReader(MetadataReader metadataReader) {\n            this.metadataReader = metadataReader;\n            return this;\n        }\n\n        /**\n         * The message publication factory is used to wrap a published message\n         * in a {@link MessagePublication} for processing.\n         * @return The factory to be used by the bus to create the publications\n         */\n        public MessagePublication.Factory getPublicationFactory() {\n            return publicationFactory;\n        }\n\n        public SyncPubSub setPublicationFactory(MessagePublication.Factory publicationFactory) {\n            this.publicationFactory = publicationFactory;\n            return this;\n        }\n    }\n\n    class AsynchronousHandlerInvocation implements Feature{\n\n        protected static final ThreadFactory MessageHandlerThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setName(\"AsyncHandler-\" + threadID.getAndIncrement());\n                thread.setDaemon(true);\n                return thread;\n            }\n        };\n\n        public static final AsynchronousHandlerInvocation Default(){\n            int numberOfCores = Runtime.getRuntime().availableProcessors();\n            return Default(numberOfCores, numberOfCores * 2);\n        }\n\n        public static final AsynchronousHandlerInvocation Default(int initialCoreThreads, int maximumCoreThreads){\n            int numberOfCores = Runtime.getRuntime().availableProcessors();\n            return new AsynchronousHandlerInvocation().setExecutor(new ThreadPoolExecutor(initialCoreThreads, maximumCoreThreads, 1,\n                    TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), MessageHandlerThreadFactory));\n        }\n\n        private ExecutorService executor;\n\n        public ExecutorService getExecutor() {\n            return executor;\n        }\n\n        public AsynchronousHandlerInvocation setExecutor(ExecutorService executor) {\n            this.executor = executor;\n            return this;\n        }\n    }\n\n    class AsynchronousMessageDispatch implements Feature{\n\n        protected static final ThreadFactory MessageDispatchThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setDaemon(true);// do not prevent the JVM from exiting\n                thread.setName(\"Dispatcher-\" + threadID.getAndIncrement());\n                return thread;\n            }\n        };\n\n        public static final AsynchronousMessageDispatch Default(){\n            return new AsynchronousMessageDispatch()\n                .setNumberOfMessageDispatchers(2)\n                .setDispatcherThreadFactory(MessageDispatchThreadFactory)\n                .setMessageQueue(new LinkedBlockingQueue<IMessagePublication>(Integer.MAX_VALUE));\n        }\n\n\n        private int numberOfMessageDispatchers;\n        private BlockingQueue<IMessagePublication> pendingMessages;\n        private ThreadFactory dispatcherThreadFactory;\n\n        public int getNumberOfMessageDispatchers() {\n            return numberOfMessageDispatchers;\n        }\n\n        public AsynchronousMessageDispatch setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n            this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n            return this;\n        }\n\n        public BlockingQueue<IMessagePublication> getPendingMessages() {\n            return pendingMessages;\n        }\n\n        public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<IMessagePublication> pendingMessages) {\n            this.pendingMessages = pendingMessages;\n            return this;\n        }\n\n        public ThreadFactory getDispatcherThreadFactory() {\n            return dispatcherThreadFactory;\n        }\n\n        public AsynchronousMessageDispatch setDispatcherThreadFactory(ThreadFactory dispatcherThreadFactory) {\n            this.dispatcherThreadFactory = dispatcherThreadFactory;\n            return this;\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\nimport java.util.concurrent.ExecutorService;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private final IHandlerInvocation delegate;\n\n    private final ExecutorService executor;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n        this.executor = delegate.getContext().getRuntime().get(BusRuntime.Properties.AsynchronousHandlerExecutor);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                    delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n *\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener(){\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener(){\n        ListenerFactory listeners = listeners(\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class,\n                MessagesListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener(){\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener,  sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers(){\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testPrioritizedMessageHandlers(){\n        ListenerFactory listeners = listeners(PrioritizedListener.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private BusRuntime mockedRuntime(){\n        return new BusRuntime(null)\n                .add(BusRuntime.Properties.ErrorHandlers, Collections.EMPTY_SET)\n                .add(BusRuntime.Properties.AsynchronousHandlerExecutor, null);\n    }\n\n    private ListenerFactory listeners(Class ...listeners){\n        ListenerFactory factory = new ListenerFactory();\n        for(Class listener : listeners){\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n    /**\n     *  define handlers with different priorities which need to be executed\n     *  in their respective order\n     */\n    public static class PrioritizedListener{\n\n\n        @Handler(priority = 1)\n        public void handlePrio1(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @Handler(priority = 2)\n        public void handlePrio2(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @Handler(priority = 3)\n        public void handlePrio3(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @Handler(priority = 4)\n        public void handlePrio4(IMessage message){\n            message.handled(this.getClass());\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/listener/Filters.java":"package net.engio.mbassy.listener;\n\n/**\n * A set of standard filters for common use cases.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class Filters {\n\n\n\n    /**\n     * This filter will only accept messages of the exact same type\n     * as specified for the handler. Subclasses (this includes interface implementations)\n     * will be rejected.\n     *\n     * NOTE: The same functionality (with better performance) is achieved using {@code rejectSubtypes = true}\n     * in the @Handler annotation\n     */\n    public static final class RejectSubtypes implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandler metadata) {\n            for (Class handledMessage : metadata.getHandledMessages()) {\n                if (handledMessage.equals(event.getClass())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * This filter will only accept messages that are real subtypes\n     * of the specified message types handled by the message handler.\n     * Example: If the handler handles Object.class the filter accepts\n     * all objects except any direct instance of Object.class {@code new Object()}\n     */\n    public static final class SubtypesOnly implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandler metadata) {\n            for(Class acceptedClasses : metadata.getHandledMessages()){\n                if(acceptedClasses.isAssignableFrom(message.getClass())\n                        && ! acceptedClasses.equals(message.getClass()))\n                    return true;\n            }\n            return false;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * This interface is meant to be implemented by different bus implementations to offer a consistent way\n * to plugin different flavors of message publication.\n *\n * The parametrization of the IPostCommand influences which publication flavours are available.\n *\n */\npublic interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport{\n\n    /**\n     * Publish a message to the bus using on of its supported message publication mechanisms. The supported\n     * mechanisms depend on the available implementation and are exposed as subclasses of IPublicationCommand.\n     * The standard mechanism is the synchronous dispatch which will publish the message in the current thread\n     * and returns after every matching handler has been invoked. @See IPublicationCommand.\n     *\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n}\n","src/main/java/net/engio/mbassy/bus/error/PublicationError.java":"package net.engio.mbassy.bus.error;\n\nimport net.engio.mbassy.bus.IMessagePublication;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are created when object publication fails\n * for some reason and contain details as to the cause and location\n * where they occurred.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n *         Time: 4:59 PM\n */\npublic class PublicationError{\n\n    // Internal state\n    private Throwable cause;\n    private String message;\n    private Method handler;\n    private Object listener;\n    private Object publishedObject;\n\n\n    /**\n     * Compound constructor, creating a PublicationError from the supplied objects.\n     *\n     * @param cause           The Throwable giving rise to this PublicationError.\n     * @param message         The message to send.\n     * @param handler        The method where the error was created.\n     * @param listener The object in which the PublicationError was generated.\n     * @param publishedObject The published object which gave rise to the error.\n     */\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final Method handler,\n                            final Object listener,\n                            final Object publishedObject) {\n\n        this.cause = cause;\n        this.message = message;\n        this.handler = handler;\n        this.listener = listener;\n        this.publishedObject = publishedObject;\n    }\n\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final IMessagePublication publication) {\n        this.cause = cause;\n        this.message = message;\n        this.publishedObject = publication != null ? publication.getMessage() : null;\n    }\n\n\n\n\n    /**\n     * Default constructor.\n     */\n    public PublicationError() {\n        super();\n    }\n\n    /**\n     * @return The Throwable giving rise to this PublicationError.\n     */\n    public Throwable getCause() {\n        return cause;\n    }\n\n    /**\n     * Assigns the cause of this PublicationError.\n     *\n     * @param cause A Throwable which gave rise to this PublicationError.\n     * @return This PublicationError.\n     */\n    public PublicationError setCause(Throwable cause) {\n        this.cause = cause;\n        return this;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public PublicationError setMessage(String message) {\n        this.message = message;\n        return this;\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public PublicationError setHandler(Method handler) {\n        this.handler = handler;\n        return this;\n    }\n\n    public Object getListener() {\n        return listener;\n    }\n\n    public PublicationError setListener(Object listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    public Object getPublishedObject() {\n        return publishedObject;\n    }\n\n    public PublicationError setPublishedObject(Object publishedObject) {\n        this.publishedObject = publishedObject;\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n    \tString newLine = System.getProperty(\"line.separator\");\n        return \"PublicationError{\" +\n                newLine +\n                \"\\tcause=\" + cause +\n                newLine +\n                \"\\tmessage='\" + message + '\\'' +\n                newLine +\n                \"\\thandler=\" + handler +\n                newLine +\n                \"\\tlistener=\" + listener +\n                newLine +\n                \"\\tpublishedObject=\" + publishedObject +\n                '}';\n    }\n}\n","src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport org.junit.Test;\n\nimport java.lang.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Tests a custom handler annotation with a @Handler meta annotation and a default filter.\n */\npublic class CustomHandlerAnnotationTest extends MessageBusTest\n{\n\t/**\n\t * Handler annotation that adds a default filter on the NamedMessage.\n\t * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Synchronized\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\tstatic @interface NamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n    /**\n     * Handler annotation that adds a default filter on the NamedMessage.\n     * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n     */\n    @Retention(value = RetentionPolicy.RUNTIME)\n    @Inherited\n    @NamedMessageHandler(\"messageThree\")\n    static @interface MessageThree {}\n\n\n\n\t/**\n\t * Test enveloped meta annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Enveloped(messages = NamedMessage.class)\n\tstatic @interface EnvelopedNamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n\t/**\n\t * Searches for a NamedMessageHandler annotation on the handler method.\n\t * The annotation specifies the supported message names.\n\t */\n\tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n\t{\n\t\t@Override\n\t\tpublic boolean accepts( NamedMessage message, MessageHandler metadata ) {\n\t\t\tNamedMessageHandler namedMessageHandler = metadata.getAnnotation(NamedMessageHandler.class);\n\t\t\tif ( namedMessageHandler != null ) {\n\t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n\t\t\t}\n\n\t\t\tEnvelopedNamedMessageHandler envelopedHandler = metadata.getAnnotation(EnvelopedNamedMessageHandler.class);\n\t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n\n\t\t}\n\t}\n\n\tstatic class NamedMessage\n\t{\n\t\tprivate String name;\n\n\t\tNamedMessage( String name ) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tstatic class NamedMessageListener\n\t{\n\t\tfinal Set<NamedMessage> handledByOne = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByTwo = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByThree = new HashSet<NamedMessage>();\n\n\t\t@NamedMessageHandler({ \"messageOne\", \"messageTwo\" })\n\t\tvoid handlerOne( NamedMessage message ) {\n\t\t\thandledByOne.add( message );\n\t\t}\n\n\t\t@EnvelopedNamedMessageHandler({ \"messageTwo\", \"messageThree\" })\n\t\tvoid handlerTwo( MessageEnvelope envelope ) {\n\t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n\t\t}\n\n\t\t@MessageThree\n\t\tvoid handlerThree( NamedMessage message ) {\n\t\t\thandledByThree.add( message );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMetaHandlerFiltering() {\n\t\tMBassador bus = createBus(SyncAsync());\n\n\t\tNamedMessageListener listener = new NamedMessageListener();\n\t\tbus.subscribe( listener );\n\n\t\tNamedMessage messageOne = new NamedMessage( \"messageOne\" );\n\t\tNamedMessage messageTwo = new NamedMessage( \"messageTwo\" );\n\t\tNamedMessage messageThree = new NamedMessage( \"messageThree\" );\n\n\t\tbus.publish( messageOne );\n\t\tbus.publish( messageTwo );\n\t\tbus.publish( messageThree );\n\n        assertEquals(2, listener.handledByOne.size());\n\t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n\t\tassertTrue(listener.handledByOne.contains(messageTwo));\n\n        assertEquals(2, listener.handledByTwo.size());\n\t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n\t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n\n        assertEquals(1, listener.handledByThree.size());\n\t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n\t}\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.common.ReflectionUtils;\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\nimport net.engio.mbassy.dispatch.el.ElFilter;\r\n\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n * defines such a message listener.\r\n *\r\n * @author bennidi\r\n *         Date: 11/14/12\r\n */\r\npublic class MessageHandler {\r\n\r\n    public static final class Properties{\r\n\r\n        public static final String HandlerMethod = \"handler\";\r\n        public static final String InvocationMode = \"invocationMode\";\r\n        public static final String Filter = \"filter\";\r\n        public static final String Condition = \"condition\";\r\n        public static final String Enveloped = \"envelope\";\r\n        public static final String HandledMessages = \"messages\";\r\n        public static final String IsSynchronized = \"synchronized\";\r\n        public static final String Listener = \"listener\";\r\n        public static final String AcceptSubtypes = \"subtypes\";\r\n        public static final String Priority = \"priority\";\r\n        public static final String Invocation = \"invocation\";\r\n\r\n        /**\r\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n         *\r\n         * @param handler  The handler annotated method of the listener\r\n         * @param handlerConfig The annotation that configures the handler\r\n         * @param filter   The set of preconfigured filters if any\r\n         * @param listenerConfig The listener metadata\r\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n         */\r\n        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n            if(handler == null){\r\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n            }\r\n            if(filter == null){\r\n                filter = new IMessageFilter[]{};\r\n            }\r\n            Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n            Class[] handledMessages = enveloped != null\r\n                    ? enveloped.messages()\r\n                    : handler.getParameterTypes();\r\n            handler.setAccessible(true);\r\n            Map<String, Object> properties = new HashMap<String, Object>();\r\n            properties.put(HandlerMethod, handler);\r\n            // add EL filter if a condition is present\r\n            if(handlerConfig.condition().length() > 0){\r\n                if (!ElFilter.isELAvailable()) {\r\n                    throw new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n                }\r\n\r\n                IMessageFilter[] expandedFilter = new IMessageFilter[filter.length + 1];\r\n                for(int i = 0; i < filter.length ; i++){\r\n                   expandedFilter[i] = filter[i];\r\n                }\r\n                expandedFilter[filter.length] = new ElFilter();\r\n                filter = expandedFilter;\r\n            }\r\n            properties.put(Filter, filter);\r\n            properties.put(Condition, cleanEL(handlerConfig.condition()));\r\n            properties.put(Priority, handlerConfig.priority());\r\n            properties.put(Invocation, handlerConfig.invocation());\r\n            properties.put(InvocationMode, handlerConfig.delivery());\r\n            properties.put(Enveloped, enveloped != null);\r\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n            properties.put(Listener, listenerConfig);\r\n            properties.put(IsSynchronized, ReflectionUtils.getAnnotation( handler, Synchronized.class) != null);\r\n            properties.put(HandledMessages, handledMessages);\r\n            return properties;\r\n        }\r\n\r\n        private static String cleanEL(String expression) {\r\n\r\n            if (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n                expression = \"${\"+expression+\"}\";\r\n            }\r\n            return expression;\r\n        }\r\n    }\r\n\r\n\r\n    private final Method handler;\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n\tprivate final String condition;\r\n    \r\n    private final int priority;\r\n\r\n    private final Class<? extends HandlerInvocation> invocation;\r\n\r\n    private final Invoke invocationMode;\r\n\r\n    private final boolean isEnvelope;\r\n\r\n    private final Class[] handledMessages;\r\n\r\n    private final boolean acceptsSubtypes;\r\n\r\n    private final MessageListener listenerConfig;\r\n\r\n    private final boolean isSynchronized;\r\n\r\n\r\n    public MessageHandler(Map<String, Object> properties){\r\n        super();\r\n        validate(properties);\r\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n        this.condition = (String)properties.get(Properties.Condition);\r\n        this.priority = (Integer)properties.get(Properties.Priority);\r\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n    }\r\n\r\n    private void validate(Map<String, Object> properties){\r\n        Object[][] expectedProperties = new Object[][]{\r\n                new Object[]{Properties.HandlerMethod, Method.class },\r\n                new Object[]{Properties.Priority, Integer.class },\r\n                new Object[]{Properties.Invocation, Class.class },\r\n                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n                new Object[]{Properties.Condition, String.class },\r\n                new Object[]{Properties.Enveloped, Boolean.class },\r\n                new Object[]{Properties.HandledMessages, Class[].class },\r\n                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n                new Object[]{Properties.Listener, MessageListener.class },\r\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n        };\r\n        for(Object[] property : expectedProperties){\r\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                        + \" but was: \" + properties.get(property[0]));\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public <A extends Annotation> A getAnnotation(Class<A> annotationType){\r\n        return ReflectionUtils.getAnnotation(handler,annotationType);\r\n    }\r\n\r\n    public boolean isSynchronized(){\r\n        return isSynchronized;\r\n    }\r\n\r\n    public boolean useStrongReferences(){\r\n        return listenerConfig.useStrongReferences();\r\n    }\r\n\r\n    public boolean isFromListener(Class listener){\r\n        return listenerConfig.isFromListener(listener);\r\n    }\r\n\r\n    public boolean isAsynchronous() {\r\n        return invocationMode.equals(Invoke.Asynchronously);\r\n    }\r\n\r\n    public boolean isFiltered() {\r\n        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n    }\r\n\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    public Method getHandler() {\r\n        return handler;\r\n    }\r\n\r\n    public IMessageFilter[] getFilter() {\r\n        return filter;\r\n    }\r\n    \r\n    public String getCondition() {\r\n    \treturn this.condition;\r\n    }\r\n\r\n    public Class[] getHandledMessages() {\r\n        return handledMessages;\r\n    }\r\n\r\n    public boolean isEnveloped() {\r\n        return isEnvelope;\r\n    }\r\n\r\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n        return invocation;\r\n    }\r\n\r\n    public boolean handlesMessage(Class<?> messageType) {\r\n        for (Class<?> handledMessage : handledMessages) {\r\n            if (handledMessage.equals(messageType)) {\r\n                return true;\r\n            }\r\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean acceptsSubtypes() {\r\n        return acceptsSubtypes;\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\r\n\r\nimport net.engio.mbassy.bus.IMessagePublication;\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\n\r\n/**\r\n * A dispatcher that implements message filtering based on the filter configuration\r\n * of the associated message handler. It will delegate message delivery to another\r\n * message dispatcher after having performed the filtering logic.\r\n *\r\n * @author bennidi\r\n *         Date: 11/23/12\r\n */\r\npublic final class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\r\n        super(dispatcher);\r\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\r\n    }\r\n\r\n    private boolean passesFilter(Object message) {\r\n\r\n        if (filter == null) {\r\n            return true;\r\n        } else {\r\n            for (IMessageFilter aFilter : filter) {\r\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void dispatch(IMessagePublication publication, Object message, Iterable listeners){\r\n        if (passesFilter(message)) {\r\n            getDelegate().dispatch(publication, message, listeners);\r\n        }\r\n    }\r\n\r\n}\r\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.FilteredMessage;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n    }\n\n    @Test\n    public void testSubtypesOnly(){\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(100, TestMessageHandler.class);\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage supertype = new TestMessage();\n        TestMessage subtype = new SubTestMessage();\n\n        bus.publish(supertype);\n        bus.publish(subtype);\n\n        assertEquals(100, subtype.counter.get());\n        assertEquals(0, supertype.counter.get());\n\n    }\n\n    public static class TestMessageHandler{\n\n        @Handler(filters = @Filter(Filters.SubtypesOnly.class))\n        public void handle(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandler metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandler metadata) {\n            return false;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all message bus implementations with support for asynchronous message dispatch\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends AbstractPubSubSupport<T> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<IMessagePublication> pendingMessages;\n\n    protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n\n        // configure asynchronous message dispatch\n        Feature.AsynchronousMessageDispatch asyncDispatch = configuration.getFeature(Feature.AsynchronousMessageDispatch.class);\n        pendingMessages = asyncDispatch.getPendingMessages();\n        dispatchers = new ArrayList<Thread>(asyncDispatch.getNumberOfMessageDispatchers());\n        initDispatcherThreads(asyncDispatch);\n\n        // configure asynchronous handler invocation\n        Feature.AsynchronousHandlerInvocation asyncInvocation = configuration.getFeature(Feature.AsynchronousHandlerInvocation.class);\n        this.executor = asyncInvocation.getExecutor();\n        getRuntime().add(BusRuntime.Properties.AsynchronousHandlerExecutor, executor);\n\n    }\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(Feature.AsynchronousMessageDispatch configuration) {\n        for (int i = 0; i < configuration.getNumberOfMessageDispatchers(); i++) {\n            // each thread will run forever and process incoming\n            // message publication requests\n            Thread dispatcher = configuration.getDispatcherThreadFactory().newThread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        IMessagePublication publication = null;\n                        try {\n                            publication = pendingMessages.take();\n                            publication.execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\",publication));\n                        }\n                    }\n                }\n            });\n            dispatcher.setName(\"Message dispatcher\");\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication) {\n        try {\n            pendingMessages.put(publication);\n            return publication.markScheduled();\n        } catch (InterruptedException e) {\n            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(publication, timeout, unit)\n                    ? publication.markScheduled()\n                    : publication;\n        } catch (InterruptedException e) {\n            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        shutdown();\n    }\n\n    @Override\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        if(executor != null) executor.shutdown();\n    }\n\n    @Override\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":"package net.engio.mbassy.dispatch.el;\r\n\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\nimport net.engio.mbassy.listener.MessageHandler;\r\n\r\nimport javax.el.ExpressionFactory;\r\nimport javax.el.ValueExpression;\r\n\r\n/*****************************************************************************\r\n * A filter that will use a expression from the handler annotation and \r\n * parse it as EL.\r\n ****************************************************************************/\r\n\r\npublic class ElFilter implements IMessageFilter {\r\n\r\n    // thread-safe initialization of EL factory singleton\r\n    public static final class ExpressionFactoryHolder{\r\n\r\n        // if runtime exception is thrown, this will\r\n        public static final ExpressionFactory ELFactory = getELFactory();\r\n\r\n        /*************************************************************************\r\n         * Get an implementation of the ExpressionFactory. This uses the\r\n         * Java service lookup mechanism to find a proper implementation.\r\n         * If none if available we do not support EL filters.\r\n         ************************************************************************/\r\n        private static final ExpressionFactory getELFactory(){\r\n            try {\r\n                return ExpressionFactory.newInstance();\r\n            } catch (RuntimeException e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static final boolean isELAvailable(){\r\n        return ExpressionFactoryHolder.ELFactory != null;\r\n    }\r\n\r\n    public static final ExpressionFactory ELFactory(){\r\n        return ExpressionFactoryHolder.ELFactory;\r\n    }\r\n\r\n    /**\r\n     * Accepts a message if the associated EL expression of the message handler resolves to 'true'\r\n     *\r\n     * @param message the message to be handled by the handler\r\n     * @param  metadata the metadata object which describes the message handler\r\n     * @return\r\n     */\r\n\t@Override\r\n\tpublic boolean accepts(Object message, MessageHandler metadata) {\r\n\t\tString expression = metadata.getCondition();\r\n\t\tStandardELResolutionContext context = new StandardELResolutionContext(message);\r\n\t\treturn evalExpression(expression, context);\r\n\t}\r\n\r\n\tprivate boolean evalExpression(String expression, StandardELResolutionContext context) {\r\n\t\tValueExpression ve = ELFactory().createValueExpression(context, expression, Boolean.class);\r\n\t\ttry{\r\n            Object result = ve.getValue(context);\r\n            return (Boolean)result;\r\n             }\r\n        catch(Throwable exception){\r\n            // TODO: BusRuntime should be available in this filter to propagate resolution errors\r\n            // -> this is generally a good feature for filters\r\n            return false;\r\n            //throw new IllegalStateException(\"A handler uses an EL filter but the output is not \\\"true\\\" or \\\"false\\\".\");\r\n        }\r\n\t}\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java":"package net.engio.mbassy.bus.error;\n\n/**\n * Publication error handlers are provided with a publication error every time an\n * error occurs during message publication.\n * A handler might fail with an exception, not be accessible because of the presence\n * of a security manager or other reasons might lead to failures during the message publication process.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n */\n@SuppressWarnings(\"PMD.UnusedModifier\")\npublic interface IPublicationErrorHandler {\n\n    /**\n     * Handle the given publication error.\n     *\n     * @param error The PublicationError to handle.\n     */\n    void handleError(PublicationError error);\n\n    /**\n     * The default error handler will simply log to standard out and\n     * print the stack trace if available.\n     */\n    static final class ConsoleLogger implements IPublicationErrorHandler {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void handleError(final PublicationError error) {\n\n            // Printout the error itself\n            System.out.println(error);\n\n            // Printout the stacktrace from the cause.\n            if (error.getCause() != null) {\n                error.getCause().printStackTrace();\n            }\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    // the registered features\n    private Map<Class<? extends Feature>, Feature> features = new HashMap<Class<? extends Feature>, Feature>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T)features.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        features.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public IBusConfiguration addErrorHandler(ConfigurationErrorHandler handler) {\n        return null;  // TODO: implement configuration validation\n    }\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/common/ListenerFactory.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * The factory can be used to declaratively specify how many instances of some given classes\n * should be created. It will create those instances using reflection and provide a list containing those instances.\n * The factory also holds strong references to the instances such that GC will not interfere with tests unless the\n * factory is explicitly cleared.\n *\n * @author bennidi\n *         Date: 11/22/12\n */\npublic class ListenerFactory {\n\n    private Map<Class, Integer> requiredBeans = new HashMap<Class, Integer>();\n    private volatile List generatedListeners;\n    private int requiredSize = 0;\n\n    public int getNumberOfListeners(Class listener){\n        return requiredBeans.containsKey(listener) ? requiredBeans.get(listener) : 0;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Class clazz){\n        requiredBeans.put(clazz, numberOfInstances);\n        requiredSize +=numberOfInstances;\n        return this;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Class ...classes){\n        for(Class clazz : classes)\n            create(numberOfInstances,clazz);\n        return this;\n    }\n\n    public ListenerFactory create(int numberOfInstances, Collection<Class> classes){\n        for(Class clazz : classes)\n            create(numberOfInstances,clazz);\n        return this;\n    }\n\n\n    public synchronized List<Object> getAll(){\n        if(generatedListeners != null)\n            return generatedListeners;\n        List listeners = new ArrayList(requiredSize);\n        try {\n            for(Class clazz : requiredBeans.keySet()){\n                int numberOfRequiredBeans = requiredBeans.get(clazz);\n                for(int i = 0; i < numberOfRequiredBeans; i++){\n                    listeners.add(clazz.newInstance());\n                }\n            }\n        } catch (Exception e) {\n            // if instantiation fails, counts will be incorrect\n            // -> fail early here\n            Assert.fail(\"There was a problem instantiating a listener \" + e);\n        }\n        Collections.shuffle(listeners);\n        generatedListeners  = Collections.unmodifiableList(listeners);\n        return generatedListeners;\n    }\n\n    // not thread-safe but not yet used concurrently\n    public synchronized  void clear(){\n        generatedListeners = null;\n        requiredBeans.clear();\n    }\n\n    /**\n     * Create a thread-safe read-only iterator\n     *\n     * NOTE: Iterator is not perfectly synchronized with mutator methods of the list of generated listeners\n     * In theory, it is possible that the list is changed while iterators are still running which should be avoided.\n     */\n    public Iterator iterator(){\n        getAll();\n        final AtomicInteger current = new AtomicInteger(0);\n\n        return new Iterator() {\n            @Override\n            public boolean hasNext() {\n                return current.get() < generatedListeners.size();\n            }\n\n            @Override\n            public Object next() {\n                int index =  current.getAndIncrement();\n                return index < generatedListeners.size() ? generatedListeners.get(index) : null;\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException(\"Iterator is read only\");\n            }\n        };\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":"package net.engio.mbassy.bus.config;\n\n/**\n * The configuration of message bus instances is feature driven, e.g. configuration parameters\n * are grouped into {@link Feature}.\n *\n * Features can be added to a bus configuration to be used later in the instantiation process of the message bus.\n * Each bus will look for the features it requires and configure them according to the provided configuration. If a required feature is not found the bus will publish a {@link ConfigurationError}\n * to the {@link ConfigurationErrorHandler}\n *\n * @author bennidi.\n */\npublic interface IBusConfiguration{\n\n    /**\n     * Set a property which will be read by the message bus constructor. Existing value will be overwritten.\n     * Null values are supported (checking for existence of property will return <code>true</code> even if set to <code>null</code>).\n     *\n     * @param name The name of the property. Note: Each implementation may support different properties.\n     * @param value The value of the property.\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration setProperty(String name, Object value);\n\n    /**\n     * Read a property from this configuration.\n     *\n     * @param name  The name of the property to be read.\n     * @param defaultValue  The value to be returned if property was not found\n     * @param <T>  The type of property\n     * @return The value associated with the given property name or <code>defaultValue</code> if not present\n     */\n    <T> T getProperty(String name, T defaultValue);\n\n    /**\n     * Check whether a property has been set.\n     *\n     * @return true if property was set (even if set to null)\n     *         false otherwise\n     */\n    boolean hasProperty(String name);\n\n\n    /**\n     * Get a registered feature by its type (class).\n     *\n     */\n    <T extends Feature> T getFeature(Class<T> feature);\n\n    /**\n     * Add a feature to the given configuration, replacing any existing feature of the same type.\n     *\n     * @param feature The feature to add\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration addFeature(Feature feature);\n\n    /**\n     * Add a handler that is called when a misconfiguration is detected.\n     */\n    IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler);\n\n    /**\n     * Calls all ConfigurationErrorHandlers\n     */\n    void handleError(ConfigurationError error);\n\n}\n","src/test/java/net/engio/mbassy/ConditionalHandlers.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/*****************************************************************************\n * Some unit tests for the \"condition\" filter.\n ****************************************************************************/\n\npublic class ConditionalHandlers extends MessageBusTest {\n\n\tpublic static class TestEvent {\n\n\t\tprivate Set<String> handledBy = new HashSet<String>();\n\t\tprivate String type;\n\t\tprivate int size;\n\n\t\tpublic TestEvent(String type, int size) {\n\t\t\tsuper();\n\t\t\tthis.type = type;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String getType() {\n\t\t\treturn type;\n\t\t}\n\n\t\tpublic int getSize() {\n\t\t\treturn size;\n\t\t}\n\n        public boolean wasHandledBy(String ...handlers){\n            for(String handler : handlers){\n                if (!handledBy.contains(handler)) return false;\n            }\n            return true;\n        }\n\n        public void handledBy(String handler){\n            handledBy.add(handler);\n        }\n\t\t\n\t}\n\n    @Listener(references = References.Strong)\n\tpublic static class ConditionalMessageListener {\n\n\t\t@Handler(condition = \"msg.type == 'TEST'\")\n\t\tpublic void handleTypeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleTypeMessage\");\n\t\t}\n\n\t\t@Handler(condition = \"msg.size > 4\")\n\t\tpublic void handleSizeMessage(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleSizeMessage\");\n\t\t}\n\n        @Handler(condition = \"msg.foo > 4\")\n        public void handleInvalidEL(TestEvent message) {\n            message.handledBy(\"handleInvalidEL\");\n        }\n\t\t\n\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\n\t\tpublic void handleCombinedEL(TestEvent message) {\n\t\t\tmessage.handledBy( \"handleCombinedEL\");\n\t\t}\n\t\t\n\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\n\t\tpublic void handleMethodAccessEL(TestEvent message) {\n\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\n\t\t}\n\n        @Handler(condition = \"msg.type == 'TEST'\")\n        @Enveloped(messages = {TestEvent.class, Object.class})\n        public void handleEnvelopedMessage(MessageEnvelope envelope) {\n            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\n        }\n\t\t\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleStringCondition() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync(false));\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"TEST\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\n\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testSimpleNumberCondition() throws Exception {\n\t\tMBassador bus =  createBus(SyncAsync(false));\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 5);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleCombinedEL() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync(false));\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 3);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testNotMatchingAnyCondition() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync(false));\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"\", 0);\n\t\tbus.publish(message);\n\n\t\tassertTrue(message.handledBy.isEmpty());\n\t}\n\t\n\t/*************************************************************************\n\t * @throws Exception\n\t ************************************************************************/\n\t@Test\n\tpublic void testHandleMethodAccessEL() throws Exception {\n\t\tMBassador bus = createBus(SyncAsync(false));\n\t\tbus.subscribe(new ConditionalMessageListener());\n\n\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\n\t\tbus.publish(message);\n\n        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 10000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        IMessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            track(bus.post(new Object()).asynchronously());\n        }\n\n        pause(10000);\n\n        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n\n        private boolean failOnException;\n\n        public AssertionErrorHandler(boolean failOnException) {\n            this.failOnException = failOnException;\n        }\n\n        @Override\n        public void handleError(PublicationError error) {\n            if(failOnException)\n                org.junit.Assert.fail(error.getCause().getMessage());\n        }\n    }\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return SyncAsync(true);\n    }\n\n    public static IBusConfiguration SyncAsync(boolean failOnError) {\n        return new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default())\n            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n\n\n    public MBassador(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    public MBassador(){\n        this(new BusConfiguration()\n                .addFeature(Feature.SyncPubSub.Default())\n                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n                .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n    }\n\n\n    public IMessagePublication publishAsync(T message) {\n        return addAsynchronousPublication(createMessagePublication(message));\n    }\n\n    public IMessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedMessage(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Message filters can be used to control what messages are delivered to a specific message handler.\n * Filters are attached to message handler using the @Listener annotation.\n * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n * The handler will be invoked only if each filter accepted the message.\n *\n * Example:\n *\n * {@code\n * @Lister\n * @Filters(Urlfilter.class)\n * public void someHandler(String message){...}\n *\n * class Urlfilter implements IMessageFilter<String>{\n *     public boolean accepts(String message, MessageHandler metadata){\n *         return message.startsWith(\"http\");\n *     }\n * }\n *\n * bus.post(\"http://www.infoq.com\"); // will be delivered\n * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n *\n * NOTE: A message filter must provide a no-arg constructor!!!\n * }\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic interface IMessageFilter<M> {\n\n    /**\n     * Check whether the message matches some criteria\n     *\n     * @param message The message to be handled by the handler\n     * @param  context The context object containing a description of the message handler and the bus environment\n     * @return  true: if the message matches the criteria and should be delivered to the handler\n     *          false: otherwise\n     */\n    boolean accepts(M message, SubscriptionContext context);\n}\n","src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java":"package net.engio.mbassy.bus.config;\n\n/**\n * Configuration errors represent specific misconfigurations of features in a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic class ConfigurationError {\n\n    private Class<? extends Feature> featureType;\n    private Feature feature;\n    private String message;\n\n    public ConfigurationError(Class<? extends Feature> featureType, Feature feature, String message) {\n        this.featureType = featureType;\n        this.feature = feature;\n        this.message = message;\n    }\n\n    public static ConfigurationError Missing(Class<? extends Feature> featureType){\n        return new ConfigurationError(featureType, null, \"An expected feature was missing. Use addFeature() in IBusConfiguration to add features.\");\n    }\n\n    @Override\n    public String toString() {\n        return \"Error for \" + featureType + \":\" + message +\n                \", (\" + feature + \")\";\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Listener.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n *\n * This annotation is meant to carry configuration that is shared among all instances of the annotated\n * listener. Supported configurations are:\n *\n *  Reference type: The bus will use either strong or weak references to its registered listeners,\n *  depending on which reference type (@see References) is set\n *\n * @author bennidi\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n@Inherited\npublic @interface Listener {\n\n    /**\n     * BY DEFAULT, REFERENCES to message listeners ARE WEAK to eliminate risks of memory leaks.\n     * It is possible to use strong references instead.\n     *\n     */\n    References references() default References.Weak;\n\n}\n","src/main/java/net/engio/mbassy/bus/BusRuntime.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.error.MissingPropertyException;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n * they expose. The runtime is a container for all those dynamic properties and components and is meant to be passed around\n * between collaborating objects such that they may access the different functionality provided by the bus implementation\n * they all belong to.\n *\n * It is the responsibility of the bus implementation to create and configure the runtime according to its capabilities,\n *\n */\npublic class BusRuntime {\n\n    private PubSubSupport provider;\n\n    private Map<String, Object> properties = new HashMap<String, Object>();\n\n    public BusRuntime(PubSubSupport provider) {\n        this.provider = provider;\n    }\n\n    public <T> T get(String key){\n         if(!contains(key))\n             throw new MissingPropertyException(\"The property \" + key + \" is not available in this runtime\");\n         else return (T) properties.get(key);\n     }\n\n    public PubSubSupport getProvider(){\n        return provider;\n    }\n\n    public Collection<String> getKeys(){\n        return properties.keySet();\n    }\n\n    public BusRuntime add(String key, Object property){\n        properties.put(key, property);\n        return this;\n    }\n\n    public boolean contains(String key){\n        return properties.containsKey(key);\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.RuntimeProvider;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.util.Collection;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * managed by the subscription manager.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext implements RuntimeProvider {\n\n    // the handler's metadata -> for each handler in a listener, a unique subscription context is created\n    private final MessageHandler handler;\n\n    // error handling is first-class functionality\n    private final Collection<IPublicationErrorHandler> errorHandlers;\n\n    private final BusRuntime runtime;\n\n    public SubscriptionContext(final BusRuntime runtime, final MessageHandler handler,\n                               final Collection<IPublicationErrorHandler> errorHandlers) {\n        this.runtime = runtime;\n        this.handler = handler;\n        this.errorHandlers = errorHandlers;\n    }\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     */\n    public MessageHandler getHandler() {\n        return handler;\n    }\n\n    /**\n     * Get the error handlers registered with the enclosing bus.\n     */\n    public Collection<IPublicationErrorHandler> getErrorHandlers(){\n        return errorHandlers;\n    }\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false);\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new IncrementingMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            IBusConfiguration asyncFIFOConfig = new BusConfiguration()\n                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n            return new MBassador(asyncFIFOConfig);\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            IBusConfiguration syncPubSubCfg = new BusConfiguration()\n                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n            return new SyncMessageBus(syncPubSubCfg);\n        }\n    }\n\n\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else throw new RuntimeException(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/config/ConfigurationErrorHandler.java":"package net.engio.mbassy.bus.config;\n\n/**\n * Respond to a {@link net.engio.mbassy.bus.config.ConfigurationError} with any kind of action.\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic interface ConfigurationErrorHandler {\n\n    /**\n     * Called when a misconfiguration is detected on a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n     * @param error The error that represents the detected misconfiguration.\n     */\n    void handle(ConfigurationError error);\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n        try {\n            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationError);\n            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandler().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandler().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandler().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandler().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/BusFactory.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\n\n/**\n * The bus factory provides convenient factory methods for the most common bus use cases.\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class BusFactory {\n\n    /**\n     * Create a message bus supporting only synchronous message publication.\n     * All message publications will run in the calling thread, no bus internal\n     * multi-threading will occur.\n     */\n    public static SyncMessageBus SynchronousOnly(){\n        BusConfiguration syncPubSubCfg = new BusConfiguration();\n        syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n        return new SyncMessageBus(syncPubSubCfg);\n    }\n\n    /**\n     * Create a message bus with support for synchronous and asynchronous message publication.\n     * Asynchronous message publication will be handled by a single thread such that FIFO\n     * order of message processing is guaranteed.\n     */\n    public static IMessageBus AsynchronousSequentialFIFO(){\n        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n        return new MBassador(asyncFIFOConfig);\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Filter.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * The filter annotation is used to add filters to message listeners.\n * It references a class that implements the IMessageFilter interface.\n * The filter will be used to check whether a message should be delivered\n * to the listener or not.\n *\n * @author bennidi\n *         Date: 2/14/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target(value = {ElementType.ANNOTATION_TYPE})\npublic @interface Filter {\n\n    /**\n     * The class that implements the filter.\n     * IMPORTANT: A filter always needs to provide a non-arg constructor\n     */\n    Class<? extends IMessageFilter> value();\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        StrongConcurrentSetTest.class,\n        WeakConcurrentSetTest.class,\n        SyncAsyncTest.class,\n        SyncBusTest.MBassadorTest.class,\n        SyncBusTest.SyncMessageBusTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        MethodDispatchTest.class,\n        DeadMessageTest.class,\n        SynchronizedHandlerTest.class,\n        SubscriptionManagerTest.class,\n        AsyncFIFOBusTest.class,\n        ConditionalHandlers.class\n})\npublic class AllTests {\n}\n","src/main/java/net/engio/mbassy/bus/common/IMessageBus.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\n/**\n * A message bus offers facilities for publishing messages to the message handlers of registered listeners.\n * A message publication starts when an object is send to the bus using one of the its publication methods.\n *\n * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there\n * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing\n * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.\n *\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked\n * in a synchronized fashion using @Synchronized annotation\n *\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n *\n * <p/>\n * By default, the bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.\n *\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the respective message handlers.\n *\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n *\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n *\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends GenericMessagePublicationSupport<T, P>{\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    P post(T message);\n\n    /**\n     * Check whether any asynchronous message publications are pending to be processed\n     *\n     * @return true if any unfinished message publications are found\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n\n}\n","src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java":"package net.engio.mbassy.common;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\n/**\n * Run various tests concurrently. A given instance of runnable will be used to spawn and start\n * as many threads as specified by an additional parameter or (if multiple runnables have been\n * passed to the method) one thread for each runnable.\n * <p/>\n * Date: 2/14/12\n *\n * @author bennidi\n */\npublic class ConcurrentExecutor {\n\n\n\tpublic static void runConcurrent(final Runnable unit, int numberOfConcurrentExecutions) {\n\t\tRunnable[] units = new Runnable[numberOfConcurrentExecutions];\n\t\t// create the tasks and schedule for execution\n\t\tfor (int i = 0; i < numberOfConcurrentExecutions; i++) {\n\t\t\tunits[i] = unit;\n\t\t}\n\t\trunConcurrent(units);\n\t}\n\n\n    public static void runConcurrent(int numberOfConcurrentExecutions, final Runnable... units) {\n        Runnable[] runnables = new Runnable[numberOfConcurrentExecutions * units.length];\n        // create the tasks and schedule for execution\n        for (int i = 0; i < numberOfConcurrentExecutions; i++) {\n            for(int k = 0; k < units.length; k++)\n                runnables[k * numberOfConcurrentExecutions +i] = units[k];\n        }\n        runConcurrent(runnables);\n    }\n\n\n    public static void runConcurrent(final Runnable... units) {\n\t\tExecutorService executor = Executors.newCachedThreadPool();\n\t\tList<Future<Long>> returnValues = new ArrayList<Future<Long>>();\n\n\t\t// create the tasks and schedule for execution\n\t\tfor (final Runnable unit : units) {\n\t\t\tCallable<Long> wrapper = new Callable<Long>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Long call() throws Exception {\n\t\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\t\tunit.run();\n\t\t\t\t\treturn System.currentTimeMillis() - start;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturnValues.add(executor.submit(wrapper));\n\t\t}\n\n\n\t\t// wait until all tasks have been executed\n\t\ttry {\n\t\t\texecutor.shutdown();// tells the thread pool to execute all waiting tasks\n\t\t\texecutor.awaitTermination(5, TimeUnit.MINUTES);\n\t\t} catch (InterruptedException e) {\n\t\t\t// unlikely that this will happen\n\t\t\te.printStackTrace();\n\t\t}\n\n        for(Future task : returnValues){\n            try {\n                task.get();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n\t}\n\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n\t\tList<Method> methods = new LinkedList<Method>();\n\t\ttry {\n\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n\t\t\t\tif ( condition.apply( method ) ) {\n\t\t\t\t\tmethods.add( method );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t//nop\n\t\t}\n\t\tif ( !target.equals( Object.class ) ) {\n\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/**\n\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n\t * for an override of the given methods -> finds the bottom most override of the given\n\t * method if any exists\n\t *\n\t * @param overridingMethod\n\t * @param subclass\n\t */\n\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n\t\tClass current = subclass;\n\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n\t\t\ttry {\n\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\tcurrent = current.getSuperclass();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n\tpublic static Set<Class> getSuperTypes(Class from) {\n\t\tSet<Class> superclasses = new HashSet<Class>();\n\t\tcollectInterfaces( from, superclasses );\n\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n\t\t\tsuperclasses.add( from.getSuperclass() );\n\t\t\tfrom = from.getSuperclass();\n\t\t\tcollectInterfaces( from, superclasses );\n\t\t}\n\t\treturn superclasses;\n\t}\n\n\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n\t\tfor ( Class intface : from.getInterfaces() ) {\n\t\t\taccumulator.add( intface );\n\t\t\tcollectInterfaces( intface, accumulator );\n\t\t}\n\t}\n\n\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n\t\tfor ( Method method : allMethods ) {\n\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\t/**\n\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n\t *\n\t * @param from AnnotatedElement (class, method...)\n\t * @param annotationType Annotation class to look for.\n\t * @param <A> Class of annotation type\n\t * @return Annotation instance or null\n\t */\n\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n\t\tif( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n\t}\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n\t\t// hierarchy of the given superclass method or the method names are not the same then\n\t\t// subclassMethod does not override superclassMethod\n\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n\t\t// method must specify the same number of parameters\n\t\t//the parameters must occur in the exact same order\n\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.ErrorHandlingSupport;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * A message bus implementation that offers only synchronous message publication. Using this bus\n * will not create any new threads.\n *\n */\npublic class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, SyncMessageBus.SyncPostCommand>{\n\n\n    public SyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    @Override\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedMessage(message));\n        }\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements IPublicationCommand {\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread-safe container that manages exactly one message handler of all registered\n * message listeners of the same class, i.e. all subscribed instances (exlcuding subclasses) of a SingleMessageHandler.class\n * will be referenced in the subscription created for SingleMessageHandler.class.\n *\n * There will be as many unique subscription objects per message listener class as there are message handlers\n * defined in the message listeners class hierarchy.\n *\n * The subscription provides functionality for message publication by means of delegation to the respective\n * message dispatcher.\n *\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n    /**\n     * Check whether this subscription manages a message handler of the given listener class.\n     */\n    public boolean belongsTo(Class listener){\n        return context.getHandler().isFromListener(listener);\n    }\n\n    /**\n     * Check whether this subscriptions manages the given listener instance.\n     */\n    public boolean contains(Object listener){\n        return listeners.contains(listener);\n    }\n\n    /**\n     * Check whether this subscription manages a specific message type.\n     */\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandler().handlesMessage(messageType);\n    }\n\n    public Class[] getHandledMessageTypes(){\n        return context.getHandler().getHandledMessages();\n    }\n\n\n    public void publish(IMessagePublication publication, Object message){\n        if(listeners.size() > 0)\n            dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandler().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int byPriority = ((Integer)o2.getPriority()).compareTo(o1.getPriority());\n            return byPriority == 0 ? o2.id.compareTo(o1.id) : byPriority;\n        }\n    };\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.*;\n\nimport static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n        if(!configuration.hasProperty(Properties.Handler.PublicationError)){\n            System.out.println(\"WARN: No error handler configured to handle exceptions during publication.\\n\" +\n                    \"Error handlers can be added to any instance of  AbstractPubSubSupport or via BusConfiguration. \\n\" +\n                    \"Falling back to console logger.\");\n        }\n        this.errorHandlers.add(configuration.getProperty(Properties.Handler.PublicationError, new IPublicationErrorHandler.ConsoleLogger()));\n        this.runtime = new BusRuntime(this)\n            .add(PublicationError, getRegisteredErrorHandlers())\n            .add(Properties.Common.Id, UUID.randomUUID().toString());\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                .createManager(pubSubFeature.getMetadataReader(),\n                        pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        synchronized (this){\n            errorHandlers.add(handler);\n        }\n    }\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends HandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler){\n        try {\n            handler.invoke(listener, message);\n        } catch (IllegalAccessException e) {\n            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        } catch (IllegalArgumentException e) {\n            handlePublicationError(new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        } catch (InvocationTargetException e) {\n            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        } catch (Throwable e) {\n            handlePublicationError( new PublicationError(e, \"Error during invocation of message handler. \" +\n                            \"The handler code threw an exception\",\n                            handler, listener, message));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        invokeHandler(message, listener, getContext().getHandler().getMethod());\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/Feature.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.ISubscriptionManagerProvider;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManagerProvider;\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * A feature defines the configuration of a specific functionality of a message bus.\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic interface Feature {\n\n\n    class SyncPubSub implements Feature{\n\n        public static final SyncPubSub Default(){\n            return new SyncPubSub()\n                    .setMetadataReader(new MetadataReader())\n                    .setPublicationFactory(new MessagePublication.Factory())\n                    .setSubscriptionFactory(new SubscriptionFactory())\n                    .setSubscriptionManagerProvider(new SubscriptionManagerProvider());\n        }\n\n        private MessagePublication.Factory publicationFactory;\n        private MetadataReader metadataReader;\n        private SubscriptionFactory subscriptionFactory;\n        private ISubscriptionManagerProvider subscriptionManagerProvider;\n\n        public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n            return subscriptionManagerProvider;\n        }\n\n        public SyncPubSub setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n            this.subscriptionManagerProvider = subscriptionManagerProvider;\n            return this;\n        }\n\n        public SubscriptionFactory getSubscriptionFactory() {\n            return subscriptionFactory;\n        }\n\n        public SyncPubSub setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n            this.subscriptionFactory = subscriptionFactory;\n            return this;\n        }\n\n        public MetadataReader getMetadataReader() {\n            return metadataReader;\n        }\n\n        public SyncPubSub setMetadataReader(MetadataReader metadataReader) {\n            this.metadataReader = metadataReader;\n            return this;\n        }\n\n        /**\n         * The message publication factory is used to wrap a published message\n         * in a {@link MessagePublication} for processing.\n         * @return The factory to be used by the bus to create the publications\n         */\n        public MessagePublication.Factory getPublicationFactory() {\n            return publicationFactory;\n        }\n\n        public SyncPubSub setPublicationFactory(MessagePublication.Factory publicationFactory) {\n            this.publicationFactory = publicationFactory;\n            return this;\n        }\n    }\n\n    class AsynchronousHandlerInvocation implements Feature{\n\n        protected static final ThreadFactory MessageHandlerThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setName(\"AsyncHandler-\" + threadID.getAndIncrement());\n                thread.setDaemon(true);\n                return thread;\n            }\n        };\n\n        public static final AsynchronousHandlerInvocation Default(){\n            int numberOfCores = Runtime.getRuntime().availableProcessors();\n            return Default(numberOfCores, numberOfCores * 2);\n        }\n\n        public static final AsynchronousHandlerInvocation Default(int minThreadCount, int maxThreadCount){\n            return new AsynchronousHandlerInvocation().setExecutor(new ThreadPoolExecutor(minThreadCount, maxThreadCount, 1,\n                    TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), MessageHandlerThreadFactory));\n        }\n\n        private ExecutorService executor;\n\n        public ExecutorService getExecutor() {\n            return executor;\n        }\n\n        public AsynchronousHandlerInvocation setExecutor(ExecutorService executor) {\n            this.executor = executor;\n            return this;\n        }\n    }\n\n    class AsynchronousMessageDispatch implements Feature{\n\n        protected static final ThreadFactory MessageDispatchThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setDaemon(true);// do not prevent the JVM from exiting\n                thread.setName(\"Dispatcher-\" + threadID.getAndIncrement());\n                return thread;\n            }\n        };\n\n        public static final AsynchronousMessageDispatch Default(){\n            return new AsynchronousMessageDispatch()\n                .setNumberOfMessageDispatchers(2)\n                .setDispatcherThreadFactory(MessageDispatchThreadFactory)\n                .setMessageQueue(new LinkedBlockingQueue<IMessagePublication>(Integer.MAX_VALUE));\n        }\n\n\n        private int numberOfMessageDispatchers;\n        private BlockingQueue<IMessagePublication> pendingMessages;\n        private ThreadFactory dispatcherThreadFactory;\n\n        public int getNumberOfMessageDispatchers() {\n            return numberOfMessageDispatchers;\n        }\n\n        public AsynchronousMessageDispatch setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n            this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n            return this;\n        }\n\n        public BlockingQueue<IMessagePublication> getPendingMessages() {\n            return pendingMessages;\n        }\n\n        public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<IMessagePublication> pendingMessages) {\n            this.pendingMessages = pendingMessages;\n            return this;\n        }\n\n        public ThreadFactory getDispatcherThreadFactory() {\n            return dispatcherThreadFactory;\n        }\n\n        public AsynchronousMessageDispatch setDispatcherThreadFactory(ThreadFactory dispatcherThreadFactory) {\n            this.dispatcherThreadFactory = dispatcherThreadFactory;\n            return this;\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\nimport java.util.concurrent.ExecutorService;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private final IHandlerInvocation delegate;\n\n    private final ExecutorService executor;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n        this.executor = delegate.getContext().getRuntime().get(Properties.Handler.AsynchronousHandlerExecutor);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                    delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n *\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener(){\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener(){\n        ListenerFactory listeners = listeners(\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class,\n                MessagesListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener(){\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesListener.DefaultListener.class,\n                MessagesListener.AsyncListener.class,\n                MessagesListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener,  sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers(){\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testPrioritizedMessageHandlers(){\n        ListenerFactory listeners = listeners(PrioritizedListener.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private BusRuntime mockedRuntime(){\n        return new BusRuntime(null)\n                .add(Properties.Handler.PublicationError, Collections.EMPTY_SET)\n                .add(Properties.Handler.AsynchronousHandlerExecutor, null);\n    }\n\n    private ListenerFactory listeners(Class ...listeners){\n        ListenerFactory factory = new ListenerFactory();\n        for(Class listener : listeners){\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n    /**\n     *  define handlers with different priorities which need to be executed\n     *  in their respective order\n     */\n    public static class PrioritizedListener{\n\n\n        @net.engio.mbassy.listener.Handler(priority = 1)\n        public void handlePrio1(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 2)\n        public void handlePrio2(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 3)\n        public void handlePrio3(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 4)\n        public void handlePrio4(IMessage message){\n            message.handled(this.getClass());\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/listener/Filters.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * A set of standard filters for common use cases.\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class Filters {\n\n\n\n    /**\n     * This filter will only accept messages of the exact same type\n     * as specified for the handler. Subclasses (this includes interface implementations)\n     * will be rejected.\n     *\n     * NOTE: The same functionality (with better performance) is achieved using {@code rejectSubtypes = true}\n     * in the @Handler annotation\n     */\n    public static final class RejectSubtypes implements IMessageFilter {\n\n        @Override\n        public boolean accepts(final Object event, final SubscriptionContext context) {\n            final MessageHandler metadata = context.getHandler();\n            for (Class handledMessage : metadata.getHandledMessages()) {\n                if (handledMessage.equals(event.getClass())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * This filter will only accept messages that are real subtypes\n     * of the specified message types handled by the message handler.\n     * Example: If the handler handles Object.class the filter accepts\n     * all objects except any direct instance of Object.class {@code new Object()}\n     */\n    public static final class SubtypesOnly implements IMessageFilter{\n\n        @Override\n        public boolean accepts(final Object message, final SubscriptionContext context) {\n            final MessageHandler metadata = context.getHandler();\n            for(Class acceptedClasses : metadata.getHandledMessages()){\n                if(acceptedClasses.isAssignableFrom(message.getClass())\n                        && ! acceptedClasses.equals(message.getClass()))\n                    return true;\n            }\n            return false;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * This interface is meant to be implemented by different bus implementations to offer a consistent way\n * to plugin different methods of message publication.\n *\n * The parametrization of the IPostCommand influences which publication methods (asynchronous, synchronous or\n * conditional etc.) are available.\n *\n */\npublic interface GenericMessagePublicationSupport<T, P extends IPublicationCommand> extends PubSubSupport<T>, ErrorHandlingSupport{\n\n    /**\n     * Publish a message to the bus using on of its supported message publication mechanisms. The supported\n     * mechanisms depend on the available implementation and are exposed as subclasses of IPublicationCommand.\n     * The standard mechanism is the synchronous dispatch which will publish the message in the current thread\n     * and returns after every matching handler has been invoked.\n     *\n     * @param message - Any subtype of T welcome\n     * @return An object that provides access to the available publication methods supported by the message bus.\n     */\n    P post(T message);\n\n}\n","src/main/java/net/engio/mbassy/bus/error/PublicationError.java":"package net.engio.mbassy.bus.error;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are created when object publication fails\n * for some reason and contain details as to the cause and location\n * where they occurred.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n *         Time: 4:59 PM\n */\npublic class PublicationError{\n\n    // Internal state\n    private Throwable cause;\n    private String message;\n    private Method handler;\n    private Object listener;\n    private Object publishedMessage;\n\n\n    /**\n     * Compound constructor, creating a PublicationError from the supplied objects.\n     *\n     * @param cause           The Throwable giving rise to this PublicationError.\n     * @param message         The message to send.\n     * @param handler        The method where the error was created.\n     * @param listener The object in which the PublicationError was generated.\n     * @param publishedObject The published object which gave rise to the error.\n     */\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final Method handler,\n                            final Object listener,\n                            final Object publishedObject) {\n\n        this.cause = cause;\n        this.message = message;\n        this.handler = handler;\n        this.listener = listener;\n        this.publishedMessage = publishedObject;\n    }\n\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final IMessagePublication publication) {\n        this.cause = cause;\n        this.message = message;\n        this.publishedMessage = publication != null ? publication.getMessage() : null;\n    }\n\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final SubscriptionContext context) {\n        this.cause = cause;\n        this.message = message;\n        this.handler = context.getHandler().getMethod();\n    }\n\n\n    /**\n     * Default constructor.\n     */\n    public PublicationError() {\n        super();\n    }\n\n    /**\n     * @return The Throwable giving rise to this PublicationError.\n     */\n    public Throwable getCause() {\n        return cause;\n    }\n\n    /**\n     * Assigns the cause of this PublicationError.\n     *\n     * @param cause A Throwable which gave rise to this PublicationError.\n     * @return This PublicationError.\n     */\n    public PublicationError setCause(Throwable cause) {\n        this.cause = cause;\n        return this;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public PublicationError setMessage(String message) {\n        this.message = message;\n        return this;\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public PublicationError setHandler(Method handler) {\n        this.handler = handler;\n        return this;\n    }\n\n    public Object getListener() {\n        return listener;\n    }\n\n    public PublicationError setListener(Object listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    public Object getPublishedMessage() {\n        return publishedMessage;\n    }\n\n    public PublicationError setPublishedMessage(Object publishedMessage) {\n        this.publishedMessage = publishedMessage;\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n    \tString newLine = System.getProperty(\"line.separator\");\n        return \"PublicationError{\" +\n                newLine +\n                \"\\tcause=\" + cause +\n                newLine +\n                \"\\tmessage='\" + message + '\\'' +\n                newLine +\n                \"\\thandler=\" + handler +\n                newLine +\n                \"\\tlistener=\" + listener +\n                newLine +\n                \"\\tpublishedMessage=\" + publishedMessage +\n                '}';\n    }\n}\n","src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport org.junit.Test;\n\nimport java.lang.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Tests a custom handler annotation with a @Handler meta annotation and a default filter.\n */\npublic class CustomHandlerAnnotationTest extends MessageBusTest\n{\n\t/**\n\t * Handler annotation that adds a default filter on the NamedMessage.\n\t * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Synchronized\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\tstatic @interface NamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n    /**\n     * Handler annotation that adds a default filter on the NamedMessage.\n     * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n     */\n    @Retention(value = RetentionPolicy.RUNTIME)\n    @Inherited\n    @NamedMessageHandler(\"messageThree\")\n    static @interface MessageThree {}\n\n\n\n\t/**\n\t * Test enveloped meta annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Enveloped(messages = NamedMessage.class)\n\tstatic @interface EnvelopedNamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n\t/**\n\t * Searches for a NamedMessageHandler annotation on the handler method.\n\t * The annotation specifies the supported message names.\n\t */\n\tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n\t{\n\t\t@Override\n\t\tpublic boolean accepts( NamedMessage message,  SubscriptionContext context ) {\n            MessageHandler handler = context.getHandler();\n\t\t\tNamedMessageHandler namedMessageHandler = handler.getAnnotation(NamedMessageHandler.class);\n\t\t\tif ( namedMessageHandler != null ) {\n\t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n\t\t\t}\n\n\t\t\tEnvelopedNamedMessageHandler envelopedHandler = handler.getAnnotation(EnvelopedNamedMessageHandler.class);\n\t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n\n\t\t}\n\t}\n\n\tstatic class NamedMessage\n\t{\n\t\tprivate String name;\n\n\t\tNamedMessage( String name ) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tstatic class NamedMessageListener\n\t{\n\t\tfinal Set<NamedMessage> handledByOne = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByTwo = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByThree = new HashSet<NamedMessage>();\n\n\t\t@NamedMessageHandler({ \"messageOne\", \"messageTwo\" })\n\t\tvoid handlerOne( NamedMessage message ) {\n\t\t\thandledByOne.add( message );\n\t\t}\n\n\t\t@EnvelopedNamedMessageHandler({ \"messageTwo\", \"messageThree\" })\n\t\tvoid handlerTwo( MessageEnvelope envelope ) {\n\t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n\t\t}\n\n\t\t@MessageThree\n\t\tvoid handlerThree( NamedMessage message ) {\n\t\t\thandledByThree.add( message );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMetaHandlerFiltering() {\n\t\tMBassador bus = createBus(SyncAsync());\n\n\t\tNamedMessageListener listener = new NamedMessageListener();\n\t\tbus.subscribe( listener );\n\n\t\tNamedMessage messageOne = new NamedMessage( \"messageOne\" );\n\t\tNamedMessage messageTwo = new NamedMessage( \"messageTwo\" );\n\t\tNamedMessage messageThree = new NamedMessage( \"messageThree\" );\n\n\t\tbus.publish( messageOne );\n\t\tbus.publish( messageTwo );\n\t\tbus.publish( messageThree );\n\n        assertEquals(2, listener.handledByOne.size());\n\t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n\t\tassertTrue(listener.handledByOne.contains(messageTwo));\n\n        assertEquals(2, listener.handledByTwo.size());\n\t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n\t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n\n        assertEquals(1, listener.handledByThree.size());\n\t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n\t}\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.common.ReflectionUtils;\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\nimport net.engio.mbassy.dispatch.el.ElFilter;\r\n\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n * defines such a message listener.\r\n *\r\n * @author bennidi\r\n *         Date: 11/14/12\r\n */\r\npublic class MessageHandler {\r\n\r\n    public static final class Properties{\r\n\r\n        public static final String HandlerMethod = \"handler\";\r\n        public static final String InvocationMode = \"invocationMode\";\r\n        public static final String Filter = \"filter\";\r\n        public static final String Condition = \"condition\";\r\n        public static final String Enveloped = \"envelope\";\r\n        public static final String HandledMessages = \"messages\";\r\n        public static final String IsSynchronized = \"synchronized\";\r\n        public static final String Listener = \"listener\";\r\n        public static final String AcceptSubtypes = \"subtypes\";\r\n        public static final String Priority = \"priority\";\r\n        public static final String Invocation = \"invocation\";\r\n\r\n        /**\r\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n         *\r\n         * @param handler  The handler annotated method of the listener\r\n         * @param handlerConfig The annotation that configures the handler\r\n         * @param filter   The set of preconfigured filters if any\r\n         * @param listenerConfig The listener metadata\r\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n         *         {@link MessageHandler} constructor.\r\n         */\r\n        public static final Map<String, Object> Create(Method handler,\r\n                                                       Handler handlerConfig,\r\n                                                       IMessageFilter[] filter,\r\n                                                       MessageListener listenerConfig){\r\n            if(handler == null){\r\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n            }\r\n            if(filter == null){\r\n                filter = new IMessageFilter[]{};\r\n            }\r\n            Enveloped enveloped = ReflectionUtils.getAnnotation( handler, Enveloped.class );\r\n            Class[] handledMessages = enveloped != null\r\n                    ? enveloped.messages()\r\n                    : handler.getParameterTypes();\r\n            handler.setAccessible(true);\r\n            Map<String, Object> properties = new HashMap<String, Object>();\r\n            properties.put(HandlerMethod, handler);\r\n            // add EL filter if a condition is present\r\n            if(handlerConfig.condition().length() > 0){\r\n                if (!ElFilter.isELAvailable()) {\r\n                    throw new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n                }\r\n\r\n                IMessageFilter[] expandedFilter = new IMessageFilter[filter.length + 1];\r\n                for(int i = 0; i < filter.length ; i++){\r\n                   expandedFilter[i] = filter[i];\r\n                }\r\n                expandedFilter[filter.length] = new ElFilter();\r\n                filter = expandedFilter;\r\n            }\r\n            properties.put(Filter, filter);\r\n            properties.put(Condition, cleanEL(handlerConfig.condition()));\r\n            properties.put(Priority, handlerConfig.priority());\r\n            properties.put(Invocation, handlerConfig.invocation());\r\n            properties.put(InvocationMode, handlerConfig.delivery());\r\n            properties.put(Enveloped, enveloped != null);\r\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n            properties.put(Listener, listenerConfig);\r\n            properties.put(IsSynchronized, ReflectionUtils.getAnnotation( handler, Synchronized.class) != null);\r\n            properties.put(HandledMessages, handledMessages);\r\n            return properties;\r\n        }\r\n\r\n        private static String cleanEL(String expression) {\r\n\r\n            if (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n                expression = \"${\"+expression+\"}\";\r\n            }\r\n            return expression;\r\n        }\r\n    }\r\n\r\n\r\n    private final Method handler;\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n\tprivate final String condition;\r\n    \r\n    private final int priority;\r\n\r\n    private final Class<? extends HandlerInvocation> invocation;\r\n\r\n    private final Invoke invocationMode;\r\n\r\n    private final boolean isEnvelope;\r\n\r\n    private final Class[] handledMessages;\r\n\r\n    private final boolean acceptsSubtypes;\r\n\r\n    private final MessageListener listenerConfig;\r\n\r\n    private final boolean isSynchronized;\r\n\r\n\r\n    public MessageHandler(Map<String, Object> properties){\r\n        super();\r\n        validate(properties);\r\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n        this.condition = (String)properties.get(Properties.Condition);\r\n        this.priority = (Integer)properties.get(Properties.Priority);\r\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n    }\r\n\r\n    private void validate(Map<String, Object> properties){\r\n        // define expected types of known properties\r\n        Object[][] expectedProperties = new Object[][]{\r\n                new Object[]{Properties.HandlerMethod, Method.class },\r\n                new Object[]{Properties.Priority, Integer.class },\r\n                new Object[]{Properties.Invocation, Class.class },\r\n                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n                new Object[]{Properties.Condition, String.class },\r\n                new Object[]{Properties.Enveloped, Boolean.class },\r\n                new Object[]{Properties.HandledMessages, Class[].class },\r\n                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n                new Object[]{Properties.Listener, MessageListener.class },\r\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n        };\r\n        // ensure types match\r\n        for(Object[] property : expectedProperties){\r\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                        + \" but was: \" + properties.get(property[0]));\r\n        }\r\n    }\r\n\r\n    public <A extends Annotation> A getAnnotation(Class<A> annotationType){\r\n        return ReflectionUtils.getAnnotation(handler,annotationType);\r\n    }\r\n\r\n    public boolean isSynchronized(){\r\n        return isSynchronized;\r\n    }\r\n\r\n    public boolean useStrongReferences(){\r\n        return listenerConfig.useStrongReferences();\r\n    }\r\n\r\n    public boolean isFromListener(Class listener){\r\n        return listenerConfig.isFromListener(listener);\r\n    }\r\n\r\n    public boolean isAsynchronous() {\r\n        return invocationMode.equals(Invoke.Asynchronously);\r\n    }\r\n\r\n    public boolean isFiltered() {\r\n        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n    }\r\n\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    public Method getMethod() {\r\n        return handler;\r\n    }\r\n\r\n    public IMessageFilter[] getFilter() {\r\n        return filter;\r\n    }\r\n    \r\n    public String getCondition() {\r\n    \treturn this.condition;\r\n    }\r\n\r\n    public Class[] getHandledMessages() {\r\n        return handledMessages;\r\n    }\r\n\r\n    public boolean isEnveloped() {\r\n        return isEnvelope;\r\n    }\r\n\r\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n        return invocation;\r\n    }\r\n\r\n    public boolean handlesMessage(Class<?> messageType) {\r\n        for (Class<?> handledMessage : handledMessages) {\r\n            if (handledMessage.equals(messageType)) {\r\n                return true;\r\n            }\r\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean acceptsSubtypes() {\r\n        return acceptsSubtypes;\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\r\n\r\nimport net.engio.mbassy.bus.IMessagePublication;\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\n\r\n/**\r\n * A dispatcher that implements message filtering based on the filter configuration\r\n * of the associated message handler. It will delegate message delivery to another\r\n * message dispatcher after having performed the filtering logic.\r\n *\r\n * @author bennidi\r\n *         Date: 11/23/12\r\n */\r\npublic final class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\r\n        super(dispatcher);\r\n        this.filter = dispatcher.getContext().getHandler().getFilter();\r\n    }\r\n\r\n    private boolean passesFilter(Object message) {\r\n\r\n        if (filter == null) {\r\n            return true;\r\n        } else {\r\n            for (IMessageFilter aFilter : filter) {\r\n                if (!aFilter.accepts(message, getContext())) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void dispatch(IMessagePublication publication, Object message, Iterable listeners){\r\n        if (passesFilter(message)) {\r\n            getDelegate().dispatch(publication, message, listeners);\r\n        }\r\n    }\r\n\r\n}\r\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.FilteredMessage;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.messages.SubTestMessage;\nimport net.engio.mbassy.messages.TestMessage;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.getAll();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n    }\n\n    @Test\n    public void testSubtypesOnly(){\n        MBassador bus = createBus(SyncAsync());\n        ListenerFactory listeners = new ListenerFactory()\n                .create(100, TestMessageHandler.class);\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage supertype = new TestMessage();\n        TestMessage subtype = new SubTestMessage();\n\n        bus.publish(supertype);\n        bus.publish(subtype);\n\n        assertEquals(100, subtype.counter.get());\n        assertEquals(0, supertype.counter.get());\n\n    }\n\n    public static class TestMessageHandler{\n\n        @Handler(filters = @Filter(Filters.SubtypesOnly.class))\n        public void handle(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, SubscriptionContext context) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n    public static final class RejectAll implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event,  SubscriptionContext context) {\n            return false;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.config.ConfigurationError;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all message bus implementations with support for asynchronous message dispatch\n *\n * @param <T> The type of message this bus consumes\n * @param <P> The publication commands this bus supports depend on P\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends AbstractPubSubSupport<T> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<IMessagePublication> pendingMessages;\n\n    protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n\n        // configure asynchronous message dispatch\n        Feature.AsynchronousMessageDispatch asyncDispatch = configuration.getFeature(Feature.AsynchronousMessageDispatch.class);\n        if(asyncDispatch == null){\n            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousMessageDispatch.class));\n        }\n        pendingMessages = asyncDispatch.getPendingMessages();\n        dispatchers = new ArrayList<Thread>(asyncDispatch.getNumberOfMessageDispatchers());\n        initDispatcherThreads(asyncDispatch);\n\n        // configure asynchronous handler invocation\n        Feature.AsynchronousHandlerInvocation asyncInvocation = configuration.getFeature(Feature.AsynchronousHandlerInvocation.class);\n        if(asyncInvocation == null){\n            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousHandlerInvocation.class));\n        }\n        this.executor = asyncInvocation.getExecutor();\n        getRuntime().add(Properties.Handler.AsynchronousHandlerExecutor, executor);\n\n    }\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(Feature.AsynchronousMessageDispatch configuration) {\n        for (int i = 0; i < configuration.getNumberOfMessageDispatchers(); i++) {\n            // each thread will run forever and process incoming\n            // message publication requests\n            Thread dispatcher = configuration.getDispatcherThreadFactory().newThread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        IMessagePublication publication = null;\n                        try {\n                            publication = pendingMessages.take();\n                            publication.execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\",publication));\n                        }\n                    }\n                }\n            });\n            dispatcher.setName(\"Message dispatcher\");\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication) {\n        try {\n            pendingMessages.put(publication);\n            return publication.markScheduled();\n        } catch (InterruptedException e) {\n            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(publication, timeout, unit)\n                    ? publication.markScheduled()\n                    : publication;\n        } catch (InterruptedException e) {\n            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        shutdown();\n    }\n\n    @Override\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        if(executor != null) executor.shutdown();\n    }\n\n    @Override\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":"package net.engio.mbassy.dispatch.el;\r\n\r\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\r\nimport net.engio.mbassy.bus.error.PublicationError;\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\nimport net.engio.mbassy.listener.MessageHandler;\r\nimport net.engio.mbassy.subscription.SubscriptionContext;\r\n\r\nimport javax.el.ExpressionFactory;\r\nimport javax.el.ValueExpression;\r\n\r\n/**\r\n * A filter that will use a expression from the handler annotation and\r\n * parse it as EL.\r\n * <p/>\r\n * Accepts a message if the associated EL expression evaluates to <code>true</code>\r\n */\r\npublic class ElFilter implements IMessageFilter {\r\n\r\n    // thread-safe initialization of EL factory singleton\r\n    public static final class ExpressionFactoryHolder {\r\n\r\n        // if runtime exception is thrown, this will\r\n        public static final ExpressionFactory ELFactory = getELFactory();\r\n\r\n        /**\r\n         * **********************************************************************\r\n         * Get an implementation of the ExpressionFactory. This uses the\r\n         * Java service lookup mechanism to find a proper implementation.\r\n         * If none is available we do not support EL filters.\r\n         * **********************************************************************\r\n         */\r\n        private static final ExpressionFactory getELFactory() {\r\n            try {\r\n                return ExpressionFactory.newInstance();\r\n            } catch (RuntimeException e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static final boolean isELAvailable() {\r\n        return ExpressionFactoryHolder.ELFactory != null;\r\n    }\r\n\r\n    public static final ExpressionFactory ELFactory() {\r\n        return ExpressionFactoryHolder.ELFactory;\r\n    }\r\n\r\n\r\n    @Override\r\n    public boolean accepts(Object message, final SubscriptionContext context) {\r\n        final MessageHandler metadata = context.getHandler();\r\n        String expression = metadata.getCondition();\r\n        StandardELResolutionContext resolutionContext = new StandardELResolutionContext(message);\r\n        return evalExpression(expression, resolutionContext, context, message);\r\n    }\r\n\r\n    private boolean evalExpression(final String expression,\r\n                                   final StandardELResolutionContext resolutionContext,\r\n                                   final SubscriptionContext context,\r\n                                   final Object message) {\r\n        ValueExpression ve = ELFactory().createValueExpression(resolutionContext, expression, Boolean.class);\r\n        try {\r\n            Object result = ve.getValue(resolutionContext);\r\n            return (Boolean) result;\r\n        } catch (Throwable exception) {\r\n            PublicationError publicationError = new PublicationError(exception, \"Error while evaluating EL expression on message\", context)\r\n                    .setPublishedMessage(message);\r\n            for (IPublicationErrorHandler errorHandler : context.getErrorHandlers()) {\r\n                errorHandler.handleError(publicationError);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java":"package net.engio.mbassy.bus.error;\n\n/**\n * Publication error handlers are provided with a publication error every time an\n * error occurs during message publication.\n * A handler might fail with an exception, not be accessible because of the presence\n * of a security manager or other reasons might lead to failures during the message publication process.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n */\n@SuppressWarnings(\"PMD.UnusedModifier\")\npublic interface IPublicationErrorHandler {\n\n    /**\n     * Handle the given publication error.\n     *\n     * @param error The PublicationError to handle.\n     */\n    void handleError(PublicationError error);\n\n    /**\n     * The default error handler will simply log to standard out and\n     * print the stack trace if available.\n     */\n    static final class ConsoleLogger implements IPublicationErrorHandler {\n\n        private final boolean printStackTrace;\n\n        public ConsoleLogger() {\n            this(false);\n        }\n\n        public ConsoleLogger(boolean printStackTrace) {\n            this.printStackTrace = printStackTrace;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void handleError(final PublicationError error) {\n\n            // Printout the error itself\n            System.out.println(error);\n\n            // Printout the stacktrace from the cause.\n            if (printStackTrace && error.getCause() != null) {\n                error.getCause().printStackTrace();\n            }\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    // the registered properties\n    private final Map<Object, Object> properties = new HashMap<Object, Object>();\n    private final List<ConfigurationErrorHandler> errorHandlerList = new LinkedList<ConfigurationErrorHandler>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public IBusConfiguration setProperty(String name, Object value) {\n        properties.put(name, value);\n        return this;\n    }\n\n    @Override\n    public <T> T getProperty(String name, T defaultValue) {\n        return properties.containsKey(name) ? (T) properties.get(name) : defaultValue;\n    }\n\n    @Override\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T) properties.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        properties.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler) {\n        errorHandlerList.add(handler);\n        return this;\n    }\n\n    @Override\n    public void handleError(ConfigurationError error) {\n        for(ConfigurationErrorHandler errorHandler : errorHandlerList){\n            errorHandler.handle(error);\n        }\n    }\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/common/ListenerFactory.java":[[78,78]],"src/test/java/net/engio/mbassy/common/MessageBusTest.java":[[64,64],[58,58],[50,53]],"src/test/java/net/engio/mbassy/ConditionalHandlers.java":[[112,112]],"src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":[[18,18],[19,19],[20,20]],"src/main/java/net/engio/mbassy/bus/MBassador.java":[[50,50],[20,23]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[212,212],[217,217],[222,222],[203,203],[227,227]],"src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":[[29,29],[32,32],[48,48]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[48,48],[51,51],[37,37],[40,40],[23,23],[58,58]],"src/main/java/net/engio/mbassy/bus/BusFactory.java":[[20,20],[29,29],[34,34]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[44,44]],"src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":[[31,31]],"src/main/java/net/engio/mbassy/subscription/Subscription.java":[[49,49],[50,50],[51,51],[39,39],[41,41],[42,42],[45,45],[58,58],[59,59],[60,60],[63,63],[77,77],[67,67]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[36,36],[37,37]],"src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":[[49,49]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[256,256],[251,251],[266,266],[217,217],[218,218],[261,261]],"src/main/java/net/engio/mbassy/bus/config/Feature.java":[[99,99],[100,100],[101,101]],"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[23,23]],"src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java":[[18,18]],"src/main/java/net/engio/mbassy/bus/error/PublicationError.java":[[46,46],[137,137],[54,54]],"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[44,44]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[20,20],[29,29]],"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[46,46]],"src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":[[25,25]],"src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java":[[39,39]],"src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":[[20,20],[25,25]]},"postChangeRange":{"src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":[[49,49]],"src/test/java/net/engio/mbassy/ConditionalHandlers.java":[[156,156],[142,142],[112,112],[96,96],[127,127]],"src/test/java/net/engio/mbassy/common/MessageBusTest.java":[[55,55]],"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":[[32,32],[60,60]],"src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":[[50,55]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[256,256],[251,251],[266,266],[217,217],[218,218],[261,261]],"src/main/java/net/engio/mbassy/bus/config/Feature.java":[[99,99],[100,100]],"src/main/java/net/engio/mbassy/bus/MBassador.java":[[51,51],[21,24]],"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[23,23]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[223,223],[228,228],[119,119],[153,153],[233,233],[214,214],[93,93],[42,42],[238,238]],"src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":[[29,29],[30,30],[32,32]],"src/main/java/net/engio/mbassy/bus/common/GenericMessagePublicationSupport.java":[[19,19],[21,21],[22,22]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[49,49],[52,52],[38,38],[41,41],[24,24],[59,59]],"src/main/java/net/engio/mbassy/bus/error/PublicationError.java":[[47,47],[144,144],[55,55]],"src/main/java/net/engio/mbassy/bus/BusFactory.java":[[27,27]],"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[44,44]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[20,20],[29,29]],"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[40,42],[49,51],[53,53]],"src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":[[31,31]],"src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":[[27,27],[30,30],[31,31]],"src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java":[[49,49]],"src/main/java/net/engio/mbassy/subscription/Subscription.java":[[46,46],[39,39],[42,42],[53,53],[56,56],[70,70],[60,60]],"src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":[[39,39],[44,44]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[36,40],[41,41],[42,44]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java","startLine":36,"endLine":36}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java","startLine":40,"endLine":40}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java","startLine":49,"endLine":49}]},{"type":"AddAdditionalCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java","startLine":49,"endLine":49}]}],"refactorings":[{"type":"\"Rename Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":48,"endLine":48},{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":51,"endLine":51}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":49,"endLine":49},{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":52,"endLine":52}]},{"type":"\"Rename Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":37,"endLine":37},{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":40,"endLine":40}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":38,"endLine":38},{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":41,"endLine":41}]}]},{"repository":"mbassador","sha1":"c5715acdd65c9be3cc4313579f027e2b55b37cd6","url":"https://github.com/bennidi/mbassador/commit/c5715acdd65c9be3cc4313579f027e2b55b37cd6","preChangeSourceCode":{"src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport java.util.Collection;\n\nimport net.engio.mbassy.common.StrongConcurrentSet;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class StrongConcurrentSetTest extends ConcurrentSetTest{\n\n    @Override\n    protected Collection createSet() {\n        return new StrongConcurrentSet();\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.Collection;\n\n/**\n * The configuration of message bus instances is feature driven, e.g. configuration parameters\n * are grouped into {@link Feature}.\n *\n * Features can be added to a bus configuration to be used later in the instantiation process of the message bus.\n * Each bus will look for the features it requires and configure them according to the provided configuration. If a required feature is not found the bus will publish a {@link ConfigurationError}\n * to the {@link ConfigurationErrorHandler}\n *\n * @author bennidi.\n */\npublic interface IBusConfiguration{\n\n    /**\n     * Set a property which will be read by the message bus constructor. Existing value will be overwritten.\n     * Null values are supported (checking for existence of property will return <code>true</code> even if set to <code>null</code>).\n     *\n     * @param name The name of the property. Note: Each implementation may support different properties.\n     * @param value The value of the property.\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration setProperty(String name, Object value);\n\n    /**\n     * Read a property from this configuration.\n     *\n     * @param name  The name of the property to be read.\n     * @param defaultValue  The value to be returned if property was not found\n     * @param <T>  The type of property\n     * @return The value associated with the given property name or <code>defaultValue</code> if not present\n     */\n    <T> T getProperty(String name, T defaultValue);\n\n    /**\n     * Check whether a property has been set.\n     *\n     * @return true if property was set (even if set to null)\n     *         false otherwise\n     */\n    boolean hasProperty(String name);\n\n\n    /**\n     * Get a registered feature by its type (class).\n     *\n     */\n    <T extends Feature> T getFeature(Class<T> feature);\n\n    /**\n     * Add a feature to the given configuration, replacing any existing feature of the same type.\n     *\n     * @param feature The feature to add\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration addFeature(Feature feature);\n\n    /**\n     * Add a handler that is called when a misconfiguration is detected.\n     * Note: Not fully implemented, yet.\n     */\n    IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler);\n\n    /**\n     * Calls all ConfigurationErrorHandlers\n     */\n    void handleError(ConfigurationError error);\n\n    BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler);\n\n    Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers();\n\n\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 1000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        IMessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            track(bus.post(new Object()).asynchronously());\n        }\n\n        // Check the handlers processing status\n        // Define timeframe in which processing should be finished\n        // If not then an error is assumed\n        long timeElapsed = 0;\n        long timeOut = 30000; // 30 seconds\n        long begin =  System.currentTimeMillis();\n        while (timeElapsed < timeOut) {\n            boolean successful = true;\n            for (SynchronizedWithAsynchronousDelivery handler : handlers) {\n                successful &= incrementsPerMessage * numberOfMessages ==  handler.counter;\n            }\n            if(successful)\n                break;\n            timeElapsed = System.currentTimeMillis() - begin;\n        }\n        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n\n    }\n\n\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/Feature.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.ISubscriptionManagerProvider;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManagerProvider;\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * A feature defines the configuration of a specific functionality of a message bus.\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic interface Feature {\n\n\n    class SyncPubSub implements Feature{\n\n        public static final SyncPubSub Default(){\n            return new SyncPubSub()\n                    .setMetadataReader(new MetadataReader())\n                    .setPublicationFactory(new MessagePublication.Factory())\n                    .setSubscriptionFactory(new SubscriptionFactory())\n                    .setSubscriptionManagerProvider(new SubscriptionManagerProvider());\n        }\n\n        private MessagePublication.Factory publicationFactory;\n        private MetadataReader metadataReader;\n        private SubscriptionFactory subscriptionFactory;\n        private ISubscriptionManagerProvider subscriptionManagerProvider;\n\n        public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n            return subscriptionManagerProvider;\n        }\n\n        public SyncPubSub setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n            this.subscriptionManagerProvider = subscriptionManagerProvider;\n            return this;\n        }\n\n        public SubscriptionFactory getSubscriptionFactory() {\n            return subscriptionFactory;\n        }\n\n        public SyncPubSub setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n            this.subscriptionFactory = subscriptionFactory;\n            return this;\n        }\n\n        public MetadataReader getMetadataReader() {\n            return metadataReader;\n        }\n\n        public SyncPubSub setMetadataReader(MetadataReader metadataReader) {\n            this.metadataReader = metadataReader;\n            return this;\n        }\n\n        /**\n         * The message publication factory is used to wrap a published message\n         * in a {@link MessagePublication} for processing.\n         * @return The factory to be used by the bus to create the publications\n         */\n        public MessagePublication.Factory getPublicationFactory() {\n            return publicationFactory;\n        }\n\n        public SyncPubSub setPublicationFactory(MessagePublication.Factory publicationFactory) {\n            this.publicationFactory = publicationFactory;\n            return this;\n        }\n    }\n\n    class AsynchronousHandlerInvocation implements Feature{\n\n        protected static final ThreadFactory MessageHandlerThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setName(\"AsyncHandler-\" + threadID.getAndIncrement());\n                thread.setDaemon(true);\n                return thread;\n            }\n        };\n\n        public static final AsynchronousHandlerInvocation Default(){\n            int numberOfCores = Runtime.getRuntime().availableProcessors();\n            return Default(numberOfCores, numberOfCores * 2);\n        }\n\n        public static final AsynchronousHandlerInvocation Default(int minThreadCount, int maxThreadCount){\n            return new AsynchronousHandlerInvocation().setExecutor(new ThreadPoolExecutor(minThreadCount, maxThreadCount, 1,\n                    TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), MessageHandlerThreadFactory));\n        }\n\n        private ExecutorService executor;\n\n        public ExecutorService getExecutor() {\n            return executor;\n        }\n\n        public AsynchronousHandlerInvocation setExecutor(ExecutorService executor) {\n            this.executor = executor;\n            return this;\n        }\n    }\n\n    class AsynchronousMessageDispatch implements Feature{\n\n        protected static final ThreadFactory MessageDispatchThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setDaemon(true);// do not prevent the JVM from exiting\n                thread.setName(\"Dispatcher-\" + threadID.getAndIncrement());\n                return thread;\n            }\n        };\n\n        public static final AsynchronousMessageDispatch Default(){\n            return new AsynchronousMessageDispatch()\n                .setNumberOfMessageDispatchers(2)\n                .setDispatcherThreadFactory(MessageDispatchThreadFactory)\n                .setMessageQueue(new LinkedBlockingQueue<IMessagePublication>(Integer.MAX_VALUE));\n        }\n\n\n        private int numberOfMessageDispatchers;\n        private BlockingQueue<IMessagePublication> pendingMessages;\n        private ThreadFactory dispatcherThreadFactory;\n\n        public int getNumberOfMessageDispatchers() {\n            return numberOfMessageDispatchers;\n        }\n\n        public AsynchronousMessageDispatch setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n            this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n            return this;\n        }\n\n        public BlockingQueue<IMessagePublication> getPendingMessages() {\n            return pendingMessages;\n        }\n\n        public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<IMessagePublication> pendingMessages) {\n            this.pendingMessages = pendingMessages;\n            return this;\n        }\n\n        public ThreadFactory getDispatcherThreadFactory() {\n            return dispatcherThreadFactory;\n        }\n\n        public AsynchronousMessageDispatch setDispatcherThreadFactory(ThreadFactory dispatcherThreadFactory) {\n            this.dispatcherThreadFactory = dispatcherThreadFactory;\n            return this;\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n * @author dorkbox\n *         Date: 22/2/15\n */\npublic abstract class AbstractConcurrentSet<T> implements Set<T> {\n    private static final AtomicLong id = new AtomicLong();\n    private final long ID = id.getAndIncrement();\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(1) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public boolean add(T element) {\n        if (element == null) return false;\n        Lock writeLock = lock.writeLock();\n        boolean changed;\n        try {\n            writeLock.lock();\n            changed = insert(element);\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean contains(Object element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n\n    /**\n     * Inserts a new element at the head of the set.\n     * Note: This method is expected to be synchronized by the calling code\n     */\n    private boolean insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> elements) {\n        boolean changed = false;\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    changed |= insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean remove(Object element) {\n        if (!contains(element)) {\n            // return quickly\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    // if it was second, now it's first\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        return this.entries.entrySet().toArray();\n    }\n\n    @SuppressWarnings(\"hiding\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return this.entries.entrySet().toArray(a);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public void clear() {\n        Lock writeLock = this.lock.writeLock();\n        try {\n            writeLock.lock();\n                head = null;\n                entries.clear();\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"rawtypes\")\n        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n        if (this.ID != other.ID) {\n            return false;\n        }\n        return true;\n    }\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // Not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // Can not nullify references to help GC because running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\nimport java.util.concurrent.ExecutorService;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private final IHandlerInvocation delegate;\n\n    private final ExecutorService executor;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n        this.executor = delegate.getContext().getRuntime().get(Properties.Handler.AsynchronousHandlerExecutor);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                    delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Message filters can be used to control what messages are delivered to a specific message handler.\n * Filters are attached to message handler using the @Listener annotation.\n * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n * The handler will be invoked only if each filter accepted the message.\n *\n * Example:\n *\n * <pre>\n * <code>\n * {@literal @}Listener\n * {@literal @}Filters(Urlfilter.class)\n * public void someHandler(String message){...}\n *\n * class Urlfilter implements IMessageFilter<String>{\n *     public boolean accepts(String message, MessageHandler metadata){\n *         return message.startsWith(\"http\");\n *     }\n * }\n *\n * bus.post(\"http://www.infoq.com\"); // will be delivered\n * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n *\n * </code>\n * </pre>\n *\n * NOTE: A message filter must provide a no-arg constructor!!!\n *\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic interface IMessageFilter<M> {\n\n    /**\n     * Check whether the message matches some criteria\n     *\n     * @param message The message to be handled by the handler\n     * @param  context The context object containing a description of the message handler and the bus environment\n     * @return  true: if the message matches the criteria and should be delivered to the handler\n     *          false: otherwise\n     */\n    boolean accepts(M message, SubscriptionContext context);\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n *\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener(){\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener(){\n        ListenerFactory listeners = listeners(\n                MessagesTypeListener.DefaultListener.class,\n                MessagesTypeListener.AsyncListener.class,\n                MessagesTypeListener.DisabledListener.class,\n                MessagesTypeListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesTypeListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesTypeListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesTypeListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener(){\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener(){\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners(){\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesTypeListener.DefaultListener.class,\n                MessagesTypeListener.AsyncListener.class,\n                MessagesTypeListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesTypeListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesTypeListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for(Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener,  sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers(){\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testPrioritizedMessageHandlers(){\n        ListenerFactory listeners = listeners(PrioritizedListener.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private BusRuntime mockedRuntime(){\n        return new BusRuntime(null)\n                .add(Properties.Handler.PublicationErrorHandlers, Collections.EMPTY_SET)\n                .add(Properties.Handler.AsynchronousHandlerExecutor, null);\n    }\n\n    private ListenerFactory listeners(Class ...listeners){\n        ListenerFactory factory = new ListenerFactory();\n        for(Class listener : listeners){\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n    /**\n     *  define handlers with different priorities which need to be executed\n     *  in their respective order\n     */\n    public static class PrioritizedListener{\n\n\n        @net.engio.mbassy.listener.Handler(priority = 1)\n        public void handlePrio1(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 2)\n        public void handlePrio2(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 3)\n        public void handlePrio3(IMessage message){\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 4)\n        public void handlePrio4(IMessage message){\n            message.handled(this.getClass());\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/CustomInvocationListener.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\nimport net.engio.mbassy.messages.StandardMessage;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * @author bennidi\n *         Date: 5/25/13\n */\n@Listener(references = References.Strong)\npublic class CustomInvocationListener {\n\n\n    // this handler will be invoked asynchronously\n    @Handler(invocation = HandleSubTestEventInvocation.class)\n    public void handle(StandardMessage message) {\n        message.handled(this.getClass());\n        message.handled(this.getClass());\n    }\n\n    public static class HandleSubTestEventInvocation extends HandlerInvocation<CustomInvocationListener, StandardMessage> {\n\n        public HandleSubTestEventInvocation(SubscriptionContext context) {\n            super(context);\n        }\n\n        @Override\n        public void invoke(CustomInvocationListener listener, StandardMessage message) {\n            listener.handle(message);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java":"package net.engio.mbassy.bus.config;\n\n/**\n * Configuration errors represent specific misconfigurations of features in a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic class ConfigurationError {\n\n    private Class<? extends Feature> featureType;\n    private Feature feature;\n    private String message;\n\n    public ConfigurationError(Class<? extends Feature> featureType, Feature feature, String message) {\n        this.featureType = featureType;\n        this.feature = feature;\n        this.message = message;\n    }\n\n    public static ConfigurationError Missing(Class<? extends Feature> featureType){\n        return new ConfigurationError(featureType, null, \"An expected feature was missing. Use addFeature() in IBusConfiguration to add features.\");\n    }\n\n    @Override\n    public String toString() {\n        return \"Error for \" + featureType + \":\" + message +\n                \", (\" + feature + \")\";\n    }\n}\n","src/main/java/net/engio/mbassy/bus/BusRuntime.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.error.MissingPropertyException;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n * they expose. The runtime is a container for all those dynamic properties and components and is meant to be passed around\n * between collaborating objects such that they may access the different functionality provided by the bus implementation\n * they all belong to.\n *\n * It is the responsibility of the bus implementation to create and configure the runtime according to its capabilities,\n *\n */\npublic class BusRuntime {\n\n    private PubSubSupport provider;\n\n    private Map<String, Object> properties = new HashMap<String, Object>();\n\n    public BusRuntime(PubSubSupport provider) {\n        this.provider = provider;\n        properties.put(Properties.Common.Id, UUID.randomUUID().toString());\n    }\n\n    public <T> T get(String key){\n         if(!contains(key))\n             throw new MissingPropertyException(\"The property \" + key + \" is not available in this runtime\");\n         else return (T) properties.get(key);\n     }\n\n    public PubSubSupport getProvider(){\n        return provider;\n    }\n\n    public Collection<String> getKeys(){\n        return properties.keySet();\n    }\n\n    public BusRuntime add(String key, Object property){\n        properties.put(key, property);\n        return this;\n    }\n\n    public boolean contains(String key){\n        return properties.containsKey(key);\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesTypeListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesTypeListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesTypeListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: modified to pass ExceptionCounter via the configuration object\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n        exceptionCount.set(0); // reset for next test\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new IncrementingMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n        //DS: added errorHandler parameter to allow adding handler from caller\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n            if (errorHandler != null) {\n                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);\n            }\n            return new MBassador(asyncFIFOConfig);\n\n        }\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n            if (errorHandler != null) {\n                syncPubSubCfg.addPublicationErrorHandler(errorHandler);\n            }\n            return new SyncMessageBus(syncPubSubCfg);\n        }\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n    }\n\n\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else throw new RuntimeException(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n        try {\n            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationErrorHandlers);\n            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandler().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandler().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandler().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandler().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/error/PublicationError.java":"package net.engio.mbassy.bus.error;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are created when object publication fails\n * for some reason and contain details as to the cause and location\n * where they occurred.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n *         Time: 4:59 PM\n */\npublic class PublicationError{\n\n    // Internal state\n    private Throwable cause;\n    private String message;\n    private Method handler;\n    private Object listener;\n    private Object publishedMessage;\n\n\n    /**\n     * Compound constructor, creating a PublicationError from the supplied objects.\n     *\n     * @param cause           The Throwable giving rise to this PublicationError.\n     * @param message         The message to send.\n     * @param handler        The method where the error was created.\n     * @param listener The object in which the PublicationError was generated.\n     * @param publishedObject The published object which gave rise to the error.\n     */\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final Method handler,\n                            final Object listener,\n                            final Object publishedObject) {\n\n        this.cause = cause;\n        this.message = message;\n        this.handler = handler;\n        this.listener = listener;\n        this.publishedMessage = publishedObject;\n    }\n\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final IMessagePublication publication) {\n        this.cause = cause;\n        this.message = message;\n        this.publishedMessage = publication != null ? publication.getMessage() : null;\n    }\n\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final SubscriptionContext context) {\n        this.cause = cause;\n        this.message = message;\n        this.handler = context.getHandler().getMethod();\n    }\n\n\n    /**\n     * Default constructor.\n     */\n    public PublicationError() {\n        super();\n    }\n\n    /**\n     * @return The Throwable giving rise to this PublicationError.\n     */\n    public Throwable getCause() {\n        return cause;\n    }\n\n    /**\n     * Assigns the cause of this PublicationError.\n     *\n     * @param cause A Throwable which gave rise to this PublicationError.\n     * @return This PublicationError.\n     */\n    public PublicationError setCause(Throwable cause) {\n        this.cause = cause;\n        return this;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public PublicationError setMessage(String message) {\n        this.message = message;\n        return this;\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public PublicationError setHandler(Method handler) {\n        this.handler = handler;\n        return this;\n    }\n\n    public Object getListener() {\n        return listener;\n    }\n\n    public PublicationError setListener(Object listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    public Object getPublishedMessage() {\n        return publishedMessage;\n    }\n\n    public PublicationError setPublishedMessage(Object publishedMessage) {\n        this.publishedMessage = publishedMessage;\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n    \tString newLine = System.getProperty(\"line.separator\");\n        return \"PublicationError{\" +\n                newLine +\n                \"\\tcause=\" + cause +\n                newLine +\n                \"\\tmessage='\" + message + '\\'' +\n                newLine +\n                \"\\thandler=\" + handler +\n                newLine +\n                \"\\tlistener=\" + listener +\n                newLine +\n                \"\\tpublishedMessage=\" + publishedMessage +\n                '}';\n    }\n}\n","src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport org.junit.Test;\n\nimport java.lang.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Tests a custom handler annotation with a @Handler meta annotation and a default filter.\n */\npublic class CustomHandlerAnnotationTest extends MessageBusTest\n{\n\t/**\n\t * Handler annotation that adds a default filter on the NamedMessage.\n\t * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Synchronized\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\tstatic @interface NamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n    /**\n     * Handler annotation that adds a default filter on the NamedMessage.\n     * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n     */\n    @Retention(value = RetentionPolicy.RUNTIME)\n    @Inherited\n    @NamedMessageHandler(\"messageThree\")\n    static @interface MessageThree {}\n\n\n\n\t/**\n\t * Test enveloped meta annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Enveloped(messages = NamedMessage.class)\n\tstatic @interface EnvelopedNamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n\t/**\n\t * Searches for a NamedMessageHandler annotation on the handler method.\n\t * The annotation specifies the supported message names.\n\t */\n\tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n\t{\n\t\t@Override\n\t\tpublic boolean accepts( NamedMessage message,  SubscriptionContext context ) {\n            MessageHandler handler = context.getHandler();\n\t\t\tNamedMessageHandler namedMessageHandler = handler.getAnnotation(NamedMessageHandler.class);\n\t\t\tif ( namedMessageHandler != null ) {\n\t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n\t\t\t}\n\n\t\t\tEnvelopedNamedMessageHandler envelopedHandler = handler.getAnnotation(EnvelopedNamedMessageHandler.class);\n\t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n\n\t\t}\n\t}\n\n\tstatic class NamedMessage\n\t{\n\t\tprivate String name;\n\n\t\tNamedMessage( String name ) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tstatic class NamedMessageListener\n\t{\n\t\tfinal Set<NamedMessage> handledByOne = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByTwo = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByThree = new HashSet<NamedMessage>();\n\n\t\t@NamedMessageHandler({ \"messageOne\", \"messageTwo\" })\n\t\tvoid handlerOne( NamedMessage message ) {\n\t\t\thandledByOne.add( message );\n\t\t}\n\n\t\t@EnvelopedNamedMessageHandler({ \"messageTwo\", \"messageThree\" })\n\t\tvoid handlerTwo( MessageEnvelope envelope ) {\n\t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n\t\t}\n\n\t\t@MessageThree\n\t\tvoid handlerThree( NamedMessage message ) {\n\t\t\thandledByThree.add( message );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMetaHandlerFiltering() {\n\t\tMBassador bus = createBus(SyncAsync());\n\n\t\tNamedMessageListener listener = new NamedMessageListener();\n\t\tbus.subscribe( listener );\n\n\t\tNamedMessage messageOne = new NamedMessage( \"messageOne\" );\n\t\tNamedMessage messageTwo = new NamedMessage( \"messageTwo\" );\n\t\tNamedMessage messageThree = new NamedMessage( \"messageThree\" );\n\n\t\tbus.publish( messageOne );\n\t\tbus.publish( messageTwo );\n\t\tbus.publish( messageThree );\n\n        assertEquals(2, listener.handledByOne.size());\n\t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n\t\tassertTrue(listener.handledByOne.contains(messageTwo));\n\n        assertEquals(2, listener.handledByTwo.size());\n\t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n\t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n\n        assertEquals(1, listener.handledByThree.size());\n\t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n\t}\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.config.ConfigurationError;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all message bus implementations with support for asynchronous message dispatch\n *\n * @param <T> The type of message this bus consumes\n * @param <P> The publication commands this bus supports depend on P\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends AbstractPubSubSupport<T> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<IMessagePublication> pendingMessages;\n\n    protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n\n        // configure asynchronous message dispatch\n        Feature.AsynchronousMessageDispatch asyncDispatch = configuration.getFeature(Feature.AsynchronousMessageDispatch.class);\n        if(asyncDispatch == null){\n            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousMessageDispatch.class));\n        }\n        pendingMessages = asyncDispatch.getPendingMessages();\n        dispatchers = new ArrayList<Thread>(asyncDispatch.getNumberOfMessageDispatchers());\n        initDispatcherThreads(asyncDispatch);\n\n        // configure asynchronous handler invocation\n        Feature.AsynchronousHandlerInvocation asyncInvocation = configuration.getFeature(Feature.AsynchronousHandlerInvocation.class);\n        if(asyncInvocation == null){\n            configuration.handleError(ConfigurationError.Missing(Feature.AsynchronousHandlerInvocation.class));\n        }\n        this.executor = asyncInvocation.getExecutor();\n        getRuntime().add(Properties.Handler.AsynchronousHandlerExecutor, executor);\n\n    }\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(Feature.AsynchronousMessageDispatch configuration) {\n        for (int i = 0; i < configuration.getNumberOfMessageDispatchers(); i++) {\n            // each thread will run forever and process incoming\n            // message publication requests\n            Thread dispatcher = configuration.getDispatcherThreadFactory().newThread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        IMessagePublication publication = null;\n                        try {\n                            publication = pendingMessages.take();\n                            publication.execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new PublicationError(t, \"Error in asynchronous dispatch\",publication));\n                        }\n                    }\n                }\n            });\n            dispatcher.setName(\"MsgDispatcher-\"+i);\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication) {\n        try {\n            pendingMessages.put(publication);\n            return publication.markScheduled();\n        } catch (InterruptedException e) {\n            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(publication, timeout, unit)\n                    ? publication.markScheduled()\n                    : publication;\n        } catch (InterruptedException e) {\n            handlePublicationError(new PublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        shutdown();\n    }\n\n    @Override\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        if(executor != null) executor.shutdown();\n    }\n\n    @Override\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.createAndTrack(\n                        StandardMessage.class,\n                        InstancesPerListener,\n                        Listeners.join(Listeners.asynchronous(),Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(\n                        MultipartMessage.class,\n                        InstancesPerListener,\n                        IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesTypeListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(waitForMessageTimeout);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: Exception counter added via config\n        IBusConfiguration config = SyncAsync(false)\n            .addPublicationErrorHandler(ExceptionCounter);\n\n        final MBassador bus = new MBassador(config);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable asynchronousPublication = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).asynchronously();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java":"package net.engio.mbassy.bus.error;\n\n/**\n * Publication error handlers are provided with a publication error every time an\n * error occurs during message publication.\n * A handler might fail with an exception, not be accessible because of the presence\n * of a security manager or other reasons might lead to failures during the message publication process.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n */\n@SuppressWarnings(\"PMD.UnusedModifier\")\npublic interface IPublicationErrorHandler {\n\n    /**\n     * Handle the given publication error.\n     *\n     * @param error The PublicationError to handle.\n     */\n    void handleError(PublicationError error);\n\n    /**\n     * The default error handler will simply log to standard out and\n     * print the stack trace if available.\n     */\n    static final class ConsoleLogger implements IPublicationErrorHandler {\n\n        private final boolean printStackTrace;\n\n        public ConsoleLogger() {\n            this(false);\n        }\n\n        public ConsoleLogger(boolean printStackTrace) {\n            this.printStackTrace = printStackTrace;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void handleError(final PublicationError error) {\n\n            // Printout the error itself\n            System.out.println(error);\n\n            // Printout the stacktrace from the cause.\n            if (printStackTrace && error.getCause() != null) {\n                error.getCause().printStackTrace();\n            }\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.*;\n\n/**\n * {@inheritDoc}\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    // the registered properties\n    private final Map<Object, Object> properties = new HashMap<Object, Object>();\n    private final List<ConfigurationErrorHandler> configurationErrorHandlers = new LinkedList<ConfigurationErrorHandler>();\n    // these are transferred to the bus to receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> publicationErrorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public IBusConfiguration setProperty(String name, Object value) {\n        properties.put(name, value);\n        return this;\n    }\n\n    @Override\n    public <T> T getProperty(String name, T defaultValue) {\n        return properties.containsKey(name) ? (T) properties.get(name) : defaultValue;\n    }\n\n    @Override\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T) properties.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        properties.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler) {\n        configurationErrorHandlers.add(handler);\n        return this;\n    }\n\n    @Override\n    public void handleError(ConfigurationError error) {\n        for(ConfigurationErrorHandler errorHandler : configurationErrorHandlers){\n            errorHandler.handle(error);\n        }\n    }\n\n@Override\n    public final BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler) {\n            publicationErrorHandlers.add(handler);\n    return this;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers() {\n        return Collections.unmodifiableCollection(publicationErrorHandlers);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.*;\n\nimport static net.engio.mbassy.bus.common.Properties.Handler.PublicationErrorHandlers;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n    public static final String ERROR_HANDLER_MSG = \"INFO: No error handler has been configured to handle exceptions during publication.\\n\" +\n            \"Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\\n\" +\n            \"Falling back to console logger.\";\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n        //transfer publication error handlers from the config object\n        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());\n        if (errorHandlers.isEmpty()) {\n            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n            System.out.println(ERROR_HANDLER_MSG);\n        }\n        this.runtime = new BusRuntime(this)\n                .add(PublicationErrorHandlers, configuration.getRegisteredPublicationErrorHandlers());\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n                                                                          .equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    protected void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n    }\n}\n","src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.BusFactory;\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class AsyncFIFOBusTest extends MessageBusTest {\n\n    @Test\n    public void testSingleThreadedSyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncListener> listeners = new LinkedList<SyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncListener listener = new SyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n             messages[i] = i;\n        }\n        // publish in ascending order\n        for(Integer message : messages)\n            fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages())\n            pause(1000);\n\n        for(SyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            for(int i=0; i < messages.length; i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n            }\n        }\n\n    }\n\n    // NOTE: Can fail due to timing issues.\n    @Test\n    public void testSingleThreadedSyncAsyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncAsyncListener> listeners = new LinkedList<SyncAsyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncAsyncListener listener = new SyncAsyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n            messages[i] = i;\n        }\n        IMessagePublication publication = null;\n        // publish in ascending order\n        for(Integer message : messages)\n            publication = fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages() && ! publication.isFinished())\n            pause(200);\n\n        // Check the handlers processing status\n        // Define timeframe in which processing should be finished\n        // If not then an error is assumed\n        long timeElapsed = 0;\n        long timeOut = 30000; // 30 seconds\n        long begin =  System.currentTimeMillis();\n        for(SyncAsyncListener listener : listeners){\n            boolean successful = true;\n            successful &= messages.length == listener.receivedSync.size();\n            successful &=  listener.receivedSync.size() ==listener.receivedAsync.size();\n            for(int i=0; i < listener.receivedAsync.size(); i++){\n                successful &= messages[i] == listener.receivedSync.get(i);\n                // sync and async in same order\n                successful &= listener.receivedSync.get(i) == listener.receivedAsync.get(i);\n            }\n            if(successful)\n                break;\n            timeElapsed = System.currentTimeMillis() - begin;\n        }\n        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n\n    }\n\n    /*\n    @Test\n    public void testMultiThreadedSyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        final IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncListener> listeners = new LinkedList<SyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncListener listener = new SyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        final int[] messages = new int[10000];\n        for(int i = 0; i < messages.length ; i++){\n            messages[i] = i;\n        }\n        final AtomicInteger messageIndex = new AtomicInteger(0);\n        // publish in ascending order\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                int idx;\n                while((idx = messageIndex.getAndIncrement()) < messages.length){\n                    fifoBUs.post(messages[idx]).asynchronously();\n                }\n            }\n        }, 5);\n\n        while(fifoBUs.hasPendingMessages())\n            pause(1000);\n\n        for(SyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            for(int i=0; i < messages.length; i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n            }\n        }\n\n    }  */\n\n\n\n    public static class SyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n    }\n\n    public static class SyncAsyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n        private List<Integer> receivedAsync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n        @Handler(delivery = Invoke.Asynchronously)\n        public void handleASync(Integer message){\n            receivedAsync.add(message);\n        }\n\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * @author bennidi\n *         Date: 3/29/13\n */\npublic class StrongConcurrentSetTest extends ConcurrentSetTest{\n\n    protected Collection createSet() {\n        return new StrongConcurrentSet();\n    }\n\n\n    @Test\n    public void testToArray() {\n        Collection<Integer> set = createSet();\n        assertFalse(set.contains(1));\n        set.add(1);\n        set.add(3);\n        set.add(5);\n        Object [] asArray = set.toArray();\n        // TODO: To array returns set of entries?!\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testContainsAll() {\n        createSet().containsAll(new HashSet<Object>());\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testRemoveAll() {\n        createSet().removeAll(new HashSet<Object>());\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testRetainAll() {\n        createSet().retainAll(new HashSet<Object>());\n    }\n\n    @Test\n    public void testClear() {\n        Collection set = createSet();\n        assertFalse(set.contains(1));\n        set.add(1);\n        assertTrue(set.contains(1));\n        assertEquals(1, set.size());\n        set.clear();\n        assertFalse(set.contains(1));\n        assertEquals(0, set.size());\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.Collection;\n\n/**\n * The configuration of message bus instances is feature driven, e.g. configuration parameters\n * are grouped into {@link Feature}.\n *\n * Each bus will look for the features it requires and configure them according to the provided configuration.\n * If a required feature is not found the bus will publish a {@link ConfigurationError}\n * to the {@link ConfigurationErrorHandler}\n *\n * @author bennidi.\n */\npublic interface IBusConfiguration{\n\n    /**\n     * Set a property which will be read by the message bus constructor. Existing value will be overwritten.\n     * Null values are supported (checking for existence of property will return <code>true</code> even if set to <code>null</code>).\n     *\n     * @param name The name of the property. Note: Each implementation may support different properties.\n     * @param value The value of the property.\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration setProperty(String name, Object value);\n\n    /**\n     * Read a property from this configuration.\n     *\n     * @param name  The name of the property to be read.\n     * @param defaultValue  The value to be returned if property was not found\n     * @param <T>  The type of property\n     * @return The value associated with the given property name or <code>defaultValue</code> if not present\n     */\n    <T> T getProperty(String name, T defaultValue);\n\n    /**\n     * Check whether a property has been set.\n     *\n     * @return true if property was set (even if set to null)\n     *         false otherwise\n     */\n    boolean hasProperty(String name);\n\n\n    /**\n     * Get a registered feature by its type (class).\n     *\n     */\n    <T extends Feature> T getFeature(Class<T> feature);\n\n    /**\n     * Add a feature to the given configuration, replacing any existing feature of the same type.\n     *\n     * @param feature The feature to add\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration addFeature(Feature feature);\n\n    /**\n     * Add a handler that will be called whenever a publication error occurs.\n     * See {@link net.engio.mbassy.bus.error.PublicationError}\n     *\n     * @param handler  The handler to be added to the list of handlers\n     * @return A reference to <code>this</code> bus configuration.\n     */\n    BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler);\n\n    /**\n     * Get an unmodifiable collection of all registered publication error handlers\n     */\n    Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers();\n\n\n    /**\n     * A collection of properties commonly used by different parts of the library.\n     *\n     * @author bennidi\n     *         Date: 22.02.15\n     */\n    final class Properties {\n\n        public static final String BusId = \"bus.id\";\n        public static final String PublicationErrorHandlers = \"bus.handlers.error\";\n        public static final String AsynchronousHandlerExecutor = \"bus.handlers.async-executor\";\n\n    }\n}\n","src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 1000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        IMessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            track(bus.post(new Object()).asynchronously());\n        }\n\n        // Check the handlers processing status\n        // Define timeframe in which processing should be finished\n        // If not then an error is assumed\n        long timeElapsed = 0;\n        long timeOut = 30000; // 30 seconds\n        long begin =  System.currentTimeMillis();\n        while (timeElapsed < timeOut) {\n            boolean successful = true;\n            for (SynchronizedWithAsynchronousDelivery handler : handlers) {\n                successful &= incrementsPerMessage * numberOfMessages ==  handler.counter;\n            }\n            if(successful)\n                break;\n            timeElapsed = System.currentTimeMillis() - begin;\n        }\n        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n\n    }\n\n\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/Feature.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.ISubscriptionManagerProvider;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManagerProvider;\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * A feature defines the configuration of a specific functionality of a message bus.\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic interface Feature {\n\n\n    class SyncPubSub implements Feature{\n\n        public static final SyncPubSub Default(){\n            return new SyncPubSub()\n                    .setMetadataReader(new MetadataReader())\n                    .setPublicationFactory(new MessagePublication.Factory())\n                    .setSubscriptionFactory(new SubscriptionFactory())\n                    .setSubscriptionManagerProvider(new SubscriptionManagerProvider());\n        }\n\n        private MessagePublication.Factory publicationFactory;\n        private MetadataReader metadataReader;\n        private SubscriptionFactory subscriptionFactory;\n        private ISubscriptionManagerProvider subscriptionManagerProvider;\n\n        public ISubscriptionManagerProvider getSubscriptionManagerProvider() {\n            return subscriptionManagerProvider;\n        }\n\n        public SyncPubSub setSubscriptionManagerProvider(ISubscriptionManagerProvider subscriptionManagerProvider) {\n            this.subscriptionManagerProvider = subscriptionManagerProvider;\n            return this;\n        }\n\n        public SubscriptionFactory getSubscriptionFactory() {\n            return subscriptionFactory;\n        }\n\n        public SyncPubSub setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n            this.subscriptionFactory = subscriptionFactory;\n            return this;\n        }\n\n        public MetadataReader getMetadataReader() {\n            return metadataReader;\n        }\n\n        public SyncPubSub setMetadataReader(MetadataReader metadataReader) {\n            this.metadataReader = metadataReader;\n            return this;\n        }\n\n        /**\n         * The message publication factory is used to wrap a published message\n         * in a {@link MessagePublication} for processing.\n         * @return The factory to be used by the bus to create the publications\n         */\n        public MessagePublication.Factory getPublicationFactory() {\n            return publicationFactory;\n        }\n\n        public SyncPubSub setPublicationFactory(MessagePublication.Factory publicationFactory) {\n            this.publicationFactory = publicationFactory;\n            return this;\n        }\n    }\n\n    class AsynchronousHandlerInvocation implements Feature{\n\n        protected static final ThreadFactory MessageHandlerThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setName(\"AsyncHandler-\" + threadID.getAndIncrement());\n                thread.setDaemon(true);\n                return thread;\n            }\n        };\n\n        public static final AsynchronousHandlerInvocation Default(){\n            int numberOfCores = Runtime.getRuntime().availableProcessors();\n            return Default(numberOfCores, numberOfCores * 2);\n        }\n\n        public static final AsynchronousHandlerInvocation Default(int minThreadCount, int maxThreadCount){\n            return new AsynchronousHandlerInvocation().setExecutor(new ThreadPoolExecutor(minThreadCount, maxThreadCount, 1,\n                    TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), MessageHandlerThreadFactory));\n        }\n\n        private ExecutorService executor;\n\n        public ExecutorService getExecutor() {\n            return executor;\n        }\n\n        public AsynchronousHandlerInvocation setExecutor(ExecutorService executor) {\n            this.executor = executor;\n            return this;\n        }\n    }\n\n    class AsynchronousMessageDispatch implements Feature{\n\n        protected static final ThreadFactory MessageDispatchThreadFactory = new ThreadFactory() {\n\n            private final AtomicInteger threadID = new AtomicInteger(0);\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = Executors.defaultThreadFactory().newThread(r);\n                thread.setDaemon(true);// do not prevent the JVM from exiting\n                thread.setName(\"Dispatcher-\" + threadID.getAndIncrement());\n                return thread;\n            }\n        };\n\n        public static final AsynchronousMessageDispatch Default(){\n            return new AsynchronousMessageDispatch()\n                .setNumberOfMessageDispatchers(2)\n                .setDispatcherThreadFactory(MessageDispatchThreadFactory)\n                .setMessageQueue(new LinkedBlockingQueue<IMessagePublication>(Integer.MAX_VALUE));\n        }\n\n\n        private int numberOfMessageDispatchers;\n        private BlockingQueue<IMessagePublication> messageQueue;\n        private ThreadFactory dispatcherThreadFactory;\n\n        public int getNumberOfMessageDispatchers() {\n            return numberOfMessageDispatchers;\n        }\n\n        public AsynchronousMessageDispatch setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n            this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n            return this;\n        }\n\n        public BlockingQueue<IMessagePublication> getMessageQueue() {\n            return messageQueue;\n        }\n\n        public AsynchronousMessageDispatch setMessageQueue(BlockingQueue<IMessagePublication> pendingMessages) {\n            this.messageQueue = pendingMessages;\n            return this;\n        }\n\n        public ThreadFactory getDispatcherThreadFactory() {\n            return dispatcherThreadFactory;\n        }\n\n        public AsynchronousMessageDispatch setDispatcherThreadFactory(ThreadFactory dispatcherThreadFactory) {\n            this.dispatcherThreadFactory = dispatcherThreadFactory;\n            return this;\n        }\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n * @author dorkbox\n *         Date: 22/2/15\n */\npublic abstract class AbstractConcurrentSet<T> implements Set<T> {\n    private static final AtomicLong id = new AtomicLong();\n    private final long ID = id.getAndIncrement();\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(1) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public boolean add(T element) {\n        if (element == null) return false;\n        Lock writeLock = lock.writeLock();\n        boolean changed;\n        try {\n            writeLock.lock();\n            changed = insert(element);\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean contains(Object element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n\n    /**\n     * Inserts a new element at the head of the set.\n     * Note: This method is expected to be synchronized by the calling code\n     */\n    private boolean insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> elements) {\n        boolean changed = false;\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    changed |= insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean remove(Object element) {\n        if (!contains(element)) {\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        return this.entries.entrySet().toArray();\n    }\n\n    @SuppressWarnings(\"hiding\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return this.entries.entrySet().toArray(a);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public void clear() {\n        Lock writeLock = this.lock.writeLock();\n        try {\n            writeLock.lock();\n                head = null;\n                entries.clear();\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"rawtypes\")\n        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n        if (this.ID != other.ID) {\n            return false;\n        }\n        return true;\n    }\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // Not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // Can not nullify references to help GC because running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\nimport java.util.concurrent.ExecutorService;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private final IHandlerInvocation delegate;\n\n    private final ExecutorService executor;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n        this.executor = delegate.getContext().getRuntime().get(IBusConfiguration.Properties.AsynchronousHandlerExecutor);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message){\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                    delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/main/java/net/engio/mbassy/listener/IMessageFilter.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Message filters can be used to control what messages are delivered to a specific message handler.\n * Filters are attached to message handler using the @Handler annotation.\n * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.\n * The handler will be invoked only if each filter accepted the message.\n *\n * Example:\n *\n * <pre>\n * <code>\n * {@literal @}Listener\n * {@literal @}Filters(Urlfilter.class)\n * public void someHandler(String message){...}\n *\n * class Urlfilter implements IMessageFilter<String>{\n *     public boolean accepts(String message, SubscriptionContext context){\n *         return message.startsWith(\"http\");\n *     }\n * }\n *\n * bus.post(\"http://www.infoq.com\"); // will be delivered\n * bus.post(\"www.stackoverflow.com\"); // will not be delivered\n *\n * </code>\n * </pre>\n *\n * NOTE: A message filter must provide a no-arg constructor!!!\n *\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic interface IMessageFilter<M> {\n\n    /**\n     * Check whether the message matches some criteria\n     *\n     * @param message The message to be handled by the handler\n     * @param  context The context object containing a description of the message handler and the bus environment\n     * @return  true: if the message matches the criteria and should be delivered to the handler\n     *          false: otherwise\n     */\n    boolean accepts(M message, SubscriptionContext context);\n}\n","src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.*;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\nimport net.engio.mbassy.subscription.SubscriptionManager;\nimport org.junit.Test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners\n * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions\n * are tested for the type of messages they should handle and\n *\n * @author bennidi\n *         Date: 5/12/13\n */\npublic class SubscriptionManagerTest extends AssertSupport {\n\n    private static final int InstancesPerListener = 5000;\n    private static final int ConcurrentUnits = 10;\n\n    @Test\n    public void testIMessageListener() {\n        ListenerFactory listeners = listeners(\n                IMessageListener.DefaultListener.class,\n                IMessageListener.AsyncListener.class,\n                IMessageListener.DisabledListener.class,\n                IMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,\n                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)\n                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testAbstractMessageListener() {\n        ListenerFactory listeners = listeners(\n                AbstractMessageListener.DefaultListener.class,\n                AbstractMessageListener.AsyncListener.class,\n                AbstractMessageListener.DisabledListener.class,\n                AbstractMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)\n                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)\n                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMessagesListener() {\n        ListenerFactory listeners = listeners(\n                MessagesTypeListener.DefaultListener.class,\n                MessagesTypeListener.AsyncListener.class,\n                MessagesTypeListener.DisabledListener.class,\n                MessagesTypeListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MessagesTypeListener.NoSubtypesListener.class).handles(MessageTypes.class)\n                .listener(MessagesTypeListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesTypeListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipartMessageListener() {\n        ListenerFactory listeners = listeners(\n                MultipartMessageListener.DefaultListener.class,\n                MultipartMessageListener.AsyncListener.class,\n                MultipartMessageListener.DisabledListener.class,\n                MultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)\n                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testIMultipartMessageListener() {\n        ListenerFactory listeners = listeners(\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                IMultipartMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStandardMessageListener() {\n        ListenerFactory listeners = listeners(\n                StandardMessageListener.DefaultListener.class,\n                StandardMessageListener.AsyncListener.class,\n                StandardMessageListener.DisabledListener.class,\n                StandardMessageListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)\n                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testICountableListener() {\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                ICountableListener.NoSubtypesListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)\n                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testMultipleMessageListeners() {\n        ListenerFactory listeners = listeners(\n                ICountableListener.DefaultListener.class,\n                ICountableListener.AsyncListener.class,\n                ICountableListener.DisabledListener.class,\n                IMultipartMessageListener.DefaultListener.class,\n                IMultipartMessageListener.AsyncListener.class,\n                IMultipartMessageListener.DisabledListener.class,\n                MessagesTypeListener.DefaultListener.class,\n                MessagesTypeListener.AsyncListener.class,\n                MessagesTypeListener.DisabledListener.class);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(ICountableListener.DefaultListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(ICountableListener.AsyncListener.class)\n                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)\n                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)\n                .listener(MessagesTypeListener.DefaultListener.class).handles(MessageTypes.class)\n                .listener(MessagesTypeListener.AsyncListener.class).handles(MessageTypes.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n        ListenerFactory listeners = listeners(CustomInvocationListener.class);\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n        runGC();\n\n        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);\n        assertEquals(1, subscriptions.size());\n        for (Subscription sub : subscriptions)\n            assertEquals(InstancesPerListener, sub.size());\n    }\n\n    @Test\n    public void testOverloadedMessageHandlers() {\n        ListenerFactory listeners = listeners(\n                Overloading.ListenerBase.class,\n                Overloading.ListenerSub.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)\n                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    @Test\n    public void testPrioritizedMessageHandlers() {\n        ListenerFactory listeners = listeners(PrioritizedListener.class);\n\n        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)\n                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);\n\n        runTestWith(listeners, expectedSubscriptions);\n    }\n\n    private BusRuntime mockedRuntime() {\n        return new BusRuntime(null)\n                .add(IBusConfiguration.Properties.PublicationErrorHandlers, Collections.EMPTY_SET)\n                .add(IBusConfiguration.Properties.AsynchronousHandlerExecutor, null);\n    }\n\n    private ListenerFactory listeners(Class... listeners) {\n        ListenerFactory factory = new ListenerFactory();\n        for (Class listener : listeners) {\n            factory.create(InstancesPerListener, listener);\n        }\n        return factory;\n    }\n\n    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator) {\n        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        validator.validate(subscriptionManager);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);\n\n        listeners.clear();\n\n        validator.validate(subscriptionManager);\n    }\n\n\n    /**\n     * define handlers with different priorities which need to be executed\n     * in their respective order\n     */\n    public static class PrioritizedListener {\n\n\n        @net.engio.mbassy.listener.Handler(priority = 1)\n        public void handlePrio1(IMessage message) {\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 2)\n        public void handlePrio2(IMessage message) {\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 3)\n        public void handlePrio3(IMessage message) {\n            message.handled(this.getClass());\n        }\n\n        @net.engio.mbassy.listener.Handler(priority = 4)\n        public void handlePrio4(IMessage message) {\n            message.handled(this.getClass());\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/CustomInvocationListener.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\nimport net.engio.mbassy.messages.StandardMessage;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * @author bennidi\n *         Date: 5/25/13\n */\n@Listener(references = References.Strong)\npublic class CustomInvocationListener {\n\n    @Handler(invocation = HandleSubTestEventInvocation.class)\n    public void handle(StandardMessage message) {\n        message.handled(this.getClass());\n        message.handled(this.getClass());\n    }\n\n    public static class HandleSubTestEventInvocation extends HandlerInvocation<CustomInvocationListener, StandardMessage> {\n\n        public HandleSubTestEventInvocation(SubscriptionContext context) {\n            super(context);\n        }\n\n        @Override\n        public void invoke(CustomInvocationListener listener, StandardMessage message) {\n            listener.handle(message);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java":"package net.engio.mbassy.bus.config;\n\n/**\n * Configuration errors represent specific invalid configurations of a feature in a {@link net.engio.mbassy.bus.config.IBusConfiguration}\n * An invalid feature configuration is assumed to render the bus dysfunctional and as such is thrown as an unchecked exception.\n *\n * @author bennidi\n *         Date: 8/29/14\n */\npublic class ConfigurationError extends RuntimeException{\n\n    private String message;\n\n    private ConfigurationError(String message) {\n        this.message = message;\n    }\n\n    public static ConfigurationError MissingFeature(Class<? extends Feature> featureType){\n        return new ConfigurationError(\"The expected feature \" + featureType +  \" was missing. Use addFeature() in IBusConfiguration to add features.\");\n    }\n\n    @Override\n    public String toString() {\n        return message;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/BusRuntime.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.MissingPropertyException;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n * they expose. The runtime is a container for all those dynamic properties and components and is meant to be passed around\n * between collaborating objects such that they may access the different functionality provided by the bus implementation\n * they all belong to.\n *\n * It is the responsibility of the bus implementation to create and configure the runtime according to its capabilities,\n *\n */\npublic class BusRuntime {\n\n    private PubSubSupport provider;\n\n    private Map<String, Object> properties = new HashMap<String, Object>();\n\n    public BusRuntime(PubSubSupport provider) {\n        this.provider = provider;\n    }\n\n    public <T> T get(String key){\n         if(!contains(key))\n             throw new MissingPropertyException(\"The property \" + key + \" is not available in this runtime\");\n         else return (T) properties.get(key);\n     }\n\n    public PubSubSupport getProvider(){\n        return provider;\n    }\n\n    public Collection<String> getKeys(){\n        return properties.keySet();\n    }\n\n    public BusRuntime add(String key, Object property){\n        properties.put(key, property);\n        return this;\n    }\n\n    public boolean contains(String key){\n        return properties.containsKey(key);\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesTypeListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesTypeListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesTypeListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: modified to pass ExceptionCounter via the configuration object\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n        exceptionCount.set(0); // reset for next test\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testExceptionInHandlerInvocation2(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: modified to pass ExceptionCounter via the configuration object\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n        exceptionCount.set(0); // reset for next test\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new IncrementingMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n        //DS: added errorHandler parameter to allow adding handler from caller\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n            if (errorHandler != null) {\n                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);\n            }\n            return new MBassador(asyncFIFOConfig);\n\n        }\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n            if (errorHandler != null) {\n                syncPubSubCfg.addPublicationErrorHandler(errorHandler);\n            }\n            return new SyncMessageBus(syncPubSubCfg);\n        }\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n    }\n\n\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else throw new RuntimeException(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandler;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{\n        try {\n            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(IBusConfiguration.Properties.PublicationErrorHandlers);\n            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandler().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandler().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandler().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandler().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {\n        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        try {\n            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n            return constructor.newInstance(context);\n        } catch (NoSuchMethodException e) {\n            throw new MessageBusException(\"The provided handler invocation did not specify the necessary constructor \"\n                    + invocation.getSimpleName() + \"(SubscriptionContext);\", e);\n        } catch (Exception e) {\n            throw new MessageBusException(\"Could not instantiate the provided handler invocation \"\n                    + invocation.getSimpleName(), e);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/error/PublicationError.java":"package net.engio.mbassy.bus.error;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.Method;\n\n/**\n * Publication errors are used to communicate exceptions that occur during message publication.\n * The most common reason is most likely an exception thrown during the execution of a message handler.\n *\n * The publication error contains details about to the cause and location where error occurred.\n * They are passed to all registered instances of {@link IPublicationErrorHandler} configured within\n * the {@link net.engio.mbassy.bus.config.IBusConfiguration}\n *\n * @author bennidi\n *         Date: 2/22/12\n *         Time: 4:59 PM\n */\npublic class PublicationError{\n\n    // Internal state\n    private Throwable cause;\n    private String message;\n    private Method handler;\n    private Object listener;\n    private Object publishedMessage;\n\n\n    /**\n     * Compound constructor, creating a PublicationError from the supplied objects.\n     *\n     * @param cause           The Throwable giving rise to this PublicationError.\n     * @param message         The message to send.\n     * @param handler        The method where the error was created.\n     * @param listener The object in which the PublicationError was generated.\n     * @param publishedObject The published object which gave rise to the error.\n     */\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final Method handler,\n                            final Object listener,\n                            final Object publishedObject) {\n\n        this.cause = cause;\n        this.message = message;\n        this.handler = handler;\n        this.listener = listener;\n        this.publishedMessage = publishedObject;\n    }\n\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final IMessagePublication publication) {\n        this.cause = cause;\n        this.message = message;\n        this.publishedMessage = publication != null ? publication.getMessage() : null;\n    }\n\n    public PublicationError(final Throwable cause,\n                            final String message,\n                            final SubscriptionContext context) {\n        this.cause = cause;\n        this.message = message;\n        this.handler = context.getHandler().getMethod();\n    }\n\n    public PublicationError(Throwable cause, String message) {\n        this.cause = cause;\n        this.message = message;\n    }\n\n\n    /**\n     * Default constructor.\n     */\n    public PublicationError() {\n        super();\n    }\n\n    /**\n     * @return The Throwable giving rise to this PublicationError.\n     */\n    public Throwable getCause() {\n        return cause;\n    }\n\n    /**\n     * Assigns the cause of this PublicationError.\n     *\n     * @param cause A Throwable which gave rise to this PublicationError.\n     * @return This PublicationError.\n     */\n    public PublicationError setCause(Throwable cause) {\n        this.cause = cause;\n        return this;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public PublicationError setMessage(String message) {\n        this.message = message;\n        return this;\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public PublicationError setHandler(Method handler) {\n        this.handler = handler;\n        return this;\n    }\n\n    public Object getListener() {\n        return listener;\n    }\n\n    public PublicationError setListener(Object listener) {\n        this.listener = listener;\n        return this;\n    }\n\n    public Object getPublishedMessage() {\n        return publishedMessage;\n    }\n\n    public PublicationError setPublishedMessage(Object publishedMessage) {\n        this.publishedMessage = publishedMessage;\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n    \tString newLine = System.getProperty(\"line.separator\");\n        return \"PublicationError{\" +\n                newLine +\n                \"\\tcause=\" + cause +\n                newLine +\n                \"\\tmessage='\" + message + '\\'' +\n                newLine +\n                \"\\thandler=\" + handler +\n                newLine +\n                \"\\tlistener=\" + listener +\n                newLine +\n                \"\\tpublishedMessage=\" + publishedMessage +\n                '}';\n    }\n}\n","src/test/java/net/engio/mbassy/CustomHandlerAnnotationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.MessageEnvelope;\nimport net.engio.mbassy.subscription.SubscriptionContext;\nimport org.junit.Test;\n\nimport java.lang.annotation.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Tests a custom handler annotation with a @Handler meta annotation and a default filter.\n */\npublic class CustomHandlerAnnotationTest extends MessageBusTest\n{\n\t/**\n\t * Handler annotation that adds a default filter on the NamedMessage.\n\t * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Synchronized\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\t@interface NamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n    /**\n     * Handler annotation that adds a default filter on the NamedMessage.\n     * Enveloped is in no way required, but simply added to test a meta enveloped annotation.\n     */\n    @Retention(value = RetentionPolicy.RUNTIME)\n    @Inherited\n    @NamedMessageHandler(\"messageThree\")\n    @interface MessageThree {}\n\n\n\n\t/**\n\t * Test enveloped meta annotation.\n\t */\n\t@Retention(value = RetentionPolicy.RUNTIME)\n\t@Target(value = { ElementType.METHOD, ElementType.ANNOTATION_TYPE })\n\t@Inherited\n\t@Handler(filters = { @Filter(NamedMessageFilter.class) })\n\t@Enveloped(messages = NamedMessage.class)\n\t@interface EnvelopedNamedMessageHandler\n\t{\n\t\t/**\n\t\t * @return The message names supported.\n\t\t */\n\t\tString[] value();\n\t}\n\n\t/**\n\t * Searches for a NamedMessageHandler annotation on the handler method.\n\t * The annotation specifies the supported message names.\n\t */\n\tpublic static class NamedMessageFilter implements IMessageFilter<NamedMessage>\n\t{\n\t\t@Override\n\t\tpublic boolean accepts( NamedMessage message,  SubscriptionContext context ) {\n            MessageHandler handler = context.getHandler();\n\t\t\tNamedMessageHandler namedMessageHandler = handler.getAnnotation(NamedMessageHandler.class);\n\t\t\tif ( namedMessageHandler != null ) {\n\t\t\t\treturn Arrays.asList( namedMessageHandler.value() ).contains( message.getName() );\n\t\t\t}\n\n\t\t\tEnvelopedNamedMessageHandler envelopedHandler = handler.getAnnotation(EnvelopedNamedMessageHandler.class);\n\t\t\treturn envelopedHandler != null && Arrays.asList( envelopedHandler.value() ).contains( message.getName() );\n\n\t\t}\n\t}\n\n\tstatic class NamedMessage\n\t{\n\t\tprivate String name;\n\n\t\tNamedMessage( String name ) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tstatic class NamedMessageListener\n\t{\n\t\tfinal Set<NamedMessage> handledByOne = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByTwo = new HashSet<NamedMessage>();\n\t\tfinal Set<NamedMessage> handledByThree = new HashSet<NamedMessage>();\n\n\t\t@NamedMessageHandler({ \"messageOne\", \"messageTwo\" })\n\t\tvoid handlerOne( NamedMessage message ) {\n\t\t\thandledByOne.add( message );\n\t\t}\n\n\t\t@EnvelopedNamedMessageHandler({ \"messageTwo\", \"messageThree\" })\n\t\tvoid handlerTwo( MessageEnvelope envelope ) {\n\t\t\thandledByTwo.add( (NamedMessage) envelope.getMessage() );\n\t\t}\n\n\t\t@MessageThree\n\t\tvoid handlerThree( NamedMessage message ) {\n\t\t\thandledByThree.add( message );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMetaHandlerFiltering() {\n\t\tMBassador bus = createBus(SyncAsync());\n\n\t\tNamedMessageListener listener = new NamedMessageListener();\n\t\tbus.subscribe( listener );\n\n\t\tNamedMessage messageOne = new NamedMessage( \"messageOne\" );\n\t\tNamedMessage messageTwo = new NamedMessage( \"messageTwo\" );\n\t\tNamedMessage messageThree = new NamedMessage( \"messageThree\" );\n\n\t\tbus.publish( messageOne );\n\t\tbus.publish( messageTwo );\n\t\tbus.publish( messageThree );\n\n        assertEquals(2, listener.handledByOne.size());\n\t\tassertTrue( listener.handledByOne.contains( messageOne ) );\n\t\tassertTrue(listener.handledByOne.contains(messageTwo));\n\n        assertEquals(2, listener.handledByTwo.size());\n\t\tassertTrue( listener.handledByTwo.contains( messageTwo ) );\n\t\tassertTrue( listener.handledByTwo.contains( messageThree ) );\n\n        assertEquals(1, listener.handledByThree.size());\n\t\tassertTrue( listener.handledByThree.contains( messageThree ) );\n\t}\n}\n","src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.ConfigurationError;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.InternalPublicationError;\nimport net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The base class for all message bus implementations with support for asynchronous message dispatch\n *\n * @param <T> The type of message this bus consumes\n * @param <P> The publication commands this bus supports depend on P\n */\npublic abstract class AbstractSyncAsyncMessageBus<T, P extends ISyncAsyncPublicationCommand>\n        extends AbstractPubSubSupport<T> implements IMessageBus<T, P> {\n\n    // executor for asynchronous message handlers\n    private final ExecutorService executor;\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers;\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<IMessagePublication> pendingMessages;\n\n    protected AbstractSyncAsyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n\n        // configure asynchronous message dispatch\n        Feature.AsynchronousMessageDispatch asyncDispatch = configuration.getFeature(Feature.AsynchronousMessageDispatch.class);\n        if(asyncDispatch == null){\n            throw ConfigurationError.MissingFeature(Feature.AsynchronousMessageDispatch.class);\n        }\n        pendingMessages = asyncDispatch.getMessageQueue();\n        dispatchers = new ArrayList<Thread>(asyncDispatch.getNumberOfMessageDispatchers());\n        initDispatcherThreads(asyncDispatch);\n\n        // configure asynchronous handler invocation\n        Feature.AsynchronousHandlerInvocation asyncInvocation = configuration.getFeature(Feature.AsynchronousHandlerInvocation.class);\n        if(asyncInvocation == null){\n            throw ConfigurationError.MissingFeature(Feature.AsynchronousHandlerInvocation.class);\n        }\n        this.executor = asyncInvocation.getExecutor();\n        getRuntime().add(IBusConfiguration.Properties.AsynchronousHandlerExecutor, executor);\n\n    }\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(Feature.AsynchronousMessageDispatch configuration) {\n        for (int i = 0; i < configuration.getNumberOfMessageDispatchers(); i++) {\n            // each thread will run forever and process incoming\n            // message publication requests\n            Thread dispatcher = configuration.getDispatcherThreadFactory().newThread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        IMessagePublication publication = null;\n                        try {\n                            publication = pendingMessages.take();\n                            publication.execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        } catch(Throwable t){\n                            handlePublicationError(new InternalPublicationError(t, \"Error in asynchronous dispatch\",publication));\n                        }\n                    }\n                }\n            });\n            dispatcher.setName(\"MsgDispatcher-\"+i);\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication) {\n        try {\n            pendingMessages.put(publication);\n            return publication.markScheduled();\n        } catch (InterruptedException e) {\n            handlePublicationError(new InternalPublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    // this method queues a message delivery request\n    protected IMessagePublication addAsynchronousPublication(IMessagePublication publication, long timeout, TimeUnit unit) {\n        try {\n            return pendingMessages.offer(publication, timeout, unit)\n                    ? publication.markScheduled()\n                    : publication;\n        } catch (InterruptedException e) {\n            handlePublicationError(new InternalPublicationError(e, \"Error while adding an asynchronous message publication\", publication));\n            return publication;\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        shutdown();\n    }\n\n    @Override\n    public void shutdown() {\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        if(executor != null) executor.shutdown();\n    }\n\n    @Override\n    public boolean hasPendingMessages() {\n        return pendingMessages.size() > 0;\n    }\n\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesTypeListener.DefaultListener.class));\n\n        bus.shutdown();\n        pause(200);\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.createAndTrack(\n                        StandardMessage.class,\n                        InstancesPerListener,\n                        Listeners.join(Listeners.asynchronous(),Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(\n                        MultipartMessage.class,\n                        InstancesPerListener,\n                        IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesTypeListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        bus.shutdown();\n        pause(200);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously(1, TimeUnit.MILLISECONDS);\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(waitForMessageTimeout);\n\n        bus.shutdown();\n        pause(200);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: Exception counter added via config\n        IBusConfiguration config = SyncAsync(false)\n            .addPublicationErrorHandler(ExceptionCounter);\n\n        final MBassador bus = new MBassador(config);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable asynchronousPublication = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new Object()).asynchronously();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(asynchronousPublication, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n        bus.shutdown();\n        pause(200);\n\n    }\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/error/IPublicationErrorHandler.java":"package net.engio.mbassy.bus.error;\n\n/**\n * Publication error handlers are provided with a publication error every time an\n * error occurs during message publication.\n * A handler might fail with an exception, not be accessible because of the presence\n * of a security manager or other reasons might lead to failures during the message publication process.\n * <p/>\n *\n * @author bennidi\n *         Date: 2/22/12\n */\n@SuppressWarnings(\"PMD.UnusedModifier\")\npublic interface IPublicationErrorHandler {\n\n    /**\n     * Handle the given publication error.\n     *\n     * @param error The PublicationError to handle.\n     */\n    void handleError(PublicationError error);\n\n    /**\n     * The default error handler will simply log to standard out and\n     * print the stack trace if available.\n     */\n    final class ConsoleLogger implements IPublicationErrorHandler {\n\n        private final boolean printStackTrace;\n\n        public ConsoleLogger() {\n            this(false);\n        }\n\n        public ConsoleLogger(boolean printStackTrace) {\n            this.printStackTrace = printStackTrace;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void handleError(final PublicationError error) {\n\n            // Printout the error itself\n            System.out.println(error);\n\n            // Printout the stacktrace from the cause.\n            if (printStackTrace && error.getCause() != null) {\n                error.getCause().printStackTrace();\n            }\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.*;\n\n/**\n * {@inheritDoc}\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    // the registered properties\n    private final Map<Object, Object> properties = new HashMap<Object, Object>();\n    private final List<ConfigurationErrorHandler> configurationErrorHandlers = new LinkedList<ConfigurationErrorHandler>();\n    // these are transferred to the bus to receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> publicationErrorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public IBusConfiguration setProperty(String name, Object value) {\n        properties.put(name, value);\n        return this;\n    }\n\n    @Override\n    public <T> T getProperty(String name, T defaultValue) {\n        return properties.containsKey(name) ? (T) properties.get(name) : defaultValue;\n    }\n\n    @Override\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T) properties.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        properties.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public final BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler) {\n        publicationErrorHandlers.add(handler);\n        return this;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers() {\n        return Collections.unmodifiableCollection(publicationErrorHandlers);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.ConfigurationError;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.*;\n\nimport static net.engio.mbassy.bus.config.IBusConfiguration.Properties.BusId;\nimport static net.engio.mbassy.bus.config.IBusConfiguration.Properties.PublicationErrorHandlers;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n    public static final String ERROR_HANDLER_MSG = \"INFO: No error handler has been configured to handle exceptions during publication.\\n\" +\n            \"Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\\n\" +\n            \"Falling back to console logger.\";\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n        //transfer publication error handlers from the config object\n        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());\n        if (errorHandlers.isEmpty()) {\n            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n            System.out.println(ERROR_HANDLER_MSG);\n        }\n        this.runtime = new BusRuntime(this)\n                .add(PublicationErrorHandlers, configuration.getRegisteredPublicationErrorHandlers())\n                .add(BusId, configuration.getProperty(BusId, UUID.randomUUID().toString()));\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        if(pubSubFeature == null){\n            throw ConfigurationError.MissingFeature(Feature.SyncPubSub.class);\n        }\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n                .equals(DeadMessage.class)) {\n            // DeadMessage Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    protected void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"(\" + runtime.get(IBusConfiguration.Properties.BusId) + \")\";\n    }\n}\n","src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class AsyncFIFOBusTest extends MessageBusTest {\n\n    @Test\n    public void testSingleThreadedSyncFIFO(){\n        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n        IMessageBus fifoBUs = new MBassador(asyncFIFOConfig);\n\n        List<SyncListener> listeners = new LinkedList<SyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncListener listener = new SyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n             messages[i] = i;\n        }\n        // publish in ascending order\n        for(Integer message : messages)\n            fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages())\n            pause(1000);\n\n        for(SyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            for(int i=0; i < messages.length; i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n            }\n        }\n\n    }\n\n    @Test\n    public void testSingleThreadedSyncAsyncFIFO(){\n        BusConfiguration asyncFIFOConfig = new BusConfiguration();\n        asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n        asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n        asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n        IMessageBus fifoBUs = new MBassador(asyncFIFOConfig);\n\n        List<SyncAsyncListener> listeners = new LinkedList<SyncAsyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncAsyncListener listener = new SyncAsyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n            messages[i] = i;\n        }\n        IMessagePublication publication = null;\n        // publish in ascending order\n        for(Integer message : messages)\n            publication = fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages() && ! publication.isFinished())\n            pause(200);\n\n        // Check the handlers processing status\n        // Define timeframe in which processing should be finished\n        // If not then an error is assumed\n        long timeElapsed = 0;\n        long timeOut = 30000; // 30 seconds\n        long begin =  System.currentTimeMillis();\n        for(SyncAsyncListener listener : listeners){\n            boolean successful = true;\n            successful &= messages.length == listener.receivedSync.size();\n            successful &=  listener.receivedSync.size() ==listener.receivedAsync.size();\n            for(int i=0; i < listener.receivedAsync.size(); i++){\n                successful &= messages[i] == listener.receivedSync.get(i);\n                // sync and async in same order\n                successful &= listener.receivedSync.get(i) == listener.receivedAsync.get(i);\n            }\n            if(successful)\n                break;\n            timeElapsed = System.currentTimeMillis() - begin;\n        }\n        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n\n    }\n\n    public static class SyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n    }\n\n    public static class SyncAsyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n        private List<Integer> receivedAsync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n        @Handler(delivery = Invoke.Asynchronously)\n        public void handleASync(Integer message){\n            receivedAsync.add(message);\n        }\n\n    }\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/StrongConcurrentSetTest.java":[[15,15]],"src/main/java/net/engio/mbassy/bus/config/Feature.java":[[157,157]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[217,217],[218,218]],"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[23,23]],"src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java":[[27,28]],"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[73,73],[91,91],[41,41],[43,43],[50,50],[53,53],[103,103]],"src/main/java/net/engio/mbassy/bus/BusRuntime.java":[[29,29]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[24,24]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[105,105],[46,46]],"src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":[[59,59],[25,25]]},"postChangeRange":{"src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":[[71,73],[62,68]],"src/main/java/net/engio/mbassy/bus/config/Feature.java":[[157,157]],"src/test/java/net/engio/mbassy/SubscriptionManagerTest.java":[[216,216],[217,217]],"src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":[[23,23]],"src/main/java/net/engio/mbassy/bus/config/ConfigurationError.java":[[24,24]],"src/main/java/net/engio/mbassy/bus/AbstractSyncAsyncMessageBus.java":[[72,72],[90,90],[40,40],[42,42],[49,49],[52,52],[102,102]],"src/test/java/net/engio/mbassy/SyncAsyncTest.java":[[122,122],[136,136],[137,137],[60,60],[61,61],[180,180],[181,181],[101,101],[102,102]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[24,24]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[110,110],[47,48],[51,53]],"src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":[[62,62],[63,63],[64,64],[65,65],[66,66],[26,26],[27,27],[28,28],[29,29],[30,30]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java","startLine":51,"endLine":51}]}],"refactorings":[]},{"repository":"mbassador","sha1":"a6d5daed0ecf33c25f27179a0601376cd191fb64","url":"https://github.com/bennidi/mbassador/commit/a6d5daed0ecf33c25f27179a0601376cd191fb64","preChangeSourceCode":{"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Map;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n\n    // Internal state\n    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public IConcurrentSet<T> add(T element) {\n        if (element == null) return this;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        if (element == null || entries.containsKey(element)) {\n            writeLock.unlock();\n            return this;\n        } else {\n            insert(element);\n            writeLock.unlock();\n        }\n        return this;\n    }\n\n    @Override\n    public boolean contains(T element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n        }\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public IConcurrentSet<T> addAll(Iterable<T> elements) {\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return this;\n    }\n\n    @Override\n    public boolean remove(T element) {\n        if (!contains(element)) {\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    ISetEntry<T> oldHead = head;\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // can not nullify references to help GC since running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n\n\n    public WeakConcurrentSet() {\n        super(new WeakHashMap<T, ISetEntry<T>>());\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private ISetEntry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                if (current.getValue() == null) {    // auto-removal of orphan references\n                    do {\n                        remove();\n                    } while(current != null && current.getValue() == null);\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    do {\n                        remove();\n                    } while(current != null && current.getValue() == null);\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) {\n                    return;\n                }\n                ISetEntry<T> newCurrent = current.next();\n                WeakConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n    @Override\n    protected Entry<T> createEntry(T value, Entry<T> next) {\n        return next != null ? new WeakEntry<T>(value, next) : new WeakEntry<T>(value);\n    }\n\n\n    public static class WeakEntry<T> extends Entry<T> {\n\n        private WeakReference<T> value;\n\n        private WeakEntry(T value, Entry<T> next) {\n            super(next);\n            this.value = new WeakReference<T>(value);\n        }\n\n        private WeakEntry(T value) {\n            super();\n            this.value = new WeakReference<T>(value);\n        }\n\n        @Override\n        public T getValue() {\n            return value.get();\n        }\n\n\n\n\n    }\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Map;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic abstract class AbstractConcurrentSet<T> implements IConcurrentSet<T> {\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public IConcurrentSet<T> add(T element) {\n        if (element == null) return this;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        if (element == null || entries.containsKey(element)) {\n            writeLock.unlock();\n            return this;\n        } else {\n            insert(element);\n            writeLock.unlock();\n        }\n        return this;\n    }\n\n    @Override\n    public boolean contains(T element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n        }\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public IConcurrentSet<T> addAll(Iterable<T> elements) {\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return this;\n    }\n\n    @Override\n    public boolean remove(T element) {\n        if (!contains(element)) {\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    ISetEntry<T> oldHead = head;\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // can not nullify references to help GC since running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * This implementation uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class WeakConcurrentSet<T> extends AbstractConcurrentSet<T>{\n\n\n    public WeakConcurrentSet() {\n        super(new WeakHashMap<T, ISetEntry<T>>());\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            // the current listelement of this iterator\n            // used to keep track of the iteration process\n            private ISetEntry<T> current = head;\n\n            // this method will remove all orphaned entries\n            // until it finds the first entry whose value has not yet been garbage collected\n            // the method assumes that the current element is already orphaned and will remove it\n            private void removeOrphans(){\n                Lock writelock = lock.writeLock();\n                try{\n                    writelock.lock();\n                    do {\n                        ISetEntry orphaned = current;\n                        current = current.next();\n                        orphaned.remove();\n                    } while(current != null && current.getValue() == null);\n                }\n                finally {\n                    writelock.unlock();\n                }\n            }\n\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                if (current.getValue() == null) {\n                // trigger removal of orphan references\n                // because a null value indicates that the value has been garbage collected\n                    removeOrphans();\n                    return current != null; // if any entry is left then it will have a value\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) {\n                    return null;\n                }\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    removeOrphans();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                //throw new UnsupportedOperationException(\"Explicit removal of set elements is only allowed via the controlling set. Sorry!\");\n                if (current == null) {\n                    return;\n                }\n                ISetEntry<T> newCurrent = current.next();\n                WeakConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n    @Override\n    protected Entry<T> createEntry(T value, Entry<T> next) {\n        return next != null ? new WeakEntry<T>(value, next) : new WeakEntry<T>(value);\n    }\n\n\n    public static class WeakEntry<T> extends Entry<T> {\n\n        private WeakReference<T> value;\n\n        private WeakEntry(T value, Entry<T> next) {\n            super(next);\n            this.value = new WeakReference<T>(value);\n        }\n\n        private WeakEntry(T value) {\n            super();\n            this.value = new WeakReference<T>(value);\n        }\n\n        @Override\n        public T getValue() {\n            return value.get();\n        }\n\n\n\n\n    }\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java":[[32,37],[48,50]]},"postChangeRange":{"src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java":[[36,49],[54,59],[70,70]]},"microChanges":[],"refactorings":[{"type":"\"Extract Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java","startLine":32,"endLine":32}],"rightSideLocations":[]},{"type":"\"Extract Method\"","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/WeakConcurrentSet.java","startLine":54,"endLine":54}]}]},{"repository":"mbassador","sha1":"fdd3a7a310410ae3c18486eeaaa433d17fee6feb","url":"https://github.com/bennidi/mbassador/commit/fdd3a7a310410ae3c18486eeaaa433d17fee6feb","preChangeSourceCode":{"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n * @author dorkbox\n *         Date: 22/2/15\n */\npublic abstract class AbstractConcurrentSet<T> implements Set<T> {\n    private static final AtomicLong id = new AtomicLong();\n    private final long ID = id.getAndIncrement();\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public boolean add(T element) {\n        if (element == null) return false;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        boolean changed = insert(element);\n        writeLock.unlock();\n        return changed;\n    }\n\n    @Override\n    public boolean contains(Object element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private boolean insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> elements) {\n        boolean changed = false;\n\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    changed |= insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean remove(Object element) {\n        if (!contains(element)) {\n            // return quickly\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    // if it was second, now it's first\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        return this.entries.entrySet().toArray();\n    }\n\n    @SuppressWarnings(\"hiding\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return this.entries.entrySet().toArray(a);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"rawtypes\")\n        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n        if (this.ID != other.ID) {\n            return false;\n        }\n        return true;\n    }\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // can not nullify references to help GC since running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ConcurrentHashMapV8;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage;\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener;\n\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n\n        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n        subscriptionsPerMessage = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n        subscriptionsPerListener = new ConcurrentHashMapV8<Class, Collection<Subscription>>(50);\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        try {\n            readWriteLock.readLock().lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            if (isKnownNonListener(listener)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listener.getClass()).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listener.getClass());\n                    return;\n                }\n                subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandler messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        try {\n            readWriteLock.writeLock().lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n\n\n    }\n\n    private boolean isKnownNonListener(Object listener) {\n        Class listeningClass = listener.getClass();\n        return nonListeners.contains(listeningClass);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        try{\n            readWriteLock.readLock().lock();\n\n            if (subscriptionsPerMessage.get(messageType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n            }\n            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (Subscription sub : subs) {\n                        if (sub.handlesMessageType(messageType)) {\n                            subscriptions.add(sub);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readWriteLock.readLock().unlock();\n        }\n        return subscriptions;\n    }\n\n\n    // associate a subscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n *\n * @author bennidi\n *         Date: 2/12/12\n * @author dorkbox\n *         Date: 22/2/15\n */\npublic abstract class AbstractConcurrentSet<T> implements Set<T> {\n    private static final AtomicLong id = new AtomicLong();\n    private final long ID = id.getAndIncrement();\n\n    // Internal state\n    protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Map<T, ISetEntry<T>> entries; // maintain a map of entries for O(log n) lookup\n    protected Entry<T> head; // reference to the first element\n\n    protected AbstractConcurrentSet(Map<T, ISetEntry<T>> entries) {\n        this.entries = entries;\n    }\n\n    protected abstract Entry<T> createEntry(T value, Entry<T> next);\n\n    @Override\n    public boolean add(T element) {\n        if (element == null) return false;\n        Lock writeLock = lock.writeLock();\n        writeLock.lock();\n        boolean changed = insert(element);\n        writeLock.unlock();\n        return changed;\n    }\n\n    @Override\n    public boolean contains(Object element) {\n        Lock readLock = lock.readLock();\n        ISetEntry<T> entry;\n        try {\n            readLock.lock();\n            entry = entries.get(element);\n\n        } finally {\n            readLock.unlock();\n        }\n        return entry != null && entry.getValue() != null;\n    }\n\n    private boolean insert(T element) {\n        if (!entries.containsKey(element)) {\n            head = createEntry(element, head);\n            entries.put(element, head);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return entries.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> elements) {\n        boolean changed = false;\n\n        Lock writeLock = lock.writeLock();\n        try {\n            writeLock.lock();\n            for (T element : elements) {\n                if (element != null) {\n                    changed |= insert(element);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean remove(Object element) {\n        if (!contains(element)) {\n            // return quickly\n            return false;\n        } else {\n            Lock writeLock = lock.writeLock();\n            try {\n                writeLock.lock();\n                ISetEntry<T> listelement = entries.get(element);\n                if (listelement == null) {\n                    return false; //removed by other thread in the meantime\n                }\n                if (listelement != head) {\n                    listelement.remove();\n                } else {\n                    // if it was second, now it's first\n                    head = head.next();\n                    //oldHead.clear(); // optimize for GC not possible because of potentially running iterators\n                }\n                entries.remove(element);\n            } finally {\n                writeLock.unlock();\n            }\n            return true;\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        return this.entries.entrySet().toArray();\n    }\n\n    @SuppressWarnings(\"hiding\")\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return this.entries.entrySet().toArray(a);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }\n\n    @Override\n    public void clear() {\n        Lock writeLock = this.lock.writeLock();\n        try {\n            writeLock.lock();\n                head = null;\n                entries.clear();\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (int) (this.ID ^ this.ID >>> 32);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        @SuppressWarnings(\"rawtypes\")\n        AbstractConcurrentSet other = (AbstractConcurrentSet) obj;\n        if (this.ID != other.ID) {\n            return false;\n        }\n        return true;\n    }\n    public abstract static class Entry<T> implements ISetEntry<T> {\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n        protected Entry(Entry<T> next) {\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        protected Entry() {\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        @Override\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if (next != null) {\n                    next.predecessor = predecessor;\n                }\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            // can not nullify references to help GC since running iterators might not see the entire set\n            // if this element is their current element\n            //next = null;\n            //predecessor = null;\n        }\n\n        @Override\n        public Entry<T> next() {\n            return next;\n        }\n\n        @Override\n        public void clear() {\n            next = null;\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ConcurrentHashMapV8;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage;\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener;\n\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n\n        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n        subscriptionsPerMessage = new ConcurrentHashMapV8<Class, Collection<Subscription>>(64);\n        subscriptionsPerListener = new ConcurrentHashMapV8<Class, Collection<Subscription>>(64);\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        ReadLock readLock = readWriteLock.readLock();\n        try {\n            readLock.lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readLock.unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            Class<?> listenerClass = listener.getClass();\n\n            if (nonListeners.contains(listenerClass)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            \n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listenerClass).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listenerClass);\n                    return;\n                }\n                subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandler messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        WriteLock writeLock = readWriteLock.writeLock();\n        try {\n            writeLock.lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n\n\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        ReadLock readLock = readWriteLock.readLock();\n        try {\n            readLock.lock();\n\n            if (subscriptionsPerMessage.get(messageType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n            }\n            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (Subscription sub : subs) {\n                        if (sub.handlesMessageType(messageType)) {\n                            subscriptions.add(sub);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readLock.unlock();\n        }\n        return subscriptions;\n    }\n\n\n    // associate a subscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":[[154,154]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[58,58],[59,59],[127,127],[152,152],[168,168],[184,184],[92,92],[98,98],[100,100],[82,82],[85,85]]},"postChangeRange":{"src/main/java/net/engio/mbassy/common/AbstractConcurrentSet.java":[[154,154],[155,161]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[60,60],[61,61],[132,132],[134,134],[159,159],[169,169],[171,171],[187,187],[95,95],[97,97],[104,104],[106,106],[83,83],[85,85],[88,88]]},"microChanges":[],"refactorings":[{"type":"\"Inline Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java","startLine":92,"endLine":92}],"rightSideLocations":[]},{"type":"\"Extract Variable\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java","startLine":92,"endLine":92}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"fca9c6017cb8210a7dd216388bf66e7af3bfd45e","url":"https://github.com/bennidi/mbassador/commit/fca9c6017cb8210a7dd216388bf66e7af3bfd45e","preChangeSourceCode":{"src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class\n})\npublic class AllTests {\n}\n","src/main/java/net/engio/mbassy/AbstractMessageBus.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.dispatch.MessagingContext;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication<T>> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<MessagePublication<T>>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request){\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request, long timeout, TimeUnit unit){\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for(Subscription sub : subs){\n                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/net/engio/mbassy/IMessageBus.java":"package net.engio.mbassy;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Listener annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    public void subscribe(Object listener);\n\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     *\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return  true, if the listener was found and successfully removed\n     *          false otherwise\n     */\n    public boolean unsubscribe(Object listener);\n\n    /**\n     *\n     * @param message\n     * @return\n     */\n    public P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    public Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    public boolean hasPendingMessages();\n\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     *\n     */\n    public static interface IPostCommand<T>{\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        public void now();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        public MessagePublication<T> asynchronously();\n\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout r\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        public MessagePublication<T> asynchronously(long timeout, TimeUnit unit);\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/MBassador.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication<T> publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n                getSubscriptionsByMessageType(message.getClass()), message));\n    }\n\n    public MessagePublication<T> publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n                getSubscriptionsByMessageType(message.getClass()), message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            final Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n            if (subscriptions == null) {\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions) {\n                subscription.publish(message);\n            }\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/MessagePublication.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MessagePublication<T> {\n\n    public static <T> MessagePublication<T> Create(Collection<Subscription> subscriptions, T message){\n        return new MessagePublication<T>(subscriptions, message, State.Initial);\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private T message;\n\n    private State state = State.Scheduled;\n\n    private MessagePublication(Collection<Subscription> subscriptions, T message, State initialState) {\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute(){\n        state = State.Running;\n        for(Subscription sub : subscriptions){\n            sub.publish(message);\n        }\n        state = State.Finished;\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public MessagePublication<T> markScheduled(){\n        if(!state.equals(State.Initial))\n            return this;\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication<T> setError(){\n        state = State.Error;\n        return this;\n    }\n\n    private enum State{\n        Initial,Scheduled,Running,Finished,Error;\n    }\n\n}\n","src/main/java/net/engio/mbassy/SyncAsyncPostCommand.java":"package net.engio.mbassy;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * This post command provides access to standard synchronous and asynchronous dispatch\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n\n    private T message;\n    private MBassador<T> mBassador;\n\n    public SyncAsyncPostCommand(MBassador<T> mBassador, T message) {\n        this.mBassador = mBassador;\n        this.message = message;\n    }\n\n    @Override\n    public void now() {\n        mBassador.publish(message);\n    }\n\n    @Override\n    public MessagePublication<T> asynchronously() {\n        return mBassador.publishAsync(message);\n    }\n\n    @Override\n    public MessagePublication asynchronously(long timeout, TimeUnit unit) {\n        return mBassador.publishAsync(message, timeout, unit);\n    }\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class,\n        DeadEventTest.class\n})\npublic class AllTests {\n}\n","src/main/java/net/engio/mbassy/AbstractMessageBus.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.dispatch.MessagingContext;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<MessagePublication>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request){\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication addAsynchronousDeliveryRequest(MessagePublication request, long timeout, TimeUnit unit){\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for(Subscription sub : subs){\n                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/net/engio/mbassy/IMessageBus.java":"package net.engio.mbassy;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Listener annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    public void subscribe(Object listener);\n\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     *\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return  true, if the listener was found and successfully removed\n     *          false otherwise\n     */\n    public boolean unsubscribe(Object listener);\n\n    /**\n     *\n     * @param message\n     * @return\n     */\n    public P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    public Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    public boolean hasPendingMessages();\n\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     *\n     */\n    public static interface IPostCommand<T>{\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        public void now();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        public MessagePublication asynchronously();\n\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout r\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        public MessagePublication asynchronously(long timeout, TimeUnit unit);\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/MBassador.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n    private MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if (subscriptions == null || subscriptions.isEmpty()) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n            return MessagePublication.Create(subscriptions, new DeadEvent(message));\n        }\n        else return MessagePublication.Create(subscriptions, message);\n    }\n\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n\n            /*\n            final Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n            if (subscriptions == null || subscriptions.isEmpty()) {\n                // publish a DeadEvent since no subscriptions could be found\n                final Collection<Subscription> deadEventSubscriptions = getSubscriptionsByMessageType(DeadEvent.class);\n                if (deadEventSubscriptions != null && !deadEventSubscriptions.isEmpty()) {\n                    for (Subscription subscription : deadEventSubscriptions) {\n                        subscription.publish(new DeadEvent(message));\n                    }\n                }\n            }\n            else{\n                for (Subscription subscription : subscriptions) {\n                    subscription.publish(message);\n                }\n            }*/\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/MessagePublication.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.common.DeadEvent;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MessagePublication {\n\n    public static  MessagePublication Create(Collection<Subscription> subscriptions, Object message){\n        return new MessagePublication(subscriptions, message, State.Initial);\n    }\n\n    private Collection<Subscription> subscriptions;\n\n    private Object message;\n\n    private State state = State.Scheduled;\n\n    private MessagePublication(Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    protected void execute(){\n        state = State.Running;\n        for(Subscription sub : subscriptions){\n            sub.publish(message);\n        }\n        state = State.Finished;\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public MessagePublication markScheduled(){\n        if(!state.equals(State.Initial))\n            return this;\n        state = State.Scheduled;\n        return this;\n    }\n\n    public MessagePublication setError(){\n        state = State.Error;\n        return this;\n    }\n\n    public boolean isDeadEvent(){\n        return DeadEvent.class.isAssignableFrom(message.getClass());\n    }\n\n    private enum State{\n        Initial,Scheduled,Running,Finished,Error;\n    }\n\n}\n","src/main/java/net/engio/mbassy/SyncAsyncPostCommand.java":"package net.engio.mbassy;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * This post command provides access to standard synchronous and asynchronous dispatch\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n\n    private T message;\n    private MBassador<T> mBassador;\n\n    public SyncAsyncPostCommand(MBassador<T> mBassador, T message) {\n        this.mBassador = mBassador;\n        this.message = message;\n    }\n\n    @Override\n    public void now() {\n        mBassador.publish(message);\n    }\n\n    @Override\n    public MessagePublication asynchronously() {\n        return mBassador.publishAsync(message);\n    }\n\n    @Override\n    public MessagePublication asynchronously(long timeout, TimeUnit unit) {\n        return mBassador.publishAsync(message, timeout, unit);\n    }\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/AbstractMessageBus.java":[[59,59]],"src/main/java/net/engio/mbassy/MBassador.java":[[16,16],[17,17],[18,18],[36,38],[39,41],[21,21],[22,22],[23,23]],"src/main/java/net/engio/mbassy/IMessageBus.java":[[139,139],[152,152]],"src/main/java/net/engio/mbassy/MessagePublication.java":[[57,57],[64,64]],"src/main/java/net/engio/mbassy/SyncAsyncPostCommand.java":[[27,27]]},"postChangeRange":{"src/main/java/net/engio/mbassy/AbstractMessageBus.java":[[59,59]],"src/main/java/net/engio/mbassy/MBassador.java":[[17,17],[18,18],[45,45],[46,46],[21,21],[22,22]],"src/main/java/net/engio/mbassy/IMessageBus.java":[[139,139],[152,152]],"src/main/java/net/engio/mbassy/MessagePublication.java":[[58,58],[65,65]],"src/main/java/net/engio/mbassy/SyncAsyncPostCommand.java":[[27,27]]},"microChanges":[{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/MBassador.java","startLine":36,"endLine":36}],"rightSideLocations":[]}],"refactorings":[{"type":"\"Extract Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/MBassador.java","startLine":36,"endLine":36}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"54b3154ddc53e1511ec1bfc829f4bcccd35368f6","url":"https://github.com/bennidi/mbassador/commit/54b3154ddc53e1511ec1bfc829f4bcccd35368f6","preChangeSourceCode":{"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T>{\n\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) return this;\n        synchronized (this) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element){\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) return;\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size(){\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (this) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) return this;\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) return false;\n        synchronized (this) {\n            Entry<T> listelement = entries.get(element);\n            if(listelement == null)return false; //removed by other thread\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                Entry<T> oldHead = head;\n                head = head.next();\n                oldHead.next = null; // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) return null;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) return;\n                Entry<T> newCurrent = current.next();\n                ConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if(next != null)next.predecessor = predecessor;\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n\n    }\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":"package net.engio.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T>{\n\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) return this;\n        synchronized (this) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element){\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) return;\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size(){\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (this) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) return this;\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) return false;\n        synchronized (this) {\n            Entry<T> listelement = entries.get(element);\n            if(listelement == null)return false; //removed by other thread\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                Entry<T> oldHead = head;\n                head = head.next();\n                oldHead.next = null; // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                if (current.getValue() == null) {    // auto-removal of orphan references\n                    do {\n                        remove();\n                    } while(current != null && current.getValue() == null);\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) return null;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    do {\n                        remove();\n                    } while(current != null && current.getValue() == null);\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) return;\n                Entry<T> newCurrent = current.next();\n                ConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if(next != null)next.predecessor = predecessor;\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n\n    }\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":[[91,91],[92,94],[104,105]]},"postChangeRange":{"src/main/java/net/engio/mbassy/common/ConcurrentSet.java":[[91,95],[105,108]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":91,"endLine":91}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":92,"endLine":92}],"rightSideLocations":[]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":91,"endLine":91}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":92,"endLine":92}],"rightSideLocations":[]}],"refactorings":[{"type":"\"Inline Variable\"","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ConcurrentSet.java","startLine":91,"endLine":91}]}]},{"repository":"mbassador","sha1":"12a3e778e99564b1c7031516a26786a9a96362db","url":"https://github.com/bennidi/mbassador/commit/12a3e778e99564b1c7031516a26786a9a96362db","preChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    private int numberOfElements = 100000;\n    private int numberOfThreads = 50;\n\n    @Ignore(\"Currently fails when building as a suite with JDK 1.7.0_15 and Maven 3.0.5 on a Mac\")\n    @Test\n    public void testIteratorCleanup() {\n\n        // Assemble\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        final Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // Remove/Garbage collect all objects that have not\n        // been inserted into the set of persisting candidates.\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSet.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listener.Enveloped;\nimport net.engio.mbassy.listener.Filter;\nimport net.engio.mbassy.listener.Filters;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Mode;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Handler(delivery = Mode.Sequential)\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n    @Handler(delivery = Mode.Sequential, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/BusConfiguration.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.listener.MetadataReader;\nimport net.engio.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration {\n\n    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread thread = Executors.defaultThreadFactory().newThread(r);\n            thread.setDaemon(true);\n            return thread;\n        }\n    };\n\n    public static BusConfiguration Default() {\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    private SubscriptionFactory subscriptionFactory;\n\n    private MetadataReader metadataReader;\n\n    private MessagePublication.Factory messagePublicationFactory;\n\n    public BusConfiguration() {\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.subscriptionFactory = new SubscriptionFactory();\n        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n        this.metadataReader = new MetadataReader();\n        this.messagePublicationFactory = new MessagePublication.Factory();\n    }\n\n    public MessagePublication.Factory getMessagePublicationFactory() {\n        return messagePublicationFactory;\n    }\n\n    public void setMessagePublicationFactory(MessagePublication.Factory messagePublicationFactory) {\n        this.messagePublicationFactory = messagePublicationFactory;\n    }\n\n    public MetadataReader getMetadataReader() {\n        return metadataReader;\n    }\n\n    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n        this.metadataReader = metadataReader;\n        return this;\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n    public SubscriptionFactory getSubscriptionFactory() {\n        return subscriptionFactory;\n    }\n\n    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n        this.subscriptionFactory = subscriptionFactory;\n        return this;\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.*;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Handler\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Mode.Concurrent)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Handler(\n            priority = 10,\n            delivery = Mode.Sequential,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n    private MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(this, subscriptions, message);\n        }\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) {\n        Handler config = messageHandler.getAnnotation(Handler.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n\n        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handle = handler.getAnnotation(Handler.class);\n            if (!handle.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handle), handle);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * that lives inside a message bus.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext {\n\n    private IMessageBus owningBus;\n\n    private MessageHandlerMetadata handlerMetadata;\n\n    public SubscriptionContext(IMessageBus owningBus, MessageHandlerMetadata handlerMetadata) {\n        this.owningBus = owningBus;\n        this.handlerMetadata = handlerMetadata;\n    }\n\n    /**\n     * Get a reference to the message bus this context belongs to\n     *\n     * @return\n     */\n    public IMessageBus getOwningBus() {\n        return owningBus;\n    }\n\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.dispatch.AsynchronousHandlerInvocation;\nimport net.engio.mbassy.dispatch.EnvelopedMessageDispatcher;\nimport net.engio.mbassy.dispatch.FilteredMessageDispatcher;\nimport net.engio.mbassy.dispatch.IHandlerInvocation;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\nimport net.engio.mbassy.dispatch.MessageDispatcher;\nimport net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author bennidi\n *         Date: 11/16/12\n *         Time: 10:39 AM\n *         To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context) {\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) {\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.ListenerSubscriptionTest;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class,\n        DeadEventTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/DeadEventTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEventTest extends MessageBusTest{\n\n\n    @Test\n    public void testDeadEvent(){\n        MBassador bus = getBus(BusConfiguration.Default());\n        DeadEventHandler deadEventHandler = new DeadEventHandler();\n        bus.subscribe(deadEventHandler);\n        assertEquals(0, deadEventHandler.getDeadEventCount());\n        bus.post(new Object()).now();\n        assertEquals(1, deadEventHandler.getDeadEventCount());\n        bus.post(323).now();\n        assertEquals(2, deadEventHandler.getDeadEventCount());\n        bus.publish(\"fkdfdk\");\n        assertEquals(3, deadEventHandler.getDeadEventCount());\n    }\n\n    public class DeadEventHandler{\n\n         private ConcurrentSet deadEvents = new ConcurrentSet();\n\n        @Handler\n         public void handle(DeadMessage message){\n             deadEvents.add(message);\n         }\n\n\n        public int getDeadEventCount(){\n            return deadEvents.size();\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n * <p/>\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * This interface marks components that have access to the subscription context.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface ISubscriptionContextAware extends IMessageBusAware {\n\n    /**\n     * Get the subscription context associated with this object\n     *\n     * @return the subscription context associated with this object\n     */\n    SubscriptionContext getContext();\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n * <p/>\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n * <p/>\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message     The message that should be delivered to the listeners\n     * @param listeners   The listeners that should receive the message\n     */\n    void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the\n     * message to each listener.\n     *\n     * @return the handler invocation that will be used to deliver the\n     *         message to each listener\n     */\n    IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private SubscriptionContext context;\n\n    public Subscription(SubscriptionContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.dispatch.ISubscriptionContextAware;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware implements ISubscriptionContextAware {\n\n    private SubscriptionContext context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext getContext() {\n        return context;\n    }\n\n    @Override\n    public IMessageBus getBus() {\n        return context.getOwningBus();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error) {\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for (IPublicationErrorHandler handler : handlers) {\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler) {\n        try {\n            handler.invoke(listener, message);\n        } catch (IllegalAccessException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        } catch (IllegalArgumentException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        } catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        } catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware implements IHandlerInvocation {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Handler(delivery = Mode.Sequential)\n    public void handleSubTestEvent(SubTestMessage message) {\n        super.handleSubTestEvent(message);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/DelegatingMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * A delegating dispatcher wraps additional logic around a given delegate. Essentially its\n * an implementation of the decorator pattern.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IMessageDispatcher delegate;\n\n\n    public DelegatingMessageDispatcher(IMessageDispatcher delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    protected IMessageDispatcher getDelegate() {\n        return delegate;\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return delegate.getInvocation();\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Handler.java":"package net.engio.mbassy.listener;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Mark any method of any object(=listener) as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Handler {\n\n    /**\n     * Add any numbers of filters to the handler. All filters are evaluated before the handler\n     * is actually invoked, which is only if all the filters accept the message.\n     */\n    Filter[] filters() default {};\n\n    /**\n     * Define the mode in which a message is delivered to each listener. Listeners can be notified\n     * sequentially or concurrently.\n     */\n    Mode delivery() default Mode.Sequential;\n\n    /**\n     * Handlers are ordered by priority and handlers with higher priority are processed before\n     * those with lower priority, i.e. Influence the order in which different handlers that consume\n     * the same message type are invoked.\n     */\n    int priority() default 0;\n\n    /**\n     * Define whether or not the handler accepts sub types of the message type it declares in its\n     * signature.\n     */\n    boolean rejectSubtypes() default false;\n\n\n    /**\n     * Enable or disable the handler. Disabled handlers do not receive any messages.\n     * This property is useful for quick changes in configuration and necessary to disable\n     * handlers that have been declared by a superclass but do not apply to the subclass\n     */\n    boolean enabled() default true;\n\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n * <p/>\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        publication.markDelivered();\n        for (Object listener : listeners) {\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    void subscribe(Object listener);\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     * <p/>\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return true, if the listener was found and successfully removed\n     *         false otherwise\n     */\n    boolean unsubscribe(Object listener);\n\n    /**\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     */\n    interface IPostCommand<T> {\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        void now();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        MessagePublication asynchronously();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout is reached.\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        MessagePublication asynchronously(long timeout, TimeUnit unit);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.ConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (IMessageFilter aFilter : filter) {\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, ConcurrentSet listeners) {\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.*;\nimport org.junit.Test;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listeners.ListenerFactory;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation extends ISubscriptionContextAware {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    void invoke(Object listener, Object message);\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Handler handlerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Mode.Concurrent);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        if (this.envelope != null) {\n            Collections.addAll(handledMessages, envelope.messages());\n        } else {\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous() {\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered() {\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority() {\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.IMessageBus;\n\n/**\n * This interface marks components that have access to the message bus that they belong to.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface IMessageBusAware {\n\n    IMessageBus getBus();\n}\n","src/test/java/net/engio/mbassy/MessagePublicationTest.java":"package net.engio.mbassy;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.events.SubTestMessage;\nimport org.junit.Test;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listeners.EventingTestBean;\nimport net.engio.mbassy.listeners.EventingTestBean2;\nimport net.engio.mbassy.listeners.EventingTestBean3;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport net.engio.mbassy.listeners.MultiEventHandler;\nimport net.engio.mbassy.listeners.NonListeningBean;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MessagePublicationTest extends MessageBusTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class)\n                .create(10000, MultiEventHandler.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n        TestMessage2 message2 = new TestMessage2();\n\n        bus.publishAsync(message);\n        bus.publishAsync(subMessage);\n        bus.publishAsync(message2);\n\n        pause(processingTimeInMS);\n\n        assertEquals(50000, message.counter.get());\n        assertEquals(80000, subMessage.counter.get());\n        assertEquals(20000, message2.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, message.counter.get());\n        assertEquals(70000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n        final CopyOnWriteArrayList<SubTestMessage> subtestMessages = new CopyOnWriteArrayList<SubTestMessage>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestMessage message = new TestMessage();\n                    SubTestMessage subMessage = new SubTestMessage();\n                    testMessages.add(message);\n                    subtestMessages.add(subMessage);\n\n                    bus.publishAsync(message);\n                    bus.publish(subMessage);\n                }\n            }\n        }, 10);\n\n        pause(processingTimeInMS);\n\n        for (TestMessage message : testMessages) {\n            assertEquals(30000, message.counter.get());\n        }\n\n        for (SubTestMessage message : subtestMessages) {\n            assertEquals(70000, message.counter.get());\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Mode;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Mode.Sequential)\n    public void handleSubTestEventAgain(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\nimport org.junit.Test;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n    \n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSetWeak.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSetWeak.contains(uniqueObject));\n        }\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final IConcurrentSet weakConcurrentSet = createSet();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            weakConcurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                    if (toRemove.contains(src))\n                        testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSetWeak.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class MultiEventHandler {\n\n\n    @Handler(delivery = Invoke.Synchronously)\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n    @Handler(delivery = Invoke.Synchronously, filters = @Filter(Filters.RejectSubtypes.class))\n    @Enveloped(messages = {TestMessage.class, TestMessage2.class})\n    public void handleSuperTypeEvents(MessageEnvelope envelope) {\n        if(TestMessage.class.isAssignableFrom(envelope.getMessage().getClass())){\n            TestMessage message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n        if(envelope.getMessage().getClass().equals(TestMessage2.class)){\n            TestMessage2 message = envelope.getMessage();\n            message.counter.incrementAndGet();\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/BusConfiguration.java":"package net.engio.mbassy.bus;\n\nimport java.util.concurrent.*;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration extends SyncBusConfiguration<BusConfiguration> {\n\n    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread thread = Executors.defaultThreadFactory().newThread(r);\n            thread.setDaemon(true);\n            return thread;\n        }\n    };\n\n    public static BusConfiguration Default() {\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    public BusConfiguration() {\n        super();\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    /**\n     * By default an unbound queuing strategy is used to ensure that no events get lost\n     * @return\n     */\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Handler\n    public void handleTestEvent(TestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Invoke.Asynchronously, invocation = HandleSubTestEventInvocation.class)\n    public void handleSubTestEvent(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Handler(\n            priority = 10,\n            delivery = Invoke.Synchronously,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n    public static class HandleSubTestEventInvocation extends HandlerInvocation<EventingTestBean, SubTestMessage> {\n\n        public HandleSubTestEventInvocation(SubscriptionContext context) {\n            super(context);\n        }\n\n        @Override\n        public void invoke(EventingTestBean listener, SubTestMessage message) {\n            listener.handleSubTestEvent(message);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message));\n    }\n\n    public MessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(createMessagePublication(message), timeout, unit);\n    }\n\n    private MessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(this, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(this, subscriptions, message);\n        }\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            MessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        Listener listenerConfig = target.getAnnotation(Listener.class);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        List<MessageHandlerMetadata> filteredHandlers = new LinkedList<MessageHandlerMetadata>();\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = handler.getAnnotation(Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            MessageHandlerMetadata handlerMetadata = new MessageHandlerMetadata(overriddenHandler == null ? handler : overriddenHandler,\n                    getFilter(handlerConfig), handlerConfig, listenerConfig);\n            filteredHandlers.add(handlerMetadata);\n\n        }\n        return filteredHandlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || handler.getAnnotation(Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\n/**\n * The subscription context holds all (meta)data/objects that are relevant to successfully publish\n * a message within a subscription. A one-to-one relation between a subscription and\n * subscription context holds -> a subscription context is created for each distinct subscription\n * that lives inside a message bus.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class SubscriptionContext<Bus extends ISyncMessageBus> {\n\n    private Bus owningBus;\n\n    private MessageHandlerMetadata handlerMetadata;\n\n    public SubscriptionContext(Bus owningBus, MessageHandlerMetadata handlerMetadata) {\n        this.owningBus = owningBus;\n        this.handlerMetadata = handlerMetadata;\n    }\n\n    /**\n     * Get a reference to the message bus this context belongs to\n     *\n     * @return\n     */\n    public Bus getOwningBus() {\n        return owningBus;\n    }\n\n\n    /**\n     * Get the meta data that specifies the characteristics of the message handler\n     * that is associated with this context\n     *\n     * @return\n     */\n    public MessageHandlerMetadata getHandlerMetadata() {\n        return handlerMetadata;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.MessageBusException;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author bennidi\n *         Date: 11/16/12\n *         Time: 10:39 AM\n *         To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(SubscriptionContext context) throws MessageBusException{\n        try {\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, context.getHandlerMetadata().useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws Exception {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n        return constructor.newInstance(context);\n    }\n}\n","src/test/java/net/engio/mbassy/AllTests.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.ListenerSubscriptionTest;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        StrongConcurrentSetTest.class,\n        WeakConcurrentSetTest.class,\n        MessagePublicationTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class,\n        ListenerSubscriptionTest.class,\n        MethodDispatchTest.class,\n        DeadEventTest.class,\n        SynchronizedHandlerTest.class\n})\npublic class AllTests {\n}\n","src/test/java/net/engio/mbassy/DeadEventTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport org.junit.Test;\n\n/**\n * Verify correct behaviour in case of message publications that do not have any matching subscriptions\n *\n * @author bennidi\n *         Date: 1/18/13\n */\npublic class DeadEventTest extends MessageBusTest{\n\n\n    @Test\n    public void testDeadEvent(){\n        MBassador bus = getBus(BusConfiguration.Default());\n        DeadEventHandler deadEventHandler = new DeadEventHandler();\n        bus.subscribe(deadEventHandler);\n        assertEquals(0, deadEventHandler.getDeadEventCount());\n        bus.post(new Object()).now();\n        assertEquals(1, deadEventHandler.getDeadEventCount());\n        bus.post(323).now();\n        assertEquals(2, deadEventHandler.getDeadEventCount());\n        bus.publish(\"fkdfdk\");\n        assertEquals(3, deadEventHandler.getDeadEventCount());\n    }\n\n    public class DeadEventHandler{\n\n         private WeakConcurrentSet deadEvents = new WeakConcurrentSet();\n\n        @Handler\n         public void handle(DeadMessage message){\n             deadEvents.add(message);\n         }\n\n\n        public int getDeadEventCount(){\n            return deadEvents.size();\n        }\n\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/EnvelopedMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\n/**\n * The enveloped dispatcher will wrap published messages in an envelope before\n * passing them to their configured dispatcher.\n * <p/>\n * All enveloped message handlers will have this dispatcher in their chain\n *\n * @author bennidi\n *         Date: 12/12/12\n */\npublic class EnvelopedMessageDispatcher extends DelegatingMessageDispatcher {\n\n\n    public EnvelopedMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n    }\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners) {\n        getDelegate().dispatch(publication, new MessageEnvelope(message), listeners);\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ISubscriptionContextAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * This interface marks components that have access to the subscription context.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface ISubscriptionContextAware<Bus extends ISyncMessageBus> extends IMessageBusAware<Bus> {\n\n    /**\n     * Get the subscription context associated with this object\n     *\n     * @return the subscription context associated with this object\n     */\n    SubscriptionContext getContext();\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\n\n/**\n * A message dispatcher provides the functionality to deliver a single message\n * to a set of listeners. A message dispatcher uses a message context to access\n * all information necessary for the message delivery.\n * <p/>\n * The delivery of a single message to a single listener is responsibility of the\n * handler invocation object associated with the dispatcher.\n * <p/>\n * Implementations if IMessageDispatcher are partially designed using decorator pattern\n * such that it is possible to compose different message dispatchers into dispatcher chains\n * to achieve more complex dispatch logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IMessageDispatcher extends ISubscriptionContextAware {\n\n    /**\n     * Delivers the given message to the given set of listeners.\n     * Delivery may be delayed, aborted or restricted in various ways, depending\n     * on the configuration of the dispatcher\n     *\n     * @param publication The message publication that initiated the dispatch\n     * @param message     The message that should be delivered to the listeners\n     * @param listeners   The listeners that should receive the message\n     */\n    void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners);\n\n    /**\n     * Get the handler invocation that will be used to deliver the\n     * message to each listener.\n     *\n     * @return the handler invocation that will be used to deliver the\n     *         message to each listener\n     */\n    IHandlerInvocation getInvocation();\n}\n","src/main/java/net/engio/mbassy/subscription/Subscription.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.dispatch.IMessageDispatcher;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private final UUID id = UUID.randomUUID();\n\n    protected final IConcurrentSet<Object> listeners;\n\n    private final IMessageDispatcher dispatcher;\n\n    private final SubscriptionContext context;\n\n    Subscription(SubscriptionContext context, IMessageDispatcher dispatcher, IConcurrentSet<Object> listeners) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n        this.listeners = listeners;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType) {\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(MessagePublication publication, Object message) {\n        dispatcher.dispatch(publication, message, listeners);\n    }\n\n    public int getPriority() {\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size() {\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result = o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id) : result;\n        }\n    };\n\n}\n","src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.dispatch.ISubscriptionContextAware;\n\n/**\n * The base implementation for subscription context aware objects (mightily obvious :)\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic class AbstractSubscriptionContextAware<Bus extends ISyncMessageBus> implements ISubscriptionContextAware<Bus> {\n\n    private final SubscriptionContext<Bus> context;\n\n    public AbstractSubscriptionContextAware(SubscriptionContext<Bus> context) {\n        this.context = context;\n    }\n\n    public SubscriptionContext<Bus> getContext() {\n        return context;\n    }\n\n    @Override\n    public Bus getBus() {\n        return context.getOwningBus();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/ReflectiveHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.IPublicationErrorHandler;\nimport net.engio.mbassy.PublicationError;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\n\n/**\n * Uses reflection to invoke a message handler for a given message.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class ReflectiveHandlerInvocation extends HandlerInvocation{\n\n    public ReflectiveHandlerInvocation(SubscriptionContext context) {\n        super(context);\n    }\n\n    protected void handlePublicationError(PublicationError error) {\n        Collection<IPublicationErrorHandler> handlers = getContext().getOwningBus().getRegisteredErrorHandlers();\n        for (IPublicationErrorHandler handler : handlers) {\n            handler.handleError(error);\n        }\n    }\n\n    protected void invokeHandler(final Object message, final Object listener, Method handler) {\n        try {\n            handler.invoke(listener, message);\n        } catch (IllegalAccessException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"The class or method is not accessible\",\n                            handler, listener, message));\n        } catch (IllegalArgumentException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Wrong arguments passed to method. Was: \" + message.getClass()\n                            + \"Expected: \" + handler.getParameterTypes()[0],\n                            handler, listener, message));\n        } catch (InvocationTargetException e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Message handler threw exception\",\n                            handler, listener, message));\n        } catch (Throwable e) {\n            handlePublicationError(\n                    new PublicationError(e, \"Error during messageHandler notification. \" +\n                            \"Unexpected exception\",\n                            handler, listener, message));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        invokeHandler(message, listener, getContext().getHandlerMetadata().getHandler());\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/AsynchronousHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.IMessageBus;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * This invocation will schedule the wrapped (decorated) invocation to be executed asynchronously\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class AsynchronousHandlerInvocation extends AbstractSubscriptionContextAware<IMessageBus> implements IHandlerInvocation<Object,Object,IMessageBus> {\n\n    private IHandlerInvocation delegate;\n\n    public AsynchronousHandlerInvocation(IHandlerInvocation delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void invoke(final Object listener, final Object message) {\n        getContext().getOwningBus().getExecutor().execute(new Runnable() {\n            @Override\n            public void run() {\n                delegate.invoke(listener, message);\n            }\n        });\n    }\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\n@Listener(references = References.Strong)\npublic class EventingTestBean2 extends EventingTestBean{\n\n    // redefine the configuration for this handler\n    @Handler(delivery = Invoke.Synchronously)\n    public void handleSubTestEvent(SubTestMessage message) {\n        super.handleSubTestEvent(message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/DelegatingMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\n\n/**\n * A delegating dispatcher wraps additional logic around a given delegate. Essentially its\n * an implementation of the decorator pattern.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic abstract class DelegatingMessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private final IMessageDispatcher delegate;\n\n\n    public DelegatingMessageDispatcher(IMessageDispatcher delegate) {\n        super(delegate.getContext());\n        this.delegate = delegate;\n    }\n\n    protected IMessageDispatcher getDelegate() {\n        return delegate;\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return delegate.getInvocation();\n    }\n}\n","src/main/java/net/engio/mbassy/listener/Handler.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any object(=listener) as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Handler {\n\n    /**\n     * Add any numbers of filters to the handler. All filters are evaluated before the handler\n     * is actually invoked, which is only if all the filters accept the message.\n     */\n    Filter[] filters() default {};\n\n    /**\n     * Define the mode in which a message is delivered to each listener. Listeners can be notified\n     * sequentially or concurrently.\n     */\n    Invoke delivery() default Invoke.Synchronously;\n\n    /**\n     * Handlers are ordered by priority and handlers with higher priority are processed before\n     * those with lower priority, i.e. Influence the order in which different handlers that consume\n     * the same message type are invoked.\n     */\n    int priority() default 0;\n\n    /**\n     * Define whether or not the handler accepts sub types of the message type it declares in its\n     * signature.\n     */\n    boolean rejectSubtypes() default false;\n\n\n    /**\n     * Enable or disable the handler. Disabled handlers do not receive any messages.\n     * This property is useful for quick changes in configuration and necessary to disable\n     * handlers that have been declared by a superclass but do not apply to the subclass\n     */\n    boolean enabled() default true;\n\n\n    /**\n     * Each handler call is implemented as an invocation object that implements the invocation mechanism.\n     * The basic implementation uses reflection and is the default. It is possible though to provide a custom\n     * invocation to add additional logic.\n     *\n     * Note: Providing a custom invocation will most likely reduce performance, since the JIT-Compiler\n     * can not do some of its sophisticated byte code optimizations.\n     *\n     */\n    Class<? extends HandlerInvocation> invocation() default ReflectiveHandlerInvocation.class;\n\n\n}\n","src/main/java/net/engio/mbassy/dispatch/MessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.subscription.AbstractSubscriptionContextAware;\nimport net.engio.mbassy.subscription.SubscriptionContext;\n\n/**\n * Standard implementation for direct, unfiltered message delivery.\n * <p/>\n * For each message delivery, this dispatcher iterates over the listeners\n * and uses the previously provided handler invocation to deliver the message\n * to each listener\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class MessageDispatcher extends AbstractSubscriptionContextAware implements IMessageDispatcher {\n\n    private final IHandlerInvocation invocation;\n\n    public MessageDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        super(context);\n        this.invocation = invocation;\n    }\n\n    @Override\n    public void dispatch(final MessagePublication publication, final Object message, final IConcurrentSet listeners) {\n        publication.markDelivered();\n        for (Object listener : listeners) {\n            getInvocation().invoke(listener, message);\n        }\n    }\n\n    @Override\n    public IHandlerInvocation getInvocation() {\n        return invocation;\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessageBus.java":"package net.engio.mbassy.bus;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Handler annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n * <p/>\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> extends ISyncMessageBus<T,P> {\n\n    /**\n     * Get the executor service that is used for asynchronous message publications.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    boolean hasPendingMessages();\n\n    /**\n     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and\n     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe\n     * to further use the message bus.\n     */\n    void shutdown();\n\n    /**\n     * @param message\n     * @return\n     */\n    P post(T message);\n\n\n    interface IPostCommand extends ISyncPostCommand {\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        MessagePublication asynchronously();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         * <p/>\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout is reached.\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        MessagePublication asynchronously(long timeout, TimeUnit unit);\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (IMessageFilter aFilter : filter) {\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, IConcurrentSet listeners) {\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/test/java/net/engio/mbassy/FilterTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.DeadMessage;\nimport net.engio.mbassy.common.FilteredMessage;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.listener.*;\nimport net.engio.mbassy.listeners.ListenerFactory;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends MessageBusTest {\n\n    private static final AtomicInteger FilteredEventCounter = new AtomicInteger(0);\n    private static final AtomicInteger DeadEventCounter = new AtomicInteger(0);\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subTestMessage = new SubTestMessage();\n\n        bus.post(message).now();\n        bus.post(subTestMessage).now();\n\n        assertEquals(100, message.counter.get());\n        assertEquals(0, subTestMessage.counter.get());\n        assertEquals(100, FilteredEventCounter.get());\n    }\n\n    @Test\n    public void testFilteredFilteredEvent() throws Exception {\n        FilteredEventCounter.set(0);\n        DeadEventCounter.set(0);\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        bus.post(new Object()).now();\n        bus.post(new SubTestMessage()).now();\n\n        assertEquals(100, FilteredEventCounter.get()); // the SubTestMessage should have been republished as a filtered event\n        assertEquals(100, DeadEventCounter.get()); // Object.class was filtered and the fil\n    }\n\n    public static class FilteredMessageListener{\n\n        // NOTE: Use rejectSubtypes property of @Handler to achieve the same functionality but with better performance\n        // and more concise syntax\n        @Handler(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestMessage(TestMessage message){\n            message.counter.incrementAndGet();\n        }\n\n        // FilteredEvents that contain messages of class Object will be filtered (again) and should cause a DeadEvent to be thrown\n        @Handler(filters = {@Filter(RejectFilteredObjects.class)})\n        public void handleFilteredEvent(FilteredMessage filtered){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler(filters = {@Filter(Filters.RejectAll.class)})\n        public void handleNone(Object any){\n            FilteredEventCounter.incrementAndGet();\n        }\n\n        // will cause republication of a FilteredEvent\n        @Handler\n        public void handleDead(DeadMessage dead){\n            DeadEventCounter.incrementAndGet();\n        }\n\n\n    }\n\n    public static class RejectFilteredObjects implements IMessageFilter{\n\n        @Override\n        public boolean accepts(Object message, MessageHandlerMetadata metadata) {\n            if(message.getClass().equals(FilteredMessage.class) && ((FilteredMessage)message).getMessage().getClass().equals(Object.class)){\n                return false;\n            }\n            return true;\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/IHandlerInvocation.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\n\n/**\n * A handler invocation encapsulates the logic that is used to invoke a single\n * message handler to process a given message.\n * A handler invocation might come in different flavours and can be composed\n * of various independent invocations be means of delegation (decorator pattern)\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic interface IHandlerInvocation<Listener, Message, Bus extends ISyncMessageBus> extends ISubscriptionContextAware<Bus> {\n\n    /**\n     * Invoke the message delivery logic of this handler\n     *\n     * @param listener The listener that will receive the message\n     * @param message  The message to be delivered to the listener\n     */\n    void invoke(Listener listener, Message message);\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandlerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private final Method handler;\n\n    private final IMessageFilter[] filter;\n\n    private final Handler handlerConfig;\n\n    private final boolean isAsynchronous;\n\n    private final Enveloped envelope;\n\n    private final List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private final boolean acceptsSubtypes;\n\n    private final Listener listenerConfig;\n\n    private final boolean isSynchronized;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Handler handlerConfig, Listener listenerConfig) {\n        if(handler == null || handlerConfig == null){\n            throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n        }\n        this.handler = handler;\n        this.filter = filter;\n        this.handlerConfig = handlerConfig;\n        this.isAsynchronous = handlerConfig.delivery().equals(Invoke.Asynchronously);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = !handlerConfig.rejectSubtypes();\n        this.listenerConfig = listenerConfig;\n        this.isSynchronized = handler.getAnnotation(Synchronized.class) != null;\n        if (this.envelope != null) {\n            for(Class messageType : envelope.messages()){\n                handledMessages.add(messageType);\n            }\n        } else {\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n    public boolean isSynchronized(){\n        return isSynchronized;\n    }\n\n    public boolean useStrongReferences(){\n        return listenerConfig != null && listenerConfig.references().equals(References.Strong);\n    }\n\n    public boolean isAsynchronous() {\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered() {\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority() {\n        return handlerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\n        return handlerConfig.invocation();\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n\n    public boolean isEnabled() {\n        return handlerConfig.enabled();\n    }\n}\n","src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.ISyncMessageBus;\n\n/**\n * This interface marks components that have access to the message bus that they belong to.\n *\n * @author bennidi\n *         Date: 3/1/13\n */\npublic interface IMessageBusAware<Bus extends ISyncMessageBus> {\n\n    Bus getBus();\n}\n","src/test/java/net/engio/mbassy/MessagePublicationTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusConfiguration;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.events.TestMessage;\nimport net.engio.mbassy.events.TestMessage2;\nimport net.engio.mbassy.listeners.*;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MessagePublicationTest extends MessageBusTest {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    private int processingTimeInMS = 4000;\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class)\n                .create(10000, MultiEventHandler.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n        TestMessage2 message2 = new TestMessage2();\n\n        bus.publishAsync(message);\n        bus.publishAsync(subMessage);\n        bus.publishAsync(message2);\n\n        pause(processingTimeInMS);\n\n        assertEquals(50000, message.counter.get());\n        assertEquals(80000, subMessage.counter.get());\n        assertEquals(20000, message2.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(30000, message.counter.get());\n        assertEquals(70000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testStrongListenerSubscription() throws Exception {\n\n        MBassador bus = getBus(new BusConfiguration());\n\n\n        for(int i = 0; i< 10000; i++){\n            bus.subscribe(new EventingTestBean2());\n        }\n\n        runGC();\n\n        TestMessage message = new TestMessage();\n        TestMessage subMessage = new SubTestMessage();\n\n        bus.publish(message);\n        bus.publish(subMessage);\n\n        pause(processingTimeInMS);\n\n        assertEquals(10000, message.counter.get());\n        assertEquals(20000, subMessage.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestMessage> testMessages = new CopyOnWriteArrayList<TestMessage>();\n        final CopyOnWriteArrayList<SubTestMessage> subtestMessages = new CopyOnWriteArrayList<SubTestMessage>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = getBus(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(10000, EventingTestBean.class)\n                .create(10000, EventingTestBean2.class)\n                .create(10000, EventingTestBean3.class)\n                .create(10000, Object.class)\n                .create(10000, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestMessage message = new TestMessage();\n                    SubTestMessage subMessage = new SubTestMessage();\n                    testMessages.add(message);\n                    subtestMessages.add(subMessage);\n\n                    bus.publishAsync(message);\n                    bus.publish(subMessage);\n                }\n            }\n        }, 10);\n\n        pause(processingTimeInMS);\n\n        for (TestMessage message : testMessages) {\n            assertEquals(30000, message.counter.get());\n        }\n\n        for (SubTestMessage message : subtestMessages) {\n            assertEquals(70000, message.counter.get());\n        }\n\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":"package net.engio.mbassy.listeners;\n\nimport net.engio.mbassy.events.SubTestMessage;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Listener;\nimport net.engio.mbassy.listener.References;\n\n/**\n * @author bennidi\n * Date: 11/22/12\n */\n@Listener(references = References.Strong)\npublic class EventingTestBean3 extends EventingTestBean2{\n\n\n    // this handler will be invoked asynchronously\n    @Handler(priority = 0, delivery = Invoke.Synchronously)\n    public void handleSubTestEventAgain(SubTestMessage message) {\n        message.counter.incrementAndGet();\n    }\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[77,77],[95,95],[101,101],[103,103],[226,226],[232,232],[241,241],[249,249],[251,251],[258,258],[264,264],[272,272],[282,282],[284,284],[141,141],[156,156],[166,166],[172,172],[177,177],[179,179],[188,188],[204,204],[206,206],[212,212],[217,217],[219,219],[113,113],[129,129]],"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":[[21,21],[34,34]],"src/main/java/net/engio/mbassy/bus/BusConfiguration.java":[[49,49],[51,51],[52,52]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[99,99]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":[[23,23],[32,32]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":[[14,14]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[80,80],[81,81],[87,87]],"src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":[[13,13]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":[[15,15]],"src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":[[31,31]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[28,28],[21,25]],"src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":[[25,25],[20,20]]},"postChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[40,40],[58,58],[64,64],[66,66],[189,189],[195,195],[204,204],[212,212],[214,214],[221,221],[227,227],[235,235],[245,245],[247,247],[104,104],[119,119],[129,129],[135,135],[140,140],[142,142],[151,151],[167,167],[169,169],[175,175],[180,180],[182,182],[76,76],[92,92]],"src/test/java/net/engio/mbassy/listeners/MultiEventHandler.java":[[18,18],[31,31]],"src/main/java/net/engio/mbassy/bus/BusConfiguration.java":[[33,33],[48,51]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean.java":[[25,25],[34,34]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean2.java":[[17,17]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[62,62],[77,77],[78,78],[84,84]],"src/main/java/net/engio/mbassy/subscription/SubscriptionContext.java":[[31,31]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[33,33],[34,34],[35,37],[21,31]],"src/main/java/net/engio/mbassy/bus/IMessageBus.java":[[50,50]],"src/test/java/net/engio/mbassy/FilterTest.java":[[31,31],[32,32]],"src/main/java/net/engio/mbassy/dispatch/IMessageBusAware.java":[[13,13]],"src/test/java/net/engio/mbassy/listeners/EventingTestBean3.java":[[18,18]],"src/main/java/net/engio/mbassy/subscription/AbstractSubscriptionContextAware.java":[[25,25],[20,20]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java","startLine":35,"endLine":35}]}],"refactorings":[{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":81,"endLine":81}],"rightSideLocations":[]},{"type":"\"Change Variable Type\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":219,"endLine":219}],"rightSideLocations":[]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":219,"endLine":219}],"rightSideLocations":[]},{"type":"\"Change Variable Type\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":179,"endLine":179}],"rightSideLocations":[]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":179,"endLine":179}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"21385b605ed17f0de1b9e2c845b6128ceeae81ca","url":"https://github.com/bennidi/mbassador/commit/21385b605ed17f0de1b9e2c845b6128ceeae81ca","preChangeSourceCode":{"src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listeners.*;\nimport org.mbassy.subscription.Subscription;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends UnitTest {\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = new MBassador();\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 1000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(300, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(1000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publishAsync(event);\n        bus.publishAsync(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publish(event);\n        bus.publish(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n            }\n        }, 10);\n\n        pause(3000);\n\n        for (TestEvent event : testEvents) {\n            assertEquals(300, event.counter.get());\n        }\n\n        for (SubTestEvent event : subtestEvents) {\n            assertEquals(700, event.counter.get());\n        }\n\n    }\n\n\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private MetadataReader metadataReader = new MetadataReader();\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private CopyOnWriteArrayList<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n\n\n\n    public AbstractMessageBus() {\n        this(2);\n    }\n\n    public AbstractMessageBus(int dispatcherThreadCount) {\n        this(dispatcherThreadCount, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n    }\n\n    public AbstractMessageBus(int dispatcherThreadCount, ExecutorService executor) {\n        this.executor = executor;\n        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n        subscriptionFactory = getSubscriptionFactory();\n    }\n\n    // use this method to introduce a custom subscription factory for extension\n    protected abstract SubscriptionFactory getSubscriptionFactory();\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            handlePublicationError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially for each class\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<Method> messageHandlers = metadataReader.getListeners(listeningClass);  // get all methods with subscriptions\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        // create subscriptions for all detected listeners\n                        for (Method messageHandler : messageHandlers) {\n                            if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n                            Class eventType = getMessageType(messageHandler);\n                            Subscription subscription = subscriptionFactory.createSubscription(metadataReader.getHandlerMetadata(messageHandler));\n                            subscription.subscribe(listener);\n                            addMessageTypeSubscription(eventType, subscription);\n                            subscriptionsByListener.add(subscription);\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n        pendingMessages.offer(request);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new CopyOnWriteArraySet<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        return true;\n    }\n\n    private static Class getMessageType(Method listener) {\n        return listener.getParameterTypes()[0];\n    }\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/test/java/org/mbassy/ConcurrentSetTest.java":"package org.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Test;\nimport org.mbassy.common.ConcurrentSet;\n\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n *\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    private int numberOfElements = 100000;\n\n    private int numberOfThreads = 50;\n\n\n    @Test\n    public void testIteratorCleanup() {\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // this will remove all objects that have not been inserted into the set of persisting candidates\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n\n\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n\n\n    }\n\n    @Test\n    public void testPerformance(){\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for(Object o: source){\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for(Object o: source){\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionDeliveryRequest.java":"package org.mbassy.subscription;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\n\n/**\n * @author bennidi\n * Date: 11/16/12\n */\npublic class SubscriptionDeliveryRequest<T> {\n\n    private Collection<Subscription> subscriptions;\n\n    private T message;\n\n    public SubscriptionDeliveryRequest(Collection<Subscription> subscriptions, T message) {\n        this.subscriptions = subscriptions;\n        this.message = message;\n    }\n\n    public SubscriptionDeliveryRequest(T message){\n        this.message = message;\n        subscriptions = new LinkedList<Subscription>();\n    }\n\n    public boolean addAll(Collection<? extends Subscription> c) {\n        return subscriptions.addAll(c);\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    public void execute(){\n        for(Subscription sub : subscriptions)\n            sub.publish(message);\n    }\n}\n","src/main/java/org/mbassy/common/ConcurrentSet.java":"package org.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbace collect objects during iteration.\n * No dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T> {\n\n\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) return this;\n        synchronized (this) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element){\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) return;\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size(){\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (this) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) return this;\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) return false;\n        synchronized (this) {\n            Entry<T> listelement = entries.get(element);\n            if(listelement == null)return false;\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                head = head.next();\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) return null;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) return;\n                synchronized (ConcurrentSet.this) {\n                    current.remove();\n                    current = current.next();\n                }\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.setNext(next());\n            } else if (next() != null) {\n                next.predecessor = null;\n            }\n        }\n\n        public void setNext(Entry<T> element) {\n            this.next = element;\n            if (element != null) element.predecessor = this;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n        public boolean hasNext() {\n            return next() != null;\n        }\n\n    }\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport org.mbassy.subscription.*;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n\n    public MBassador(){\n        this(2);\n    }\n\n    public MBassador(int dispatcherThreadCount){\n        super(dispatcherThreadCount);\n    }\n\n    public MBassador(int dispatcherThreadCount, ExecutorService executor){\n        super(dispatcherThreadCount,executor);\n    }\n\n    @Override\n    protected SubscriptionFactory getSubscriptionFactory() {\n        return new SubscriptionFactory(this);\n    }\n\n    public void publishAsync(T message){\n        addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n\tpublic void publish(T message){\n\t\ttry {\n\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n\t\t\tif(subscriptions == null){\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions){\n                subscription.publish(message);\n            }\n\t\t} catch (Throwable e) {\n\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t.setMessage(\"Error during publication of message\")\n\t\t\t\t\t.setCause(e)\n\t\t\t\t\t.setPublishedObject(message));\n\t\t}\n\n\t}\n\n\n    @Override\n    public SyncAsyncPostCommand post(T message) {\n        return new SyncAsyncPostCommand(this, message);\n    }\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionFactory.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.dispatch.*;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    private IMessageBus owner;\n\n    public SubscriptionFactory(IMessageBus owner) {\n        this.owner = owner;\n    }\n\n    public Subscription createSubscription(MessageHandlerMetadata messageHandlerMetadata){\n        MessagingContext context = new MessagingContext(owner, messageHandlerMetadata);\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/test/java/org/mbassy/FilterTest.java":"package org.mbassy;\n\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Filter;\nimport org.mbassy.listener.IMessageFilter;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listeners.*;\n\nimport java.util.List;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends UnitTest{\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n\n        MBassador bus = new MBassador();\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subTestEvent = new SubTestEvent();\n\n        bus.post(event).now();\n        bus.post(subTestEvent).now();\n\n        assertEquals(100, event.counter.get());\n        assertEquals(0, subTestEvent.counter.get());\n\n    }\n\n\n    public static class FilteredMessageListener{\n\n        @Listener(filters = {@Filter(IMessageFilter.DontAllowSubtypes.class)})\n        public void handleTestEvent(TestEvent event){\n            event.counter.incrementAndGet();\n        }\n\n\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listeners.*;\nimport org.mbassy.subscription.Subscription;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends UnitTest {\n\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = new MBassador(new BusConfiguration());\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 1000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(300, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(1000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publishAsync(event);\n        bus.publishAsync(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publish(event);\n        bus.publish(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n            }\n        }, 10);\n\n        pause(3000);\n\n        for (TestEvent event : testEvents) {\n            assertEquals(300, event.counter.get());\n        }\n\n        for (SubTestEvent event : subtestEvents) {\n            assertEquals(700, event.counter.get());\n        }\n\n    }\n\n\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.dispatch.MessagingContext;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            handlePublicationError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<Method> messageHandlers = metadataReader.getListeners(listeningClass);  // get all methods with subscriptions\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (Method messageHandler : messageHandlers) {\n                            if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n                            Class eventType = getMessageType(messageHandler);\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, metadataReader.getHandlerMetadata(messageHandler)));\n                            subscription.subscribe(listener);\n                            addMessageTypeSubscription(eventType, subscription);\n                            subscriptionsByListener.add(subscription);\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n        pendingMessages.offer(request);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new CopyOnWriteArraySet<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        return true;\n    }\n\n    private static Class getMessageType(Method listener) {\n        return listener.getParameterTypes()[0];\n    }\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/test/java/org/mbassy/ConcurrentSetTest.java":"package org.mbassy;\n\nimport junit.framework.Assert;\nimport org.junit.Test;\nimport org.mbassy.common.ConcurrentSet;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Random;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class ConcurrentSetTest extends UnitTest {\n\n    private int numberOfElements = 100000;\n\n    private int numberOfThreads = 50;\n\n\n    @Test\n    public void testIteratorCleanup() {\n        final HashSet<Object> persistingCandidates = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n\n            if (rand.nextInt() % 3 == 0) {\n                persistingCandidates.add(candidate);\n            }\n            testSet.add(candidate);\n        }\n\n        // this will remove all objects that have not been inserted into the set of persisting candidates\n        runGC();\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object testObject : testSet) {\n                    // do nothing\n                    // just iterate to trigger automatic clean up\n                    System.currentTimeMillis();\n                }\n            }\n        }, numberOfThreads);\n\n        assertEquals(persistingCandidates.size(), testSet.size());\n        for (Object test : testSet) {\n            assertTrue(persistingCandidates.contains(test));\n        }\n\n\n    }\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSet.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSet.contains(uniqueObject));\n        }\n\n\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final ConcurrentSet<Object> concurrentSet = new ConcurrentSet<Object>();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            concurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.add(src);\n                    if (toRemove.contains(src))\n                        testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSet) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSet.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSet.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final ConcurrentSet<Object> testSet = new ConcurrentSet<Object>();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSet.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = testSet.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSet.size());\n        for(Object src : source){\n            assertFalse(testSet.contains(src));\n        }\n    }\n\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionDeliveryRequest.java":"package org.mbassy.subscription;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\n\n/**\n * @author bennidi\n * Date: 11/16/12\n */\npublic class SubscriptionDeliveryRequest<T> {\n\n    private Collection<Subscription> subscriptions;\n\n    private T message;\n\n    public SubscriptionDeliveryRequest(Collection<Subscription> subscriptions, T message) {\n        this.subscriptions = subscriptions;\n        this.message = message;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    public void execute(){\n        for(Subscription sub : subscriptions)\n            sub.publish(message);\n    }\n}\n","src/main/java/org/mbassy/common/ConcurrentSet.java":"package org.mbassy.common;\n\n\nimport java.lang.ref.WeakReference;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.WeakHashMap;\n\n/**\n * This data structure is optimized for non-blocking reads even when write operations occur.\n * Running read iterators will not be affected by add operations since writes always insert at the head of the\n * structure. Remove operations can affect any running iterator such that a removed element that has not yet\n * been reached by the iterator will not appear in that iterator anymore.\n * <p/>\n * The structure uses weak references to the elements. Iterators automatically perform cleanups of\n * garbage collected objects during iteration -> no dedicated maintenance operations need to be called or run in background.\n * <p/>\n * <p/>\n * <p/>\n *\n * @author bennidi\n *         Date: 2/12/12\n */\npublic class ConcurrentSet<T> implements Iterable<T>{\n\n    private WeakHashMap<T, Entry<T>> entries = new WeakHashMap<T, Entry<T>>(); // maintain a map of entries for O(log n) lookup\n\n    private Entry<T> head; // reference to the first element\n\n    public ConcurrentSet<T> add(T element) {\n        if (element == null || entries.containsKey(element)) return this;\n        synchronized (this) {\n            insert(element);\n        }\n        return this;\n    }\n\n    public boolean contains(T element){\n        Entry<T> entry = entries.get(element);\n        return entry != null && entry.getValue() != null;\n    }\n\n    private void insert(T element) {\n        if (entries.containsKey(element)) return;\n        if (head == null) {\n            head = new Entry<T>(element);\n        } else {\n            head = new Entry<T>(element, head);\n        }\n        entries.put(element, head);\n    }\n\n    public int size(){\n        return entries.size();\n    }\n\n    public ConcurrentSet<T> addAll(Iterable<T> elements) {\n        synchronized (this) {\n            for (T element : elements) {\n                if (element == null || entries.containsKey(element)) return this;\n\n                insert(element);\n            }\n        }\n        return this;\n    }\n\n    public boolean remove(T element) {\n        if (!entries.containsKey(element)) return false;\n        synchronized (this) {\n            Entry<T> listelement = entries.get(element);\n            if(listelement == null)return false; //removed by other thread\n            if (listelement != head) {\n                listelement.remove();\n            } else {\n                Entry<T> oldHead = head;\n                head = head.next();\n                oldHead.next = null; // optimize for GC\n            }\n            entries.remove(element);\n        }\n        return true;\n    }\n\n    public Iterator<T> iterator() {\n        return new Iterator<T>() {\n\n            private Entry<T> current = head;\n\n            public boolean hasNext() {\n                if (current == null) return false;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return hasNext();\n                } else {\n                    return true;\n                }\n            }\n\n            public T next() {\n                if (current == null) return null;\n                T value = current.getValue();\n                if (value == null) {    // auto-removal of orphan references\n                    remove();\n                    return next();\n                } else {\n                    current = current.next();\n                    return value;\n                }\n            }\n\n            public void remove() {\n                if (current == null) return;\n                Entry<T> newCurrent = current.next();\n                ConcurrentSet.this.remove(current.getValue());\n                current = newCurrent;\n            }\n        };\n    }\n\n\n    public class Entry<T> {\n\n        private WeakReference<T> value;\n\n        private Entry<T> next;\n\n        private Entry<T> predecessor;\n\n\n        private Entry(T value) {\n            this.value = new WeakReference<T>(value);\n        }\n\n        private Entry(T value, Entry<T> next) {\n            this(value);\n            this.next = next;\n            next.predecessor = this;\n        }\n\n        public T getValue() {\n            return value.get();\n        }\n\n        // not thread-safe! must be synchronized in enclosing context\n        public void remove() {\n            if (predecessor != null) {\n                predecessor.next = next;\n                if(next != null)next.predecessor = predecessor;\n            } else if (next != null) {\n                next.predecessor = null;\n            }\n            next = null;\n            predecessor = null;\n        }\n\n        public Entry<T> next() {\n            return next;\n        }\n\n\n    }\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport org.mbassy.subscription.*;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n\n    public MBassador(BusConfiguration configuration){\n        super(configuration);\n    }\n\n\n    public void publishAsync(T message){\n        addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n\tpublic void publish(T message){\n\t\ttry {\n\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n\t\t\tif(subscriptions == null){\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions){\n                subscription.publish(message);\n            }\n\t\t} catch (Throwable e) {\n\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t.setMessage(\"Error during publication of message\")\n\t\t\t\t\t.setCause(e)\n\t\t\t\t\t.setPublishedObject(message));\n\t\t}\n\n\t}\n\n\n    @Override\n    public SyncAsyncPostCommand post(T message) {\n        return new SyncAsyncPostCommand(this, message);\n    }\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionFactory.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.dispatch.*;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(MessagingContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/test/java/org/mbassy/FilterTest.java":"package org.mbassy;\n\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Filter;\nimport org.mbassy.listener.IMessageFilter;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listeners.*;\n\nimport java.util.List;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends UnitTest{\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subTestEvent = new SubTestEvent();\n\n        bus.post(event).now();\n        bus.post(subTestEvent).now();\n\n        assertEquals(100, event.counter.get());\n        assertEquals(0, subTestEvent.counter.get());\n\n    }\n\n\n    public static class FilteredMessageListener{\n\n        @Listener(filters = {@Filter(IMessageFilter.DontAllowSubtypes.class)})\n        public void handleTestEvent(TestEvent event){\n            event.counter.incrementAndGet();\n        }\n\n\n    }\n\n}\n"},"preChangeRange":{"src/main/java/org/mbassy/AbstractMessageBus.java":[[126,126],[135,135]],"src/main/java/org/mbassy/common/ConcurrentSet.java":[[114,117],[148,148],[149,149]]},"postChangeRange":{"src/test/java/org/mbassy/MBassadorTest.java":[[139,139],[28,28],[82,82],[110,110],[172,172]],"src/main/java/org/mbassy/AbstractMessageBus.java":[[122,122],[128,128]],"src/main/java/org/mbassy/common/ConcurrentSet.java":[[115,115],[116,116],[117,117],[76,76],[78,78],[149,149],[150,150],[151,151],[154,154],[155,155]],"src/test/java/org/mbassy/FilterTest.java":[[24,24]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/common/ConcurrentSet.java","startLine":150,"endLine":150}]}],"refactorings":[]},{"repository":"mbassador","sha1":"687fbb72ed2f716332e4ff08229b8566e31d4f91","url":"https://github.com/bennidi/mbassador/commit/687fbb72ed2f716332e4ff08229b8566e31d4f91","preChangeSourceCode":{"src/test/java/org/mbassy/listeners/EventingTestBean.java":"package org.mbassy.listeners;\n\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Filter;\nimport org.mbassy.listener.IMessageFilter;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listener.Mode;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Listener\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, dispatch = Mode.Asynchronous)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Listener(\n            priority = 10,\n            dispatch = Mode.Synchronous,\n            filters = {@Filter(IMessageFilter.None.class), @Filter(IMessageFilter.All.class)})\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n\n}\n","src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":"package org.mbassy.listener;\n\nimport java.lang.reflect.Method;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public Class getDeclaredMessageType(){\n        return handler.getParameterTypes()[0];\n    }\n}\n","src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listeners.*;\nimport org.mbassy.subscription.Subscription;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends UnitTest {\n\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = new MBassador(new BusConfiguration());\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 1000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(300, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(1000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publishAsync(event);\n        bus.publishAsync(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publish(event);\n        bus.publish(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n            }\n        }, 10);\n\n        pause(3000);\n\n        for (TestEvent event : testEvents) {\n            assertEquals(300, event.counter.get());\n        }\n\n        for (SubTestEvent event : subtestEvents) {\n            assertEquals(700, event.counter.get());\n        }\n\n    }\n\n\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.dispatch.MessagingContext;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // indicates whether the shutdown method has been invoked\n    // -> if true, then dispatchers will have been shutdown\n    private final AtomicBoolean isShutDown = new AtomicBoolean(false);\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<Method> messageHandlers = metadataReader.getMessageHandlers(listeningClass);  // get all methods with subscriptions\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (Method messageHandler : messageHandlers) {\n                            if (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n                            Class eventType = getMessageType(messageHandler);\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, metadataReader.getHandlerMetadata(messageHandler)));\n                            subscription.subscribe(listener);\n                            addMessageTypeSubscription(eventType, subscription);\n                            subscriptionsByListener.add(subscription);\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n        pendingMessages.offer(request);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        return true;\n    }\n\n    private static Class getMessageType(Method listener) {\n        return listener.getParameterTypes()[0];\n    }\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n        isShutDown.set(true);\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionFactory.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.dispatch.*;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(MessagingContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/org/mbassy/listener/IMessageFilter.java":"package org.mbassy.listener;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n * If a filter is used the message will only be delivered if it passes the filter(s)\n *\n * NOTE: A message filter must provide either a no-arg constructor.\n *\n * @author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageFilter {\n\n    /**\n     * Evaluate the message to ensure that it matches the handler configuration\n     *\n     *\n     * @param message the message to be delivered\n     * @return\n     */\n\tpublic boolean accepts(Object message, MessageHandlerMetadata metadata);\n\n\n\n\tpublic static final class All implements IMessageFilter {\n\n\t\t@Override\n\t\tpublic boolean accepts(Object event, MessageHandlerMetadata metadata) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n    public static final class None implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return false;\n        }\n    }\n\n\n    public static final class DontAllowSubtypes implements IMessageFilter {\n\n        @Override\n        public boolean accepts(Object event, MessageHandlerMetadata metadata) {\n            return event.getClass().equals(metadata.getDeclaredMessageType());\n        }\n    }\n\n\n}\n","src/main/java/org/mbassy/BusConfiguration.java":"package org.mbassy;\n\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.concurrent.*;\n\n/**\n *\n *\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration {\n\n    public static final BusConfiguration Default(){\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    private SubscriptionFactory subscriptionFactory;\n\n    private MetadataReader metadataReader;\n\n    public BusConfiguration() {\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.subscriptionFactory = new SubscriptionFactory();\n        this.executor = new ThreadPoolExecutor(5, 20, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n        this.metadataReader = new MetadataReader();\n    }\n\n    public MetadataReader getMetadataReader() {\n        return metadataReader;\n    }\n\n    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n        this.metadataReader = metadataReader;\n        return this;\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n    public SubscriptionFactory getSubscriptionFactory() {\n        return subscriptionFactory;\n    }\n\n    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n        this.subscriptionFactory = subscriptionFactory;\n        return this;\n    }\n}\n","src/main/java/org/mbassy/listener/MetadataReader.java":"package org.mbassy.listener;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:22 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription) throws Exception{\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler) throws Exception{\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        IMessageFilter[] filter = getFilter(config);\n        return new MessageHandlerMetadata(messageHandler, filter, config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<Method> getMessageHandlers(Class<?> target) {\n        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        List<Method>  handlers = new LinkedList<Method>();\n        for(Method listener : allMethods){\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(listener, target);\n\n            if(overriddenHandler != null && isHandler(overriddenHandler)){\n                handlers.add(overriddenHandler);\n            }\n            if(overriddenHandler == null){\n                handlers.add(listener);\n            }\n        }\n        return ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n    }\n\n    private static boolean isHandler(Method m){\n        Annotation[] annotations  = m.getDeclaredAnnotations();\n        for(Annotation annotation : annotations){\n            if(annotation.equals(Listener.class))return true;\n        }\n        return false;\n\n    }\n\n}\n","src/test/java/org/mbassy/FilterTest.java":"package org.mbassy;\n\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Filter;\nimport org.mbassy.listener.IMessageFilter;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listeners.*;\n\nimport java.util.List;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends UnitTest{\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subTestEvent = new SubTestEvent();\n\n        bus.post(event).now();\n        bus.post(subTestEvent).now();\n\n        assertEquals(100, event.counter.get());\n        assertEquals(0, subTestEvent.counter.get());\n\n    }\n\n\n    public static class FilteredMessageListener{\n\n        @Listener(filters = {@Filter(IMessageFilter.DontAllowSubtypes.class)})\n        public void handleTestEvent(TestEvent event){\n            event.counter.incrementAndGet();\n        }\n\n\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/org/mbassy/listeners/EventingTestBean.java":"package org.mbassy.listeners;\n\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.*;\n\n/**\n * Basic bean that defines some event handlers to be used for different unit testting scenarios\n *\n * @author bennidi\n * Date: 11/22/12\n */\npublic class EventingTestBean {\n\n    // every event of type TestEvent or any subtype will be delivered\n    // to this listener\n    @Listener\n    public void handleTestEvent(TestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will be invoked asynchronously\n    @Listener(priority = 0, dispatch = Mode.Asynchronous)\n    public void handleSubTestEvent(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n    // this handler will receive events of type SubTestEvent\n    // or any subtabe and that passes the given filter\n    @Listener(\n            priority = 10,\n            dispatch = Mode.Synchronous,\n            filters = {@Filter(Filters.RejectAll.class), @Filter(Filters.AllowAll.class)})\n    public void handleFiltered(SubTestEvent event) {\n        event.counter.incrementAndGet();\n    }\n\n\n}\n","src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":"package org.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n}\n","src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.events.TestEvent2;\nimport org.mbassy.listeners.*;\nimport org.mbassy.subscription.Subscription;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class MBassadorTest extends UnitTest {\n\n\n    // this is a single threaded test for subscribing and unsubscribing of a single listener\n    @Test\n    public void testSubscribeSimple() throws InterruptedException {\n        MBassador bus = new MBassador(new BusConfiguration());\n        List<Object> listeners = new LinkedList<Object>();\n        int listenerCount = 1000;\n\n        // subscribe a number of listeners to the bus\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean listener = new EventingTestBean();\n            NonListeningBean nonListener = new NonListeningBean();\n            listeners.add(listener);\n\n            bus.subscribe(listener);\n            bus.subscribe(nonListener);\n\n            assertFalse(bus.unsubscribe(nonListener)); // these are not expected to be subscribed listeners\n            assertFalse(bus.unsubscribe(new EventingTestBean()));\n\n        }\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(listenerCount, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(3 * listenerCount, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n        // unsubscribe the listeners\n        for(Object listener : listeners){\n            assertTrue(bus.unsubscribe(listener)); // this listener is expected to exist\n        }\n\n        // no listener should be left\n        testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(1, testEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(3, subTestEventsubscriptions.size());\n        assertEquals(0, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n    private int getNumberOfSubscribedListeners(Collection<Subscription> subscriptions) {\n        int listeners = 0;\n        for (Subscription sub : subscriptions) {\n            listeners += sub.size();\n        }\n        return listeners;\n    }\n\n    @Test\n    public void testConcurrentSubscription() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        // check the generated subscriptions for existence of all previously subscribed valid listeners\n        Collection<Subscription> testEventsubscriptions = bus.getSubscriptionsByMessageType(TestEvent.class);\n        assertEquals(3, testEventsubscriptions.size());\n        assertEquals(300, getNumberOfSubscribedListeners(testEventsubscriptions));\n\n        Collection<Subscription> subTestEventsubscriptions = bus.getSubscriptionsByMessageType(SubTestEvent.class);\n        assertEquals(10, subTestEventsubscriptions.size());\n        assertEquals(1000, getNumberOfSubscribedListeners(subTestEventsubscriptions));\n\n    }\n\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class)\n                .create(100, MultiEventHandler.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n        TestEvent2 event2 = new TestEvent2();\n\n        bus.publishAsync(event);\n        bus.publishAsync(subEvent);\n        bus.publishAsync(event2);\n\n        pause(2000);\n\n        assertEquals(500, event.counter.get());\n        assertEquals(800, subEvent.counter.get());\n        assertEquals(200, event2.counter.get());\n\n    }\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subEvent = new SubTestEvent();\n\n        bus.publish(event);\n        bus.publish(subEvent);\n\n        pause(2000);\n\n        assertEquals(300, event.counter.get());\n        assertEquals(700, subEvent.counter.get());\n\n    }\n\n    @Test\n    public void testConcurrentMixedMessagePublication() throws Exception {\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final int eventLoopsPerTHread = 100;\n\n\n        final MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, EventingTestBean.class)\n                .create(100, EventingTestBean2.class)\n                .create(100, EventingTestBean3.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < eventLoopsPerTHread; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n            }\n        }, 10);\n\n        pause(3000);\n\n        for (TestEvent event : testEvents) {\n            assertEquals(300, event.counter.get());\n        }\n\n        for (SubTestEvent event : subtestEvents) {\n            assertEquals(700, event.counter.get());\n        }\n\n    }\n\n\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.dispatch.MessagingContext;\nimport org.mbassy.listener.MessageHandlerMetadata;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // indicates whether the shutdown method has been invoked\n    // -> if true, then dispatchers will have been shutdown\n    private final AtomicBoolean isShutDown = new AtomicBoolean(false);\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n        pendingMessages.offer(request);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n        isShutDown.set(true);\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/org/mbassy/subscription/SubscriptionFactory.java":"package org.mbassy.subscription;\n\nimport org.mbassy.IMessageBus;\nimport org.mbassy.IPublicationErrorHandler;\nimport org.mbassy.dispatch.*;\nimport org.mbassy.listener.MessageHandlerMetadata;\n\nimport java.util.Collection;\n\n/**\n * Created with IntelliJ IDEA.\n * @author bennidi\n * Date: 11/16/12\n * Time: 10:39 AM\n * To change this template use File | Settings | File Templates.\n */\npublic class SubscriptionFactory {\n\n    public Subscription createSubscription(MessagingContext context){\n        IHandlerInvocation invocation = buildInvocationForHandler(context);\n        IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n        return new Subscription(context, dispatcher);\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(MessagingContext context){\n        IHandlerInvocation invocation = new ReflectiveHandlerInvocation(context);\n        if(context.getHandlerMetadata().isAsynchronous()){\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(MessagingContext context, IHandlerInvocation invocation){\n       IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n       if(context.getHandlerMetadata().isEnveloped()){\n          dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n       }\n       if(context.getHandlerMetadata().isFiltered()){\n          dispatcher = new FilteredMessageDispatcher(dispatcher);\n       }\n       return dispatcher;\n    }\n}\n","src/main/java/org/mbassy/listener/IMessageFilter.java":"package org.mbassy.listener;\n\n/**\n * Message filters can be used to prevent certain messages to be delivered to a specific listener.\n * If a filter is used the message will only be delivered if it passes the filter(s)\n *\n * NOTE: A message filter must provide either a no-arg constructor.\n *\n * @author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageFilter {\n\n    /**\n     * Evaluate the message to ensure that it matches the handler configuration\n     *\n     *\n     * @param message the message to be delivered\n     * @return\n     */\n\tpublic boolean accepts(Object message, MessageHandlerMetadata metadata);\n\n}\n","src/main/java/org/mbassy/BusConfiguration.java":"package org.mbassy;\n\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour. *\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration {\n\n    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread thread = Executors.defaultThreadFactory().newThread(r);\n            thread.setDaemon(true);\n            return thread;\n        }\n    };\n\n    public static final BusConfiguration Default(){\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    private SubscriptionFactory subscriptionFactory;\n\n    private MetadataReader metadataReader;\n\n    public BusConfiguration() {\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.subscriptionFactory = new SubscriptionFactory();\n        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n        this.metadataReader = new MetadataReader();\n    }\n\n    public MetadataReader getMetadataReader() {\n        return metadataReader;\n    }\n\n    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n        this.metadataReader = metadataReader;\n        return this;\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n    public SubscriptionFactory getSubscriptionFactory() {\n        return subscriptionFactory;\n    }\n\n    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n        this.subscriptionFactory = subscriptionFactory;\n        return this;\n    }\n}\n","src/main/java/org/mbassy/listener/MetadataReader.java":"package org.mbassy.listener;\n\nimport com.sun.xml.internal.messaging.saaj.soap.Envelope;\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        List<Method>  handlers = new LinkedList<Method>();\n        for(Method listener : allMethods){\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(listener, target);\n\n            if(overriddenHandler != null && isHandler(overriddenHandler)){\n                handlers.add(overriddenHandler);\n            }\n            if(overriddenHandler == null){\n                handlers.add(listener);\n            }\n        }\n        handlers =  ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n        List<MessageHandlerMetadata> messageHandlers = new ArrayList<MessageHandlerMetadata>(handlers.size());\n        for(Method handler : handlers){\n            if(isValidMessageHandler(handler))\n                messageHandlers.add(getHandlerMetadata(handler));\n        }\n        return messageHandlers;\n    }\n\n    private static boolean isHandler(Method m){\n        Annotation[] annotations  = m.getDeclaredAnnotations();\n        for(Annotation annotation : annotations){\n            if(annotation.equals(Listener.class))return true;\n        }\n        return false;\n    }\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/test/java/org/mbassy/FilterTest.java":"package org.mbassy;\n\nimport org.junit.Test;\nimport org.mbassy.events.SubTestEvent;\nimport org.mbassy.events.TestEvent;\nimport org.mbassy.listener.Filter;\nimport org.mbassy.listener.Filters;\nimport org.mbassy.listener.IMessageFilter;\nimport org.mbassy.listener.Listener;\nimport org.mbassy.listeners.*;\n\nimport java.util.List;\n\n/**\n * Testing of filter functionality\n *\n * @author bennidi\n *         Date: 11/26/12\n */\npublic class FilterTest extends UnitTest{\n\n    @Test\n    public void testSubclassFilter() throws Exception {\n\n        MBassador bus = new MBassador(new BusConfiguration());\n        ListenerFactory listenerFactory = new ListenerFactory()\n                .create(100, FilteredMessageListener.class)\n                .create(100, Object.class)\n                .create(100, NonListeningBean.class);\n\n        List<Object> listeners = listenerFactory.build();\n\n        // this will subscribe the listeners concurrently to the bus\n        TestUtil.setup(bus, listeners, 10);\n\n        TestEvent event = new TestEvent();\n        TestEvent subTestEvent = new SubTestEvent();\n\n        bus.post(event).now();\n        bus.post(subTestEvent).now();\n\n        assertEquals(100, event.counter.get());\n        assertEquals(0, subTestEvent.counter.get());\n\n    }\n\n\n    public static class FilteredMessageListener{\n\n        @Listener(filters = {@Filter(Filters.RejectSubtypes.class)})\n        public void handleTestEvent(TestEvent event){\n            event.counter.incrementAndGet();\n        }\n\n\n    }\n\n}\n"},"preChangeRange":{"src/test/java/org/mbassy/listeners/EventingTestBean.java":[[36,36]],"src/test/java/org/mbassy/MBassadorTest.java":[[116,116],[131,131],[132,132]],"src/main/java/org/mbassy/AbstractMessageBus.java":[[121,121],[128,128],[129,129],[130,130],[132,132],[134,134]],"src/main/java/org/mbassy/BusConfiguration.java":[[35,35]],"src/main/java/org/mbassy/listener/MetadataReader.java":[[52,52],[54,54],[55,55],[60,60],[73,73],[34,34]],"src/test/java/org/mbassy/FilterTest.java":[[49,49]]},"postChangeRange":{"src/test/java/org/mbassy/listeners/EventingTestBean.java":[[33,33]],"src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":[[33,33],[34,40]],"src/test/java/org/mbassy/MBassadorTest.java":[[117,118],[127,127],[131,131],[135,135],[136,136],[137,137]],"src/main/java/org/mbassy/AbstractMessageBus.java":[[121,121],[128,128],[131,131],[135,135],[136,138]],"src/main/java/org/mbassy/subscription/SubscriptionFactory.java":[[35,37]],"src/main/java/org/mbassy/BusConfiguration.java":[[43,43]],"src/main/java/org/mbassy/listener/MetadataReader.java":[[58,58],[63,63],[76,76],[77,77],[78,81],[82,82],[40,41],[43,47]],"src/test/java/org/mbassy/FilterTest.java":[[50,50]]},"microChanges":[{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/org/mbassy/AbstractMessageBus.java","startLine":129,"endLine":129}],"rightSideLocations":[]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/listener/MessageHandlerMetadata.java","startLine":34,"endLine":34}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/subscription/SubscriptionFactory.java","startLine":35,"endLine":35}]}],"refactorings":[]},{"repository":"mbassador","sha1":"e170301c2c591dc3289909f2d3ea2ab10e293753","url":"https://github.com/bennidi/mbassador/commit/e170301c2c591dc3289909f2d3ea2ab10e293753","preChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\n * defines such a message listener.\n *\n * @author bennidi\n *         Date: 11/14/12\n */\npublic class MessageHandler {\n\n    public static final class Properties{\n\n        public static final String HandlerMethod = \"handler\";\n        public static final String InvocationMode = \"invocationMode\";\n        public static final String Filter = \"filter\";\n        public static final String Enveloped = \"envelope\";\n        public static final String HandledMessages = \"messages\";\n        public static final String IsSynchronized = \"synchronized\";\n        public static final String Listener = \"listener\";\n        public static final String AcceptSubtypes = \"subtypes\";\n        public static final String Priority = \"priority\";\n        public static final String Invocation = \"invocation\";\n\n        /**\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\n         *\n         * @param handler  The handler annotated method of the listener\n         * @param handlerConfig The annotation that configures the handler\n         * @param filter   The set of preconfigured filters if any\n         * @param listenerConfig The listener metadata\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\n         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\n         */\n        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\n            if(handler == null){\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\n            }\n            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\n            Class[] handledMessages = enveloped != null\n                    ? enveloped.messages()\n                    : handler.getParameterTypes();\n            handler.setAccessible(true);\n            Map<String, Object> properties = new HashMap<String, Object>();\n            properties.put(HandlerMethod, handler);\n            properties.put(Filter, filter != null ? filter : new IMessageFilter[]{});\n            properties.put(Priority, handlerConfig.priority());\n            properties.put(Invocation, handlerConfig.invocation());\n            properties.put(InvocationMode, handlerConfig.delivery());\n            properties.put(Enveloped, enveloped != null);\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\n            properties.put(Listener, listenerConfig);\n            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\n            properties.put(HandledMessages, handledMessages);\n            return properties;\n        }\n    }\n\n\n    private final Method handler;\n\n    private final IMessageFilter[] filter;\n\n    private final int priority;\n\n    private final Class<? extends HandlerInvocation> invocation;\n\n    private final Invoke invocationMode;\n\n    private final boolean isEnvelope;\n\n    private final Class[] handledMessages;\n\n    private final boolean acceptsSubtypes;\n\n    private final MessageListener listenerConfig;\n\n    private final boolean isSynchronized;\n\n    public MessageHandler(Map<String, Object> properties){\n        super();\n        validate(properties);\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\n        this.priority = (Integer)properties.get(Properties.Priority);\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\n    }\n\n    private void validate(Map<String, Object> properties){\n        Object[][] expectedProperties = new Object[][]{\n                new Object[]{Properties.HandlerMethod, Method.class },\n                new Object[]{Properties.Priority, Integer.class },\n                new Object[]{Properties.Invocation, Class.class },\n                new Object[]{Properties.Filter, IMessageFilter[].class },\n                new Object[]{Properties.Enveloped, Boolean.class },\n                new Object[]{Properties.HandledMessages, Class[].class },\n                new Object[]{Properties.IsSynchronized, Boolean.class },\n                new Object[]{Properties.Listener, MessageListener.class },\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\n        };\n        for(Object[] property : expectedProperties){\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\n                        + \" but was: \" + properties.get(property[0]));\n        }\n\n\n    }\n\n    public boolean isSynchronized(){\n        return isSynchronized;\n    }\n\n    public boolean useStrongReferences(){\n        return listenerConfig.useStrongReferences();\n    }\n\n    public boolean isFromListener(Class listener){\n        return listenerConfig.isFromListener(listener);\n    }\n\n    public boolean isAsynchronous() {\n        return invocationMode.equals(Invoke.Asynchronously);\n    }\n\n    public boolean isFiltered() {\n        return filter.length > 0;\n    }\n\n    public int getPriority() {\n        return priority;\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public Class[] getHandledMessages() {\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return isEnvelope;\n    }\n\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\n        return invocation;\n    }\n\n    public boolean handlesMessage(Class<?> messageType) {\n        for (Class<?> handledMessage : handledMessages) {\n            if (handledMessage.equals(messageType)) {\n                return true;\n            }\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes() {\n        return acceptsSubtypes;\n    }\n\n}\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\n\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.listener.IMessageFilter;\n\n/**\n * A dispatcher that implements message filtering based on the filter configuration\n * of the associated message handler. It will delegate message delivery to another\n * message dispatcher after having performed the filtering logic.\n *\n * @author bennidi\n *         Date: 11/23/12\n */\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\n\n    private final IMessageFilter[] filter;\n\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\n        super(dispatcher);\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\n    }\n\n    private boolean passesFilter(Object message) {\n\n        if (filter == null) {\n            return true;\n        } else {\n            for (IMessageFilter aFilter : filter) {\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n    @Override\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\n        if (passesFilter(message)) {\n            getDelegate().dispatch(publication, message, listeners);\n        }\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/Handler.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.dispatch.HandlerInvocation;\nimport net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any class(=listener) as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Handler {\n\n    /**\n     * Add any numbers of filters to the handler. All filters are evaluated before the handler\n     * is actually invoked, which is only if all the filters accept the message.\n     */\n    Filter[] filters() default {};\n\n    /**\n     * Define the mode in which a message is delivered to each listener. Listeners can be notified\n     * sequentially or concurrently.\n     */\n    Invoke delivery() default Invoke.Synchronously;\n\n    /**\n     * Handlers are ordered by priority and handlers with higher priority are processed before\n     * those with lower priority, i.e. Influence the order in which different handlers that consume\n     * the same message type are invoked.\n     */\n    int priority() default 0;\n\n    /**\n     * Define whether or not the handler accepts sub types of the message type it declares in its\n     * signature.\n     */\n    boolean rejectSubtypes() default false;\n\n\n    /**\n     * Enable or disable the handler. Disabled handlers do not receive any messages.\n     * This property is useful for quick changes in configuration and necessary to disable\n     * handlers that have been declared by a superclass but do not apply to the subclass\n     */\n    boolean enabled() default true;\n\n\n    /**\n     * Each handler call is implemented as an invocation object that implements the invocation mechanism.\n     * The basic implementation uses reflection and is the default. It is possible though to provide a custom\n     * invocation to add additional logic.\n     *\n     * Note: Providing a custom invocation will most likely reduce performance, since the JIT-Compiler\n     * can not do some of its sophisticated byte code optimizations.\n     *\n     */\n    Class<? extends HandlerInvocation> invocation() default ReflectiveHandlerInvocation.class;\n\n\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n * defines such a message listener.\r\n *\r\n * @author bennidi\r\n *         Date: 11/14/12\r\n */\r\npublic class MessageHandler {\r\n\r\n    public static final class Properties{\r\n\r\n        public static final String HandlerMethod = \"handler\";\r\n        public static final String InvocationMode = \"invocationMode\";\r\n        public static final String Filter = \"filter\";\r\n        public static final String Condition = \"condition\";\r\n        public static final String Enveloped = \"envelope\";\r\n        public static final String HandledMessages = \"messages\";\r\n        public static final String IsSynchronized = \"synchronized\";\r\n        public static final String Listener = \"listener\";\r\n        public static final String AcceptSubtypes = \"subtypes\";\r\n        public static final String Priority = \"priority\";\r\n        public static final String Invocation = \"invocation\";\r\n\r\n        /**\r\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n         *\r\n         * @param handler  The handler annotated method of the listener\r\n         * @param handlerConfig The annotation that configures the handler\r\n         * @param filter   The set of preconfigured filters if any\r\n         * @param listenerConfig The listener metadata\r\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n         */\r\n        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n            if(handler == null){\r\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n            }\r\n            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\r\n            Class[] handledMessages = enveloped != null\r\n                    ? enveloped.messages()\r\n                    : handler.getParameterTypes();\r\n            handler.setAccessible(true);\r\n            Map<String, Object> properties = new HashMap<String, Object>();\r\n            properties.put(HandlerMethod, handler);\r\n            properties.put(Filter, filter != null ? filter : new IMessageFilter[]{});\r\n            properties.put(Condition, handlerConfig.condition());\r\n            properties.put(Priority, handlerConfig.priority());\r\n            properties.put(Invocation, handlerConfig.invocation());\r\n            properties.put(InvocationMode, handlerConfig.delivery());\r\n            properties.put(Enveloped, enveloped != null);\r\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n            properties.put(Listener, listenerConfig);\r\n            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\r\n            properties.put(HandledMessages, handledMessages);\r\n            return properties;\r\n        }\r\n    }\r\n\r\n\r\n    private final Method handler;\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n\tprivate String condition;\r\n    \r\n    private final int priority;\r\n\r\n    private final Class<? extends HandlerInvocation> invocation;\r\n\r\n    private final Invoke invocationMode;\r\n\r\n    private final boolean isEnvelope;\r\n\r\n    private final Class[] handledMessages;\r\n\r\n    private final boolean acceptsSubtypes;\r\n\r\n    private final MessageListener listenerConfig;\r\n\r\n    private final boolean isSynchronized;\r\n\r\n\r\n    public MessageHandler(Map<String, Object> properties){\r\n        super();\r\n        validate(properties);\r\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n        this.condition = (String)properties.get(Properties.Condition);\r\n        this.priority = (Integer)properties.get(Properties.Priority);\r\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n    }\r\n\r\n    private void validate(Map<String, Object> properties){\r\n        Object[][] expectedProperties = new Object[][]{\r\n                new Object[]{Properties.HandlerMethod, Method.class },\r\n                new Object[]{Properties.Priority, Integer.class },\r\n                new Object[]{Properties.Invocation, Class.class },\r\n                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n                new Object[]{Properties.Condition, String.class },\r\n                new Object[]{Properties.Enveloped, Boolean.class },\r\n                new Object[]{Properties.HandledMessages, Class[].class },\r\n                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n                new Object[]{Properties.Listener, MessageListener.class },\r\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n        };\r\n        for(Object[] property : expectedProperties){\r\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                        + \" but was: \" + properties.get(property[0]));\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public boolean isSynchronized(){\r\n        return isSynchronized;\r\n    }\r\n\r\n    public boolean useStrongReferences(){\r\n        return listenerConfig.useStrongReferences();\r\n    }\r\n\r\n    public boolean isFromListener(Class listener){\r\n        return listenerConfig.isFromListener(listener);\r\n    }\r\n\r\n    public boolean isAsynchronous() {\r\n        return invocationMode.equals(Invoke.Asynchronously);\r\n    }\r\n\r\n    public boolean isFiltered() {\r\n        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n    }\r\n\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    public Method getHandler() {\r\n        return handler;\r\n    }\r\n\r\n    public IMessageFilter[] getFilter() {\r\n        return filter;\r\n    }\r\n    \r\n    public String getCondition() {\r\n    \treturn this.condition;\r\n    }\r\n\r\n    public Class[] getHandledMessages() {\r\n        return handledMessages;\r\n    }\r\n\r\n    public boolean isEnveloped() {\r\n        return isEnvelope;\r\n    }\r\n\r\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n        return invocation;\r\n    }\r\n\r\n    public boolean handlesMessage(Class<?> messageType) {\r\n        for (Class<?> handledMessage : handledMessages) {\r\n            if (handledMessage.equals(messageType)) {\r\n                return true;\r\n            }\r\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean acceptsSubtypes() {\r\n        return acceptsSubtypes;\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\r\n\r\nimport net.engio.mbassy.bus.MessagePublication;\r\nimport net.engio.mbassy.dispatch.el.ElFilter;\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\n\r\n/**\r\n * A dispatcher that implements message filtering based on the filter configuration\r\n * of the associated message handler. It will delegate message delivery to another\r\n * message dispatcher after having performed the filtering logic.\r\n *\r\n * @author bennidi\r\n *         Date: 11/23/12\r\n */\r\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\r\n        super(dispatcher);\r\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\r\n    }\r\n\r\n    private boolean passesFilter(Object message) {\r\n\r\n        if (filter == null) {\r\n            return true;\r\n        } else {\r\n            for (IMessageFilter aFilter : filter) {\r\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\r\n        if (passesFilter(message) && passesELFilter(message)) {\r\n            getDelegate().dispatch(publication, message, listeners);\r\n        }\r\n    }\r\n\r\n\t/*************************************************************************\r\n\t * This will test the EL expression defined on the Handler annotation.\r\n\t * This is like a \"parameterizable\" filter.\r\n\t * @param me the message object to filter with the EL expression if there is one.\r\n\t * @return true if the event is allowed, false if it is rejected.\r\n\t ************************************************************************/\r\n        \r\n\tprivate boolean passesELFilter(Object message) {\r\n\t\tElFilter filter = ElFilter.getInstance();\r\n\t\treturn filter != null && filter.accepts(message, getContext().getHandlerMetadata());\r\n\t}\r\n}\r\n","src/main/java/net/engio/mbassy/listener/Handler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\nimport net.engio.mbassy.dispatch.ReflectiveHandlerInvocation;\r\n\r\nimport java.lang.annotation.*;\r\n\r\n/**\r\n * Mark any method of any class(=listener) as a message handler and configure the handler\r\n * using different properties.\r\n *\r\n * @author bennidi\r\n *         Date: 2/8/12\r\n */\r\n@Retention(value = RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@Target(value = {ElementType.METHOD})\r\npublic @interface Handler {\r\n\r\n    /**\r\n     * Add any numbers of filters to the handler. All filters are evaluated before the handler\r\n     * is actually invoked, which is only if all the filters accept the message.\r\n     */\r\n    Filter[] filters() default {};\r\n    \r\n    \r\n    /**\r\n     * Defines a filter condition as Expression Language. This can be used to filter the events based on \r\n     * attributes of the event object. Note that the expression must resolve to either\r\n     * <code>true</code> to allow the event or <code>false</code> to block it from delivery to the handler. \r\n     * The message itself is available as \"msg\" variable. \r\n     * @return the condition in EL syntax.\r\n     */\r\n    String condition() default \"\";\r\n\r\n    /**\r\n     * Define the mode in which a message is delivered to each listener. Listeners can be notified\r\n     * sequentially or concurrently.\r\n     */\r\n    Invoke delivery() default Invoke.Synchronously;\r\n\r\n    /**\r\n     * Handlers are ordered by priority and handlers with higher priority are processed before\r\n     * those with lower priority, i.e. Influence the order in which different handlers that consume\r\n     * the same message type are invoked.\r\n     */\r\n    int priority() default 0;\r\n\r\n    /**\r\n     * Define whether or not the handler accepts sub types of the message type it declares in its\r\n     * signature.\r\n     */\r\n    boolean rejectSubtypes() default false;\r\n\r\n\r\n    /**\r\n     * Enable or disable the handler. Disabled handlers do not receive any messages.\r\n     * This property is useful for quick changes in configuration and necessary to disable\r\n     * handlers that have been declared by a superclass but do not apply to the subclass\r\n     */\r\n    boolean enabled() default true;\r\n\r\n\r\n    /**\r\n     * Each handler call is implemented as an invocation object that implements the invocation mechanism.\r\n     * The basic implementation uses reflection and is the default. It is possible though to provide a custom\r\n     * invocation to add additional logic.\r\n     *\r\n     * Note: Providing a custom invocation will most likely reduce performance, since the JIT-Compiler\r\n     * can not do some of its sophisticated byte code optimizations.\r\n     *\r\n     */\r\n    Class<? extends HandlerInvocation> invocation() default ReflectiveHandlerInvocation.class;\r\n\r\n\r\n}\r\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[140,140]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[40,40]]},"postChangeRange":{"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[147,147],[114,114],[97,97],[55,55]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[41,41]]},"microChanges":[{"type":"AddAdditionalCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java","startLine":41,"endLine":41}]}],"refactorings":[]},{"repository":"mbassador","sha1":"6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9","url":"https://github.com/bennidi/mbassador/commit/6c19fd3bd9c7005c3f329fb43586db6ea7f45ad9","preChangeSourceCode":{"src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":"package net.engio.mbassy.bus.config;\n\n/**\n * The configuration of message bus instances is feature driven, e.g. configuration parameters\n * are grouped into {@link Feature}.\n *\n * Features can be added to a bus configuration to be used later in the instantiation process of the message bus.\n * Each bus will look for the features it requires and configure them according to the provided configuration. If a required feature is not found the bus will publish a {@link ConfigurationError}\n * to the {@link ConfigurationErrorHandler}\n *\n * @author bennidi.\n */\npublic interface IBusConfiguration{\n\n    /**\n     * Set a property which will be read by the message bus constructor. Existing value will be overwritten.\n     * Null values are supported (checking for existence of property will return <code>true</code> even if set to <code>null</code>).\n     *\n     * @param name The name of the property. Note: Each implementation may support different properties.\n     * @param value The value of the property.\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration setProperty(String name, Object value);\n\n    /**\n     * Read a property from this configuration.\n     *\n     * @param name  The name of the property to be read.\n     * @param defaultValue  The value to be returned if property was not found\n     * @param <T>  The type of property\n     * @return The value associated with the given property name or <code>defaultValue</code> if not present\n     */\n    <T> T getProperty(String name, T defaultValue);\n\n    /**\n     * Check whether a property has been set.\n     *\n     * @return true if property was set (even if set to null)\n     *         false otherwise\n     */\n    boolean hasProperty(String name);\n\n\n    /**\n     * Get a registered feature by its type (class).\n     *\n     */\n    <T extends Feature> T getFeature(Class<T> feature);\n\n    /**\n     * Add a feature to the given configuration, replacing any existing feature of the same type.\n     *\n     * @param feature The feature to add\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration addFeature(Feature feature);\n\n    /**\n     * Add a handler that is called when a misconfiguration is detected.\n     */\n    IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler);\n\n    /**\n     * Calls all ConfigurationErrorHandlers\n     */\n    void handleError(ConfigurationError error);\n\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n\n        private boolean failOnException;\n\n        public AssertionErrorHandler(boolean failOnException) {\n            this.failOnException = failOnException;\n        }\n\n        @Override\n        public void handleError(PublicationError error) {\n            if(failOnException)\n                org.junit.Assert.fail(error.getCause().getMessage());\n        }\n    }\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return SyncAsync(true);\n    }\n\n    public static IBusConfiguration SyncAsync(boolean failOnError) {\n        return new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default())\n            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n\n\n    public MBassador(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    public MBassador(){\n        this(new BusConfiguration()\n                .addFeature(Feature.SyncPubSub.Default())\n                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n                .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n    }\n\n\n    public IMessagePublication publishAsync(T message) {\n        return addAsynchronousPublication(createMessagePublication(message));\n    }\n\n    public IMessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedMessage(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.Collection;\n\n\npublic interface ErrorHandlingSupport {\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.ErrorHandlingSupport;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * A message bus implementation that offers only synchronous message publication. Using this bus\n * will not create any new threads.\n *\n */\npublic class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T, SyncMessageBus.SyncPostCommand>{\n\n\n    public SyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    @Override\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedMessage(message));\n        }\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements IPublicationCommand {\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final MBassador bus = new MBassador(SyncAsync()\n                .setProperty(Properties.Handler.PublicationError, ExceptionCounter));\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).asynchronously();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/BusRuntime.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.error.MissingPropertyException;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n * they expose. The runtime is a container for all those dynamic properties and components and is meant to be passed around\n * between collaborating objects such that they may access the different functionality provided by the bus implementation\n * they all belong to.\n *\n * It is the responsibility of the bus implementation to create and configure the runtime according to its capabilities,\n *\n */\npublic class BusRuntime {\n\n    private PubSubSupport provider;\n\n    private Map<String, Object> properties = new HashMap<String, Object>();\n\n    public BusRuntime(PubSubSupport provider) {\n        this.provider = provider;\n    }\n\n    public <T> T get(String key){\n         if(!contains(key))\n             throw new MissingPropertyException(\"The property \" + key + \" is not available in this runtime\");\n         else return (T) properties.get(key);\n     }\n\n    public PubSubSupport getProvider(){\n        return provider;\n    }\n\n    public Collection<String> getKeys(){\n        return properties.keySet();\n    }\n\n    public BusRuntime add(String key, Object property){\n        properties.put(key, property);\n        return this;\n    }\n\n    public boolean contains(String key){\n        return properties.containsKey(key);\n    }\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false);\n        bus.addErrorHandler(ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new IncrementingMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            IBusConfiguration asyncFIFOConfig = new BusConfiguration()\n                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n            return new MBassador(asyncFIFOConfig);\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            IBusConfiguration syncPubSubCfg = new BusConfiguration()\n                    .setProperty(Properties.Handler.PublicationError, new AssertionErrorHandler(failOnException));\n            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n            return new SyncMessageBus(syncPubSubCfg);\n        }\n    }\n\n\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else throw new RuntimeException(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    // the registered properties\n    private final Map<Object, Object> properties = new HashMap<Object, Object>();\n    private final List<ConfigurationErrorHandler> errorHandlerList = new LinkedList<ConfigurationErrorHandler>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public IBusConfiguration setProperty(String name, Object value) {\n        properties.put(name, value);\n        return this;\n    }\n\n    @Override\n    public <T> T getProperty(String name, T defaultValue) {\n        return properties.containsKey(name) ? (T) properties.get(name) : defaultValue;\n    }\n\n    @Override\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T) properties.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        properties.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler) {\n        errorHandlerList.add(handler);\n        return this;\n    }\n\n    @Override\n    public void handleError(ConfigurationError error) {\n        for(ConfigurationErrorHandler errorHandler : errorHandlerList){\n            errorHandler.handle(error);\n        }\n    }\n}\n","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.*;\n\nimport static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n        if(!configuration.hasProperty(Properties.Handler.PublicationError)){\n            System.out.println(\"WARN: No error handler configured to handle exceptions during publication.\\n\" +\n                    \"Publication error handlers can be added by AbstractPubSubSupport.addErrorHandler()\\n\" +\n                    \"Configuration error handlers can be added by IBUsConfiguration.addConfigurationErrorHandler()\\n\" +\n                    \"Falling back to console logger.\");\n        }\n        this.errorHandlers.add(configuration.getProperty(Properties.Handler.PublicationError, new IPublicationErrorHandler.ConsoleLogger()));\n        this.runtime = new BusRuntime(this)\n            .add(PublicationError, getRegisteredErrorHandlers())\n            .add(Properties.Common.Id, UUID.randomUUID().toString());\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                .createManager(pubSubFeature.getMetadataReader(),\n                        pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    public final void addErrorHandler(IPublicationErrorHandler handler) {\n        synchronized (this){\n            errorHandlers.add(handler);\n        }\n    }\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass().equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n    }\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/bus/config/IBusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.Collection;\n\n/**\n * The configuration of message bus instances is feature driven, e.g. configuration parameters\n * are grouped into {@link Feature}.\n *\n * Features can be added to a bus configuration to be used later in the instantiation process of the message bus.\n * Each bus will look for the features it requires and configure them according to the provided configuration. If a required feature is not found the bus will publish a {@link ConfigurationError}\n * to the {@link ConfigurationErrorHandler}\n *\n * @author bennidi.\n */\npublic interface IBusConfiguration{\n\n    /**\n     * Set a property which will be read by the message bus constructor. Existing value will be overwritten.\n     * Null values are supported (checking for existence of property will return <code>true</code> even if set to <code>null</code>).\n     *\n     * @param name The name of the property. Note: Each implementation may support different properties.\n     * @param value The value of the property.\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration setProperty(String name, Object value);\n\n    /**\n     * Read a property from this configuration.\n     *\n     * @param name  The name of the property to be read.\n     * @param defaultValue  The value to be returned if property was not found\n     * @param <T>  The type of property\n     * @return The value associated with the given property name or <code>defaultValue</code> if not present\n     */\n    <T> T getProperty(String name, T defaultValue);\n\n    /**\n     * Check whether a property has been set.\n     *\n     * @return true if property was set (even if set to null)\n     *         false otherwise\n     */\n    boolean hasProperty(String name);\n\n\n    /**\n     * Get a registered feature by its type (class).\n     *\n     */\n    <T extends Feature> T getFeature(Class<T> feature);\n\n    /**\n     * Add a feature to the given configuration, replacing any existing feature of the same type.\n     *\n     * @param feature The feature to add\n     * @return  A reference to <code>this</code> bus configuration.\n     */\n    IBusConfiguration addFeature(Feature feature);\n\n    /**\n     * Add a handler that is called when a misconfiguration is detected.\n     */\n    IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler);\n\n    /**\n     * Calls all ConfigurationErrorHandlers\n     */\n    void handleError(ConfigurationError error);\n\n    BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler);\n\n    Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers();\n\n\n}\n","src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    public static final class AssertionErrorHandler implements IPublicationErrorHandler{\n\n        private boolean failOnException;\n\n        public AssertionErrorHandler(boolean failOnException) {\n            this.failOnException = failOnException;\n        }\n\n        @Override\n        public void handleError(PublicationError error) {\n            if(failOnException)\n                org.junit.Assert.fail(error.getCause().getMessage());\n        }\n    }\n\n    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n\n    @Before\n    public void setUp(){\n        issuedPublications = new StrongConcurrentSet<IMessagePublication>();\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public static IBusConfiguration SyncAsync() {\n        return SyncAsync(true);\n    }\n\n    public static IBusConfiguration SyncAsync(boolean failOnError) {\n        return new BusConfiguration()\n            .addFeature(Feature.SyncPubSub.Default())\n            .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n            .addFeature(Feature.AsynchronousMessageDispatch.Default());\n        //DS: removed as publication error handlers now in configuration object\n//            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));\n    }\n\n    public MBassador createBus(IBusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        return bus;\n    }\n\n    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    protected void track(IMessagePublication asynchronously) {\n        issuedPublications.add(asynchronously);\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(IMessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(IMessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/MBassador.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.SyncAsyncPostCommand;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractSyncAsyncMessageBus<T, SyncAsyncPostCommand<T>> implements IMessageBus<T, SyncAsyncPostCommand<T>> {\n\n\n    /**\n     * Default constructor using default setup. super() will also add a default publication error logger\n     */\n    public MBassador(){\n        this(new BusConfiguration()\n                .addFeature(Feature.SyncPubSub.Default())\n                .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n                .addFeature(Feature.AsynchronousMessageDispatch.Default()));\n    }\n\n    /**\n     * Construct with default settings and specified publication error handler\n     *\n     * @param errorHandler\n     */\n    public MBassador(IPublicationErrorHandler errorHandler) {\n        super(new BusConfiguration().addFeature(Feature.SyncPubSub.Default())\n                                    .addFeature(Feature.AsynchronousHandlerInvocation.Default())\n                                    .addFeature(Feature.AsynchronousMessageDispatch.Default())\n                                    .addPublicationErrorHandler(errorHandler));\n    }\n\n    /**\n     * Construct with fully specified configuration\n     *\n     * @param configuration\n     */\n    public MBassador(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n\n\n\n    public IMessagePublication publishAsync(T message) {\n        return addAsynchronousPublication(createMessagePublication(message));\n    }\n\n    public IMessagePublication publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousPublication(createMessagePublication(message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedMessage(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java":"package net.engio.mbassy.bus.common;\n\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.Collection;\n\n/**\n * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n * may not be accessible due to security constraints or is not annotated properly.\n * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n * Error handlers can be added via the {@link IBusConfiguration}.\n *\n */\n\npublic interface ErrorHandlingSupport {\n\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n}\n","src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.ErrorHandlingSupport;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.bus.publication.IPublicationCommand;\n\n/**\n * A message bus implementation that offers only synchronous message publication. Using this bus\n * will not create any new threads.\n */\npublic class SyncMessageBus<T> extends AbstractPubSubSupport<T> implements PubSubSupport<T>, ErrorHandlingSupport, GenericMessagePublicationSupport<T,\n        SyncMessageBus.SyncPostCommand> {\n\n    /**\n     * Default constructor using default setup. super() will also add a default publication error logger\n     */\n    public SyncMessageBus() {\n        super(new BusConfiguration().addFeature(Feature.SyncPubSub.Default()));\n    }\n\n    /**\n     * Construct with default settings and specified publication error handler\n     * @param errorHandler\n     */\n    public SyncMessageBus(IPublicationErrorHandler errorHandler) {\n        super(new BusConfiguration().addFeature(Feature.SyncPubSub.Default()).addPublicationErrorHandler(errorHandler));\n    }\n\n    /**\n     * Construct with fully specified configuration\n     *\n     * @param configuration\n     */\n    public SyncMessageBus(IBusConfiguration configuration) {\n        super(configuration);\n    }\n\n    @Override\n    public void publish(T message) {\n        try {\n            IMessagePublication publication = createMessagePublication(message);\n            publication.execute();\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError().setMessage(\"Error during publication of message\")\n                                                         .setCause(e)\n                                                         .setPublishedMessage(message));\n        }\n    }\n\n    @Override\n    public SyncPostCommand post(T message) {\n        return new SyncPostCommand(message);\n    }\n\n    public class SyncPostCommand implements IPublicationCommand {\n\n        private T message;\n\n        public SyncPostCommand(T message) {\n            this.message = message;\n        }\n\n        @Override\n        public void now() {\n            publish(message);\n        }\n    }\n}\n","src/test/java/net/engio/mbassy/SyncAsyncTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.*;\nimport net.engio.mbassy.listeners.*;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic class SyncAsyncTest extends MessageBusTest {\n\n\n    @Test\n    public void testSyncPublicationSyncHandlers() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.synchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // test single-threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // test multi-threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n    @Test\n    public void testSyncPublicationAsyncHandlers() throws Exception {\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n        final MessageManager messageManager = new MessageManager();\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n    }\n\n    @Test\n    public void testAsynchronousMessagePublication() throws Exception {\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, Listeners.asynchronous())\n                .create(InstancesPerListener, Listeners.noHandlers());\n        final MBassador bus = createBus(SyncAsync(), listeners);\n\n\n        final MessageManager messageManager = new MessageManager();\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);\n\n                bus.post(standardMessage).asynchronously();\n                bus.post(multipartMessage).asynchronously();\n                bus.post(MessageTypes.Simple).asynchronously();\n\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        messageManager.waitForMessages(processingTimeInMS);\n\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        messageManager.waitForMessages(processingTimeInMS);\n\n    }\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: Exception counter added via config\n        IBusConfiguration config = SyncAsync();\n        config.addPublicationErrorHandler(ExceptionCounter);\n        final MBassador bus = new MBassador(config);\n\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).asynchronously();\n\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener, exceptionCount.get());\n\n\n        // multi threaded\n        exceptionCount.set(0);\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        pause(processingTimeInMS);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n\n    }\n\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/BusRuntime.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.error.MissingPropertyException;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Message bus implementations potentially vary in the features they provide and consequently in the components and properties\n * they expose. The runtime is a container for all those dynamic properties and components and is meant to be passed around\n * between collaborating objects such that they may access the different functionality provided by the bus implementation\n * they all belong to.\n *\n * It is the responsibility of the bus implementation to create and configure the runtime according to its capabilities,\n *\n */\npublic class BusRuntime {\n\n    private PubSubSupport provider;\n\n    private Map<String, Object> properties = new HashMap<String, Object>();\n\n    public BusRuntime(PubSubSupport provider) {\n        this.provider = provider;\n    }\n\n    public <T> T get(String key){\n         if(!contains(key))\n             throw new MissingPropertyException(\"The property \" + key + \" is not available in this runtime\");\n         else return (T) properties.get(key);\n     }\n\n    public PubSubSupport getProvider(){\n        return provider;\n    }\n\n    public Collection<String> getKeys(){\n        return properties.keySet();\n    }\n\n    public BusRuntime add(String key, Object property){\n        properties.put(key, property);\n        return this;\n    }\n\n    public boolean contains(String key){\n        return properties.containsKey(key);\n    }\n\n\n}\n","src/test/java/net/engio/mbassy/SyncBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.SyncMessageBus;\nimport net.engio.mbassy.bus.common.GenericMessagePublicationSupport;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.ListenerFactory;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.common.TestUtil;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listeners.CustomInvocationListener;\nimport net.engio.mbassy.listeners.ExceptionThrowingListener;\nimport net.engio.mbassy.listeners.IMessageListener;\nimport net.engio.mbassy.listeners.MessagesListener;\nimport net.engio.mbassy.messages.MessageTypes;\nimport net.engio.mbassy.messages.MultipartMessage;\nimport net.engio.mbassy.messages.StandardMessage;\nimport org.junit.Test;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n *         Date: 2/8/12\n */\npublic abstract class SyncBusTest extends MessageBusTest {\n\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);\n\n    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);\n\n    @Test\n    public void testSynchronousMessagePublication() throws Exception {\n\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, IMessageListener.DefaultListener.class)\n                .create(InstancesPerListener, IMessageListener.DisabledListener.class)\n                .create(InstancesPerListener, MessagesListener.DefaultListener.class)\n                .create(InstancesPerListener, MessagesListener.DisabledListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n                bus.post(MessageTypes.Multipart).now();\n\n                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        MessageTypes.resetAll();\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));\n        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));\n    }\n\n\n\n    @Test\n    public void testExceptionInHandlerInvocation(){\n        final AtomicInteger exceptionCount = new AtomicInteger(0);\n        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {\n            @Override\n            public void handleError(PublicationError error) {\n                exceptionCount.incrementAndGet();\n            }\n        };\n\n        //DS: modified to pass ExceptionCounter via the configuration object\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, ExceptionThrowingListener.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publish = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new StandardMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publish, 1);\n\n        exceptionCount.set(0);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);\n        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());\n    }\n\n    @Test\n    public void testCustomHandlerInvocation(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, CustomInvocationListener.class)\n                .create(InstancesPerListener, Object.class);\n\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                StandardMessage standardMessage = new StandardMessage();\n                MultipartMessage multipartMessage = new MultipartMessage();\n\n                bus.post(standardMessage).now();\n                bus.post(multipartMessage).now();\n                bus.post(MessageTypes.Simple).now();\n\n                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));\n                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n    @Test\n    public void testHandlerPriorities(){\n        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);\n        ListenerFactory listeners = new ListenerFactory()\n                .create(InstancesPerListener, PrioritizedListener.class)\n                .create(InstancesPerListener, Object.class);\n\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n\n        Runnable publishAndCheck = new Runnable() {\n            @Override\n            public void run() {\n                bus.post(new IncrementingMessage()).now();\n            }\n        };\n\n        // single threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);\n\n        // multi threaded\n        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);\n\n    }\n\n\n    public static class MBassadorTest extends SyncBusTest {\n\n        //DS: added errorHandler parameter to allow adding handler from caller\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());\n            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));\n            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));\n            if (errorHandler != null) {\n                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);\n            }\n            return new MBassador(asyncFIFOConfig);\n\n        }\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n\n    }\n\n    public static class SyncMessageBusTest extends SyncBusTest {\n\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {\n            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));\n            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());\n            if (errorHandler != null) {\n                syncPubSubCfg.addPublicationErrorHandler(errorHandler);\n            }\n            return new SyncMessageBus(syncPubSubCfg);\n        }\n\n        @Override\n        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {\n            return getSyncMessageBus(failOnException, null);\n        }\n    }\n\n\n\n\n\n    static class IncrementingMessage{\n\n        private int count = 1;\n\n        public void markHandled(int newVal){\n            // only transitions by the next handler are allowed\n            if(count == newVal || count + 1 == newVal) count = newVal;\n            else throw new RuntimeException(\"Message was handled out of order\");\n        }\n    }\n\n\n    public static class PrioritizedListener{\n\n        @Handler(priority = Integer.MIN_VALUE)\n        public void handle1(IncrementingMessage message) {\n            message.markHandled(4);\n        }\n\n        @Handler(priority = -2)\n        public void handle2(IncrementingMessage message) {\n            message.markHandled(3);\n        }\n\n        @Handler\n        public void handle3(IncrementingMessage message) {\n            message.markHandled(2);\n        }\n\n        @Handler(priority = Integer.MAX_VALUE)\n        public void handle4(IncrementingMessage message) {\n            message.markHandled(1);\n        }\n\n\n    }\n\n\n\n}\n","src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":"package net.engio.mbassy.bus.config;\n\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\n\nimport java.util.*;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour.\n */\npublic class BusConfiguration implements IBusConfiguration {\n\n    // the registered properties\n    private final Map<Object, Object> properties = new HashMap<Object, Object>();\n    private final List<ConfigurationErrorHandler> configurationErrorHandlers = new LinkedList<ConfigurationErrorHandler>();\n    // these are transferred to the bus to receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> publicationErrorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    public BusConfiguration() {\n        super();\n    }\n\n    @Override\n    public IBusConfiguration setProperty(String name, Object value) {\n        properties.put(name, value);\n        return this;\n    }\n\n    @Override\n    public <T> T getProperty(String name, T defaultValue) {\n        return properties.containsKey(name) ? (T) properties.get(name) : defaultValue;\n    }\n\n    @Override\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    @Override\n    public <T extends Feature> T getFeature(Class<T> feature) {\n        return (T) properties.get(feature);\n    }\n\n    @Override\n    public IBusConfiguration addFeature(Feature feature) {\n        properties.put(feature.getClass(), feature);\n        return this;\n    }\n\n    @Override\n    public IBusConfiguration addConfigurationErrorHandler(ConfigurationErrorHandler handler) {\n        configurationErrorHandlers.add(handler);\n        return this;\n    }\n\n    @Override\n    public void handleError(ConfigurationError error) {\n        for(ConfigurationErrorHandler errorHandler : configurationErrorHandlers){\n            errorHandler.handle(error);\n        }\n    }\n\n@Override\n    public final BusConfiguration addPublicationErrorHandler(IPublicationErrorHandler handler) {\n            publicationErrorHandlers.add(handler);\n    return this;\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredPublicationErrorHandlers() {\n        return Collections.unmodifiableCollection(publicationErrorHandlers);\n    }\n}\n","src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.Properties;\nimport net.engio.mbassy.bus.common.PubSubSupport;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.subscription.Subscription;\nimport net.engio.mbassy.subscription.SubscriptionManager;\n\nimport java.util.*;\n\nimport static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n */\npublic abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {\n\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();\n\n    private final MessagePublication.Factory publicationFactory;\n\n    private final SubscriptionManager subscriptionManager;\n\n    private final BusRuntime runtime;\n\n    public static final String ERROR_HANDLER_MSG = \"INFO: No error handler has been configured to handle exceptions during publication.\\n\" +\n            \"Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\\n\" +\n            \"Falling back to console logger.\";\n\n\n\n\n    public AbstractPubSubSupport(IBusConfiguration configuration) {\n\n        //transfer publication error handlers from the config object\n        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());\n        if (errorHandlers.isEmpty()) {\n            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());\n            System.out.println(ERROR_HANDLER_MSG);\n        }\n        this.runtime = new BusRuntime(this).add(PublicationError, getRegisteredErrorHandlers())\n                                           .add(Properties.Common.Id, UUID.randomUUID()\n                                                                          .toString());\n        // configure the pub sub feature\n        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);\n        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()\n                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);\n        this.publicationFactory = pubSubFeature.getPublicationFactory();\n    }\n\n    protected MessagePublication.Factory getPublicationFactory() {\n        return publicationFactory;\n    }\n\n\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        return subscriptionManager.unsubscribe(listener);\n    }\n\n\n    public void subscribe(Object listener) {\n        subscriptionManager.subscribe(listener);\n    }\n\n\n    @Override\n    public BusRuntime getRuntime() {\n        return runtime;\n    }\n\n    protected IMessagePublication createMessagePublication(T message) {\n        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()\n                                                                          .equals(DeadMessage.class)) {\n            // Dead Event\n            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);\n            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));\n        } else {\n            return getPublicationFactory().createPublication(runtime, subscriptions, message);\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        return subscriptionManager.getSubscriptionsByMessageType(messageType);\n    }\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers) {\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"{ \" + runtime.get(Properties.Common.Id) + \"}\";\n    }\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":[[62,63]],"src/test/java/net/engio/mbassy/SyncAsyncTest.java":[[135,136]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[181,182],[183,183],[184,184],[185,185],[186,186],[94,94],[196,197],[198,198],[199,199]],"src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":[[50,50],[56,56]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[36,41],[42,42]]},"postChangeRange":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":[[62,62]],"src/main/java/net/engio/mbassy/bus/MBassador.java":[[39,43],[17,19]],"src/test/java/net/engio/mbassy/SyncAsyncTest.java":[[136,136],[137,137],[138,138]],"src/main/java/net/engio/mbassy/bus/SyncMessageBus.java":[[35,39]],"src/test/java/net/engio/mbassy/SyncBusTest.java":[[196,196],[95,95],[216,216]],"src/main/java/net/engio/mbassy/bus/config/BusConfiguration.java":[[51,51],[57,57]],"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java":[[44,44],[45,48]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java","startLine":45,"endLine":45}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/AbstractPubSubSupport.java","startLine":36,"endLine":36}],"rightSideLocations":[]}],"refactorings":[]},{"repository":"mbassador","sha1":"b15ad227f315aa2bc327f39a0fc7778192811ebe","url":"https://github.com/bennidi/mbassador/commit/b15ad227f315aa2bc327f39a0fc7778192811ebe","preChangeSourceCode":{"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 10000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        IMessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            track(bus.post(new Object()).asynchronously());\n        }\n\n        pause(10000);\n\n        for(SynchronizedWithAsynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.subscription.Subscription;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic interface IMessagePublication {\n\n    boolean add(Subscription subscription);  // TODO: this method should not be part of the interface\n\n    /*\n    TODO: document state transitions\n     */\n    void execute();\n\n    boolean isFinished();\n\n    boolean isRunning();\n\n    boolean isScheduled();\n\n    void markDelivered(); // TODO: this method should not be part of the interface\n\n    IMessagePublication markScheduled(); // TODO: this method should not be part of the interface\n\n    boolean isDeadEvent();\n\n    boolean isFilteredEvent();\n\n    Object getMessage();\n\n\n    // TODO: This interface should only be used as return type to public API calls (clients). Internally the implementation\n    // of the interface should be used. This would allow to remove the unwanted methods from this interface.\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication implements IMessagePublication {\n\n    private final Collection<Subscription> subscriptions;\n    private final Object message;\n    // message publications can be referenced by multiple threads to query publication progress\n    private volatile State state = State.Initial;\n    private volatile boolean delivered = false;\n    private final BusRuntime runtime;\n\n    protected MessagePublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.runtime = runtime;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    /*\n    TODO: document state transitions\n     */\n    public void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n           sub.publish(this, message);\n        }\n        state = State.Finished;\n        // if the message has not been marked delivered by the dispatcher\n        if (!delivered) {\n            if (!isFilteredEvent() && !isDeadEvent()) {\n                runtime.getProvider().publish(new FilteredMessage(message));\n            } else if (!isDeadEvent()) {\n                runtime.getProvider().publish(new DeadMessage(message));\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (state.equals(State.Initial)) {\n            state = State.Scheduled;\n        }\n        return this;\n    }\n\n\n    public boolean isDeadEvent() {\n        return DeadMessage.class.equals(message.getClass());\n    }\n\n    public boolean isFilteredEvent() {\n        return FilteredMessage.class.equals(message.getClass());\n    }\n\n    public Object getMessage() {\n        return message;\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error\n    }\n\n    public static class Factory {\n\n        public IMessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(runtime, subscriptions, message, State.Initial);\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":"package net.engio.mbassy;\n\nimport net.engio.mbassy.bus.BusFactory;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class AsyncFIFOBusTest extends MessageBusTest {\n\n    @Test\n    public void testSingleThreadedSyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncListener> listeners = new LinkedList<SyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncListener listener = new SyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n             messages[i] = i;\n        }\n        // publish in ascending order\n        for(Integer message : messages)\n            fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages())\n            pause(1000);\n\n        for(SyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            for(int i=0; i < messages.length; i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n            }\n        }\n\n    }\n\n    // NOTE: Can fail due to timing issues.\n    @Test\n    public void testSingleThreadedSyncAsyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncAsyncListener> listeners = new LinkedList<SyncAsyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncAsyncListener listener = new SyncAsyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n            messages[i] = i;\n        }\n        // publish in ascending order\n        for(Integer message : messages)\n            fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages())\n            pause(2000);\n\n        for(SyncAsyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            assertEquals(listener.receivedSync.size(), listener.receivedAsync.size());\n            for(int i=0; i < listener.receivedAsync.size(); i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n                // sync and async in same order\n                assertEquals(listener.receivedSync.get(i), listener.receivedAsync.get(i));\n            }\n        }\n\n    }\n\n    /*\n    @Test\n    public void testMultiThreadedSyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        final IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncListener> listeners = new LinkedList<SyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncListener listener = new SyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        final int[] messages = new int[10000];\n        for(int i = 0; i < messages.length ; i++){\n            messages[i] = i;\n        }\n        final AtomicInteger messageIndex = new AtomicInteger(0);\n        // publish in ascending order\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                int idx;\n                while((idx = messageIndex.getAndIncrement()) < messages.length){\n                    fifoBUs.post(messages[idx]).asynchronously();\n                }\n            }\n        }, 5);\n\n        while(fifoBUs.hasPendingMessages())\n            pause(1000);\n\n        for(SyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            for(int i=0; i < messages.length; i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n            }\n        }\n\n    }  */\n\n\n\n    public static class SyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n    }\n\n    public static class SyncAsyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n        private List<Integer> receivedAsync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n        @Handler(delivery = Invoke.Asynchronously)\n        public void handleASync(Integer message){\n            receivedAsync.add(message);\n        }\n\n    }\n\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.bus.config.Feature;\nimport net.engio.mbassy.bus.config.IBusConfiguration;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport net.engio.mbassy.listener.Synchronized;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Todo: Add javadoc\n *\n * @author bennidi\n *         Date: 3/31/13\n */\npublic class SynchronizedHandlerTest extends MessageBusTest {\n\n\n    private static int incrementsPerMessage = 1000;\n    private static int numberOfMessages = 1000;\n    private static int numberOfListeners = 1000;\n\n    @Test\n    public void testSynchronizedWithSynchronousInvocation(){\n        List<SynchronizedWithSynchronousDelivery> handlers = new LinkedList<SynchronizedWithSynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithSynchronousDelivery handler = new SynchronizedWithSynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        IMessagePublication publication = null;\n        for(int i = 0; i < numberOfMessages; i++){\n           publication =  bus.post(new Object()).asynchronously();\n        }\n        // wait for last publication\n        while (!publication.isFinished()){\n            pause(100);\n        }\n\n        for(SynchronizedWithSynchronousDelivery handler : handlers){\n            assertEquals(incrementsPerMessage * numberOfMessages, handler.counter);\n        }\n\n    }\n\n    @Test\n    public void testSynchronizedWithAsSynchronousInvocation(){\n        List<SynchronizedWithAsynchronousDelivery> handlers = new LinkedList<SynchronizedWithAsynchronousDelivery>();\n        IBusConfiguration config = SyncAsync(true);\n        config.getFeature(Feature.AsynchronousMessageDispatch.class)\n                .setNumberOfMessageDispatchers(6);\n        IMessageBus bus = createBus(config);\n        for(int i = 0; i < numberOfListeners; i++){\n            SynchronizedWithAsynchronousDelivery handler = new SynchronizedWithAsynchronousDelivery();\n            handlers.add(handler);\n            bus.subscribe(handler);\n        }\n\n        for(int i = 0; i < numberOfMessages; i++){\n            track(bus.post(new Object()).asynchronously());\n        }\n\n        // Check the handlers processing status\n        // Define timeframe in which processing should be finished\n        // If not then an error is assumed\n        long timeElapsed = 0;\n        long timeOut = 30000; // 30 seconds\n        long begin =  System.currentTimeMillis();\n        while (timeElapsed < timeOut) {\n            boolean successful = true;\n            for (SynchronizedWithAsynchronousDelivery handler : handlers) {\n                successful &= incrementsPerMessage * numberOfMessages ==  handler.counter;\n            }\n            if(successful)\n                break;\n            timeElapsed = System.currentTimeMillis() - begin;\n        }\n        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n\n    }\n\n\n\n    public static class SynchronizedWithSynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler\n        @Synchronized\n        public void handleMessage(Object o){\n           for(int i = 0; i < incrementsPerMessage; i++){\n               counter++;\n           }\n        }\n\n    }\n\n    public static class SynchronizedWithAsynchronousDelivery {\n\n        private int counter = 0;\n\n        @Handler(delivery = Invoke.Asynchronously)\n        @Synchronized\n        public void handleMessage(Object o){\n            for(int i = 0; i < incrementsPerMessage; i++){\n                counter++;\n            }\n        }\n\n    }\n}\n","src/main/java/net/engio/mbassy/bus/IMessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.subscription.Subscription;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic interface IMessagePublication {\n\n    boolean add(Subscription subscription);  // TODO: this method should not be part of the interface\n\n    /*\n    TODO: document state transitions\n     */\n    void execute();\n\n    boolean isFinished();\n\n    boolean isRunning();\n\n    boolean isScheduled();\n\n    void markDelivered(); // TODO: this method should not be part of the interface\n\n    IMessagePublication markScheduled(); // TODO: this method should not be part of the interface\n\n    boolean isDeadMessage();\n\n    boolean isFilteredMessage();\n\n    Object getMessage();\n\n\n    // TODO: This interface should only be used as return type to public API calls (clients). Internally the implementation\n    // of the interface should be used. This would allow to remove the unwanted methods from this interface.\n}\n","src/main/java/net/engio/mbassy/bus/MessagePublication.java":"package net.engio.mbassy.bus;\n\nimport net.engio.mbassy.bus.common.DeadMessage;\nimport net.engio.mbassy.bus.common.FilteredMessage;\nimport net.engio.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\n\n/**\n * A message publication is created for each asynchronous message dispatch. It reflects the state\n * of the corresponding message publication process, i.e. provides information whether the\n * publication was successfully scheduled, is currently running etc.\n * <p/>\n * A message publication lives within a single thread. It is not designed in a thread-safe manner -> not eligible to\n * be used in multiple threads simultaneously .\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MessagePublication implements IMessagePublication {\n\n    private final Collection<Subscription> subscriptions;\n    private final Object message;\n    // message publications can be referenced by multiple threads to query publication progress\n    private volatile State state = State.Initial;\n    private volatile boolean delivered = false;\n    private final BusRuntime runtime;\n\n    protected MessagePublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message, State initialState) {\n        this.runtime = runtime;\n        this.subscriptions = subscriptions;\n        this.message = message;\n        this.state = initialState;\n    }\n\n    public boolean add(Subscription subscription) {\n        return subscriptions.add(subscription);\n    }\n\n    /*\n    TODO: document state transitions\n     */\n    public void execute() {\n        state = State.Running;\n        for (Subscription sub : subscriptions) {\n           sub.publish(this, message);\n        }\n        state = State.Finished;\n        // This part is necessary to support the feature of publishing a DeadMessage or FilteredMessage\n        // in case that the original message has not made it to any listener.\n        // This happens if subscriptions are empty (due to GC of weak listeners or explicit desubscription)\n        // or if configured filters do not let a message pass. The flag is set by the dispatchers.\n        // META: This seems to be a suboptimal design\n        if (!delivered) {\n            if (!isFilteredMessage() && !isDeadMessage()) {\n                runtime.getProvider().publish(new FilteredMessage(message));\n            } else if (!isDeadMessage()) {\n                runtime.getProvider().publish(new DeadMessage(message));\n            }\n\n        }\n    }\n\n    public boolean isFinished() {\n        return state.equals(State.Finished);\n    }\n\n    public boolean isRunning() {\n        return state.equals(State.Running);\n    }\n\n    public boolean isScheduled() {\n        return state.equals(State.Scheduled);\n    }\n\n    public void markDelivered() {\n        delivered = true;\n    }\n\n    public MessagePublication markScheduled() {\n        if (state.equals(State.Initial)) {\n            state = State.Scheduled;\n        }\n        return this;\n    }\n\n\n    public boolean isDeadMessage() {\n        return DeadMessage.class.equals(message.getClass());\n    }\n\n    public boolean isFilteredMessage() {\n        return FilteredMessage.class.equals(message.getClass());\n    }\n\n    public Object getMessage() {\n        return message;\n    }\n\n    private enum State {\n        Initial, Scheduled, Running, Finished, Error\n    }\n\n    public static class Factory {\n\n        public IMessagePublication createPublication(BusRuntime runtime, Collection<Subscription> subscriptions, Object message) {\n            return new MessagePublication(runtime, subscriptions, message, State.Initial);\n        }\n\n    }\n\n}\n","src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.BusFactory;\nimport net.engio.mbassy.bus.IMessagePublication;\nimport net.engio.mbassy.bus.common.IMessageBus;\nimport net.engio.mbassy.common.MessageBusTest;\nimport net.engio.mbassy.listener.Handler;\nimport net.engio.mbassy.listener.Invoke;\nimport org.junit.Test;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n * @author bennidi\n *         Date: 3/30/14\n */\npublic class AsyncFIFOBusTest extends MessageBusTest {\n\n    @Test\n    public void testSingleThreadedSyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncListener> listeners = new LinkedList<SyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncListener listener = new SyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n             messages[i] = i;\n        }\n        // publish in ascending order\n        for(Integer message : messages)\n            fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages())\n            pause(1000);\n\n        for(SyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            for(int i=0; i < messages.length; i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n            }\n        }\n\n    }\n\n    // NOTE: Can fail due to timing issues.\n    @Test\n    public void testSingleThreadedSyncAsyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncAsyncListener> listeners = new LinkedList<SyncAsyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncAsyncListener listener = new SyncAsyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        int[] messages = new int[1000];\n        for(int i = 0; i < messages.length ; i++){\n            messages[i] = i;\n        }\n        IMessagePublication publication = null;\n        // publish in ascending order\n        for(Integer message : messages)\n            publication = fifoBUs.post(message).asynchronously();\n\n        while(fifoBUs.hasPendingMessages() && ! publication.isFinished())\n            pause(200);\n\n        // Check the handlers processing status\n        // Define timeframe in which processing should be finished\n        // If not then an error is assumed\n        long timeElapsed = 0;\n        long timeOut = 30000; // 30 seconds\n        long begin =  System.currentTimeMillis();\n        for(SyncAsyncListener listener : listeners){\n            boolean successful = true;\n            successful &= messages.length == listener.receivedSync.size();\n            successful &=  listener.receivedSync.size() ==listener.receivedAsync.size();\n            for(int i=0; i < listener.receivedAsync.size(); i++){\n                successful &= messages[i] == listener.receivedSync.get(i);\n                // sync and async in same order\n                successful &= listener.receivedSync.get(i) == listener.receivedAsync.get(i);\n            }\n            if(successful)\n                break;\n            timeElapsed = System.currentTimeMillis() - begin;\n        }\n        if(timeElapsed >= timeOut) Assert.fail(\"Processing of handlers unfinished after timeout\");\n\n    }\n\n    /*\n    @Test\n    public void testMultiThreadedSyncFIFO(){\n        // create a fifo bus with 1000 concurrently subscribed listeners\n        final IMessageBus fifoBUs = BusFactory.AsynchronousSequentialFIFO();\n\n        List<SyncListener> listeners = new LinkedList<SyncListener>();\n        for(int i = 0; i < 1000 ; i++){\n            SyncListener listener = new SyncListener();\n            listeners.add(listener);\n            fifoBUs.subscribe(listener);\n        }\n\n        // prepare set of messages in increasing order\n        final int[] messages = new int[10000];\n        for(int i = 0; i < messages.length ; i++){\n            messages[i] = i;\n        }\n        final AtomicInteger messageIndex = new AtomicInteger(0);\n        // publish in ascending order\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                int idx;\n                while((idx = messageIndex.getAndIncrement()) < messages.length){\n                    fifoBUs.post(messages[idx]).asynchronously();\n                }\n            }\n        }, 5);\n\n        while(fifoBUs.hasPendingMessages())\n            pause(1000);\n\n        for(SyncListener listener : listeners){\n            assertEquals(messages.length, listener.receivedSync.size());\n            for(int i=0; i < messages.length; i++){\n                assertEquals(messages[i], listener.receivedSync.get(i));\n            }\n        }\n\n    }  */\n\n\n\n    public static class SyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n    }\n\n    public static class SyncAsyncListener {\n\n        private List<Integer> receivedSync = new LinkedList<Integer>();\n        private List<Integer> receivedAsync = new LinkedList<Integer>();\n\n        @Handler\n        public void handleSync(Integer message){\n            receivedSync.add(message);\n        }\n\n        @Handler(delivery = Invoke.Asynchronously)\n        public void handleASync(Integer message){\n            receivedAsync.add(message);\n        }\n\n    }\n\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":[[74,74],[76,78]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[51,51],[53,53]],"src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":[[73,73],[75,75],[76,76],[79,79],[80,80],[82,82],[84,84]]},"postChangeRange":{"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java":[[78,78],[79,79],[80,80],[81,89],[90,90]],"src/main/java/net/engio/mbassy/bus/MessagePublication.java":[[55,55],[57,57]],"src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java":[[73,73],[76,76],[78,78],[79,79],[84,84],[85,85],[86,86],[88,88],[89,89],[90,90],[92,92],[94,94],[96,97],[98,98],[100,100]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java","startLine":100,"endLine":100}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/AsyncFIFOBusTest.java","startLine":96,"endLine":96}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java","startLine":90,"endLine":90}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/test/java/net/engio/mbassy/SynchronizedHandlerTest.java","startLine":86,"endLine":86}]}],"refactorings":[{"type":"\"Rename Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":53,"endLine":53},{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":51,"endLine":51}],"rightSideLocations":[]},{"type":"\"Rename Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":51,"endLine":51}],"rightSideLocations":[]},{"type":"\"Rename Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":51,"endLine":51},{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":53,"endLine":53}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":55,"endLine":55},{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":57,"endLine":57}]},{"type":"\"Rename Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":51,"endLine":51}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/bus/MessagePublication.java","startLine":55,"endLine":55}]}]},{"repository":"mbassador","sha1":"6aadcbe036b535732ef54f49cebc6498eb3f2d62","url":"https://github.com/bennidi/mbassador/commit/6aadcbe036b535732ef54f49cebc6498eb3f2d62","preChangeSourceCode":{"src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mbassy.filter.Filter;\nimport org.mbassy.filter.MessageFilter;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n * Date: 2/8/12\n */\npublic class MBassadorTest {\n\n\n\t@Test\n\tpublic void testAsynchronous() throws InterruptedException {\n\n\t\tMBassador bus = new MBassador();\n\t\tint listenerCount = 1000;\n\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n\n        for (int i = 1; i <= listenerCount; i++) {\n\t\t\tEventingTestBean bean = new EventingTestBean();\n\t\t\tpersistentReferences.add(bean);\n\t\t\tbus.subscribe(bean);\n\t\t}\n\n\t\tTestEvent event = new TestEvent();\n\t\tTestEvent subEvent = new SubTestEvent();\n\n\t\tbus.publishAsync(event);\n\t\tbus.publishAsync(subEvent);\n\n\t\tThread.sleep(2000);\n\n\t\tAssert.assertTrue(event.counter.get() == 1000);\n\t\tAssert.assertTrue(subEvent.counter.get() == 1000 * 2);\n\n\t}\n\n    @Test\n\tpublic void testSynchronous() throws InterruptedException {\n\n\t\tMBassador bus = new MBassador();\n\t\tint listenerCount = 100;\n\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n\t\tfor (int i = 1; i <= listenerCount; i++) {\n\n\n\t\t\tEventingTestBean bean = new EventingTestBean();\n\t\t\tpersistentReferences.add(bean);\n\t\t\tbus.subscribe(bean);\n\n\t\t\tTestEvent event = new TestEvent();\n\t\t\tTestEvent subEvent = new SubTestEvent();\n\n\t\t\tbus.publish(event);\n\t\t\tbus.publish(subEvent);\n\n            Assert.assertEquals(i, event.counter.get());\n\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            }\n\n\t\t\tAssert.assertEquals(i * 2, subEvent.counter.get());\n\n\t\t}\n\n\t}\n\n    @Test\n\tpublic void testConcurrentPublication() {\n        final MBassador bus = new MBassador();\n        final int listenerCount = 100;\n        final int concurenny = 20;\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final CopyOnWriteArrayList<EventingTestBean> persistentReferences = new CopyOnWriteArrayList<EventingTestBean>();\n\n\t\tConcurrentExecutor.runConcurrent(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\tfor (int i = 0; i < listenerCount; i++) {\n\t\t\t\t\tEventingTestBean bean = new EventingTestBean();\n\t\t\t\t\tpersistentReferences.add(bean);\n                    bus.subscribe(bean);\n\t\t\t\t}\n\n\t\t\t\tlong end = System.currentTimeMillis();\n\t\t\t\tSystem.out.println(\"MBassador: Creating \" + listenerCount + \" listeners took \" + (end - start) + \" ms\");\n\t\t\t}\n\t\t}, concurenny);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                long start = System.currentTimeMillis();\n                for (int i = 0; i < listenerCount; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n\n                long end = System.currentTimeMillis();\n                System.out.println(\"MBassador: Publishing \" + 2 * listenerCount + \" events took \" + (end - start) + \" ms\");\n            }\n        }, concurenny);\n\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n\n        for(TestEvent event : testEvents){\n            Assert.assertEquals(listenerCount * concurenny, event.counter.get());\n        }\n\n        for(SubTestEvent event : subtestEvents){\n            Assert.assertEquals(listenerCount * concurenny * 2, event.counter.get());\n        }\n\n\t}\n\n\n\tpublic static class TestEvent {\n\n\t\tpublic AtomicInteger counter = new AtomicInteger();\n\n\t}\n\n\tpublic static class SubTestEvent extends TestEvent {\n\n\t}\n\n\n\tpublic class EventingTestBean {\n\n        // every event of type TestEvent or any subtype will be delivered\n        // to this listener\n\t\t@Listener\n\t\tpublic void handleTestEvent(TestEvent event) {\n\t\t\tevent.counter.incrementAndGet();\n\t\t}\n\n        // this handler will be invoked asynchronously\n\t\t@Listener(mode = Listener.Dispatch.Asynchronous)\n\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n            event.counter.incrementAndGet();\n\t\t}\n\n        // this handler will receive events of type SubTestEvent\n        // or any subtabe and that passes the given filter\n        @Listener({@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n        public void handleFiltered(SubTestEvent event) {\n            event.counter.incrementAndGet();\n        }\n\n\n\t}\n\n\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport org.mbassy.filter.Filter;\nimport org.mbassy.filter.MessageFilter;\nimport org.mbassy.common.*;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for each concrete message publication.\n * A message publication is the publication of any message using one of the bus' publish(..) methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Listener annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of insertion (subscription) but any\n * class using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any messageHandler may only be subscribed once (subsequent subscriptions of an already subscribed messageHandler will be silently ignored)\n * <p/>\n * Removing a listener means removing all subscribed message handlers of that object. This remove operation\n * immediately takes effect and on all running dispatch processes. A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic class MBassador<T>{\n\n\n\t//  This predicate is used to find all message listeners (methods annotated with @Listener)\n\tprivate static final IPredicate<Method> AllMessageListeners = new IPredicate<Method>() {\n\t\t@Override\n\t\tpublic boolean apply(Method target) {\n\t\t\treturn target.getAnnotation(Listener.class) != null;\n\t\t}\n\t};\n\n    // This is the default error handler it will simply log to standard out and\n    // print stack trace if available\n\tprotected static final class ConsoleLogger implements IPublicationErrorHandler {\n\t\t@Override\n\t\tpublic void handleError(PublicationError error) {\n            System.out.println(error);\n            if (error.getCause() != null) error.getCause().printStackTrace();\n\t\t}\n\t};\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private ExecutorService executor = new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n\n\t// cache already created filter instances\n\tprivate final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n\n\t// all subscriptions per message type\n\t// this is the primary list for dispatching a specific message\n\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n\t// all subscriptions per messageHandler type\n\t// this list provides access for subscribing and unsubsribing\n\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n\t// remember already processed classes that do not contain any listeners\n\tprivate final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n\tprivate IPublicationErrorHandler errorHandler = new ConsoleLogger();\n\n\n    // all threads that are available for asynchronous message dispatching\n    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<T> pendingMessages = new LinkedBlockingQueue<T>();\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            publish(pendingMessages.take());\n                        } catch (InterruptedException e) {\n                            errorHandler.handleError(new PublicationError(e, \"Asnchronous publication interupted\", null, null, null));\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    public MBassador(){\n        initDispatcherThreads(2);\n    }\n\n    public MBassador(int dispatcherThreadCount){\n        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n    }\n\n\n    public void publishAsync(T message){\n        pendingMessages.offer(message);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n\tpublic void publish(T message){\n\t\ttry {\n\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n\t\t\tfor (Subscription subscription : subscriptions) subscription.publish(message);\n\t\t} catch (Throwable e) {\n\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t.setMessage(\"Error during publication of message\")\n\t\t\t\t\t.setCause(e)\n\t\t\t\t\t.setPublishedObject(message));\n\t\t}\n\n\t}\n\n    /**\n     * Immediately unsubscribe all registered message handlers (if any) of the given listener. When this call returns\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the messageHandler was still subscribed).\n     * A call to this method passing null, an already subscribed message or any message that does not define any listeners\n     * will not have any effect.\n     *\n     * @param listener\n     */\n\tpublic void unsubscribe(Object listener){\n\t\tif (listener == null) return;\n\t\tCollection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n\t\tfor (Subscription subscription : subscriptions) {\n\t\t\tsubscription.unsubscribe(listener);\n\t\t}\n\t}\n\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n\tpublic void subscribe(Object listener){\n\t\tClass listeningClass = listener.getClass();\n\t\tif (nonListeners.contains(listeningClass))\n\t\t\treturn; // early reject of known classes that do not participate in eventing\n\t\tCollection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n\t\tif (subscriptionsByListener == null) { // if the type is registered for the first time\n\t\t\tsynchronized (this) { // new subscriptions must be processed sequentially for each class\n\t\t\t\tsubscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n\t\t\t\tif (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n\t\t\t\t\tList<Method> messageHandlers = getListeners(listeningClass);  // get all methods with subscriptions\n\t\t\t\t\tsubscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n\t\t\t\t\tif (messageHandlers.isEmpty()) {  // remember the class as non listening class\n\t\t\t\t\t\tnonListeners.add(listeningClass);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// create subscriptions for all detected listeners\n\t\t\t\t\tfor (Method messageHandler : messageHandlers) {\n\t\t\t\t\t\tif (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n\t\t\t\t\t\tMessageFilter[] filter = getFilter(messageHandler.getAnnotation(Listener.class));\n\t\t\t\t\t\tClass eventType = getMessageType(messageHandler);\n\t\t\t\t\t\tSubscription subscription = new Subscription(messageHandler, filter);\n\t\t\t\t\t\tsubscription.subscribe(listener);\n\t\t\t\t\t\taddMessageTypeSubscription(eventType, subscription);\n\t\t\t\t\t\tsubscriptionsByListener.add(subscription);\n\t\t\t\t\t\t//updateMessageTypeHierarchy(eventType);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// register the message to the existing subscriptions\n\t\tfor (Subscription sub : subscriptionsByListener) sub.subscribe(listener);\n\t}\n\n\n\tpublic void setErrorHandler(IPublicationErrorHandler handler){\n\t\tthis.errorHandler = handler;\n\t}\n\n\n\n\t// obtain the set of subscriptions for the given message type\n\tprivate Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n\t\t// TODO improve with cache\n\t\tCollection<Subscription> subscriptions = new LinkedList<Subscription>();\n\n\t\tif(subscriptionsPerMessage.get(messageType) != null) {\n\t\t\tsubscriptions.addAll(subscriptionsPerMessage.get(messageType));\n\t\t}\n\t\tfor (Class eventSuperType : getSuperclasses(messageType)){\n           if(subscriptionsPerMessage.get(eventSuperType) != null){\n               subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n           }\n        }\n\n\t\treturn subscriptions;\n\t}\n\n    private Collection<Class> getSuperclasses(Class from){\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while(!from.equals(Object.class)){\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n\t// associate a suscription with a message type\n\tprivate void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n\t\tCollection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n\t\tif (subscriptions == null) {\n\t\t\tsubscriptions = new CopyOnWriteArraySet<Subscription>();\n\t\t\tsubscriptionsPerMessage.put(messageType, subscriptions);\n\t\t}\n\t\tsubscriptions.add(subscription);\n\t}\n\n    /*\n\tprivate void updateMessageTypeHierarchy(Class messageType) {\n\t\tfor (Class existingEventType : subscriptionsPerMessage.keySet()) {\n\t\t\tif (existingEventType.equals(messageType)) continue;\n\t\t\tif (messageType.isAssignableFrom(existingEventType)) //message is super type of existing\n\t\t\t\tmessageTypeHierarchy.put(existingEventType, messageType);\n\t\t\telse if (existingEventType.isAssignableFrom(messageType)) { // message is sub type of existing\n\t\t\t\tmessageTypeHierarchy.put(messageType, existingEventType); // add direct super type\n\t\t\t\tmessageTypeHierarchy.putAll(messageType, messageTypeHierarchy.get(existingEventType)); // add all super types of super type\n\t\t\t}\n\t\t}\n\t}*/\n\n\n\tprivate boolean isValidMessageHandler(Method handler) {\n\t\tif (handler.getParameterTypes().length != 1) {\n\t\t\t// a messageHandler only defines one parameter (the message)\n\t\t\tSystem.out.println(\"Found nono or more than one parameter in messageHandler [\" + handler.getName()\n\t\t\t\t\t+ \"]. A messageHandler must define exactly one parameter\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static Class getMessageType(Method listener) {\n\t\treturn listener.getParameterTypes()[0];\n\t}\n\n\t// get all listeners defined by the given class (includes\n\t// listeners defined in super classes)\n\tprivate static List<Method> getListeners(Class<?> target) {\n\t\treturn ReflectionUtils.getMethods(AllMessageListeners, target);\n\t}\n\n\t// retrieve all instances of filters associated with the given subscription\n\tprivate MessageFilter[] getFilter(Listener subscription) {\n\t\tif (subscription.value().length == 0) return null;\n\t\tMessageFilter[] filters = new MessageFilter[subscription.value().length];\n\t\tint i = 0;\n\t\tfor (Filter filterDef : subscription.value()) {\n\t\t\tMessageFilter filter = filterCache.get(filterDef.value());\n\t\t\tif (filter == null) {\n\t\t\t\ttry {\n\t\t\t\t\tfilter = filterDef.value().newInstance();\n\t\t\t\t\tfilterCache.put(filterDef.value(), filter);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t\t\t.setMessage(\"Error retrieving filter\"));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfilters[i] = filter;\n\t\t\ti++;\n\t\t}\n\t\treturn filters;\n\t}\n\n\n\n\tprivate void handlePublicationError(PublicationError error) {\n\t\terrorHandler.handleError(error);\n\t}\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        for(Thread dispatcher : dispatchers){\n            dispatcher.interrupt();\n        }\n    }\n\n    /**\n     * Subscription is a thread safe container for objects that contain message handlers\n     *\n     */\n\tprivate class Subscription {\n\n\t\tprivate final MessageFilter[] filter;\n\n\t\tprivate final Method messageHandler;\n\n\t\tprivate ConcurrentLinkedBag<Object> listeners = new ConcurrentLinkedBag<Object>();\n\n        private boolean isAynchronous;\n\n\t\tprivate Subscription(Method messageHandler, MessageFilter[] filter) {\n\t\t\tthis.messageHandler = messageHandler;\n\t\t\tthis.filter = filter;\n            this.messageHandler.setAccessible(true);\n            this.isAynchronous = messageHandler.getAnnotation(Listener.class).mode().equals(Listener.Dispatch.Asynchronous);\n\t\t}\n\n\n\t\tpublic void subscribe(Object o) {\n\t\t\tlisteners.add(o);\n\n\t\t}\n\n        private void dispatch(final Object message, final Object listener){\n            if(isAynchronous){\n                 MBassador.this.executor.execute(new Runnable() {\n                     @Override\n                     public void run() {\n                         invokeHandler(message, listener);\n                     }\n                 });\n            }\n            else{\n                invokeHandler(message, listener);\n            }\n        }\n\n        private void invokeHandler(final Object message, final Object listener){\n            try {\n                messageHandler.invoke(listener, message);\n            }catch(IllegalAccessException e){\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"The class or method is not accessible\",\n                                messageHandler, listener, message));\n            }\n            catch(IllegalArgumentException e){\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"Wrong arguments passed to method. Was: \" + message.getClass()\n                                + \"Expected: \" + messageHandler.getParameterTypes()[0],\n                                messageHandler, listener, message));\n            }\n            catch (InvocationTargetException e) {\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"Message handler threw exception\",\n                                messageHandler, listener, message));\n            }\n            catch (Throwable e) {\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"Unexpected exception\",\n                                messageHandler, listener, message));\n            }\n        }\n\n\t\tpublic void publish(Object message) {\n\n\t\t\tIterator<Object> iterator = listeners.iterator();\n\t\t\tObject listener = null;\n\t\t\twhile ((listener = iterator.next()) != null) {\n\t\t\t\t\tif(passesFilter(message, listener)) {\n\t\t\t\t\t\tdispatch(message, listener);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean passesFilter(Object message, Object listener) {\n\n\t\t\tif (filter == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < filter.length; i++) {\n\t\t\t\t\tif (!filter[i].accepts(message, listener)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tpublic void unsubscribe(Object existingListener) {\n\t\t\tlisteners.remove(existingListener);\n\t\t}\n\t}\n\n}\n"},"postChangeSourceCode":{"src/test/java/org/mbassy/MBassadorTest.java":"package org.mbassy;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mbassy.filter.Filter;\nimport org.mbassy.filter.MessageFilter;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.\n *\n * @author bennidi\n * Date: 2/8/12\n */\npublic class MBassadorTest {\n\n\n\n    @Test\n    public void testSubscribe() throws InterruptedException {\n\n        MBassador bus = new MBassador();\n        int listenerCount = 1000;\n\n        for (int i = 1; i <= listenerCount; i++) {\n            EventingTestBean bean = new EventingTestBean();\n            bus.subscribe(bean);\n            bus.unsubscribe(new EventingTestBean());\n\n        }\n    }\n\n    @Test\n    public void testUnSubscribe() throws InterruptedException {\n\n        MBassador bus = new MBassador();\n        int listenerCount = 1000;\n\n        for (int i = 1; i <= listenerCount; i++) {\n            bus.unsubscribe(new EventingTestBean());\n\n        }\n    }\n\n\n\t@Test\n\tpublic void testAsynchronous() throws InterruptedException {\n\n\t\tMBassador bus = new MBassador();\n\t\tint listenerCount = 1000;\n\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n\n        for (int i = 1; i <= listenerCount; i++) {\n\t\t\tEventingTestBean bean = new EventingTestBean();\n\t\t\tpersistentReferences.add(bean);\n\t\t\tbus.subscribe(bean);\n\t\t}\n\n\t\tTestEvent event = new TestEvent();\n\t\tTestEvent subEvent = new SubTestEvent();\n\n\t\tbus.publishAsync(event);\n\t\tbus.publishAsync(subEvent);\n\n\t\tThread.sleep(2000);\n\n\t\tAssert.assertTrue(event.counter.get() == 1000);\n\t\tAssert.assertTrue(subEvent.counter.get() == 1000 * 2);\n\n\t}\n\n    @Test\n\tpublic void testSynchronous() throws InterruptedException {\n\n\t\tMBassador bus = new MBassador();\n\t\tint listenerCount = 100;\n\t\tList<EventingTestBean> persistentReferences = new ArrayList();\n\t\tfor (int i = 1; i <= listenerCount; i++) {\n\n\n\t\t\tEventingTestBean bean = new EventingTestBean();\n\t\t\tpersistentReferences.add(bean);\n\t\t\tbus.subscribe(bean);\n\n\t\t\tTestEvent event = new TestEvent();\n\t\t\tTestEvent subEvent = new SubTestEvent();\n\n\t\t\tbus.publish(event);\n\t\t\tbus.publish(subEvent);\n\n            Assert.assertEquals(i, event.counter.get());\n\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n            }\n\n\t\t\tAssert.assertEquals(i * 2, subEvent.counter.get());\n\n\t\t}\n\n\t}\n\n    @Test\n\tpublic void testConcurrentPublication() {\n        final MBassador bus = new MBassador();\n        final int listenerCount = 100;\n        final int concurenny = 20;\n        final CopyOnWriteArrayList<TestEvent> testEvents = new CopyOnWriteArrayList<TestEvent>();\n        final CopyOnWriteArrayList<SubTestEvent> subtestEvents = new CopyOnWriteArrayList<SubTestEvent>();\n        final CopyOnWriteArrayList<EventingTestBean> persistentReferences = new CopyOnWriteArrayList<EventingTestBean>();\n\n\t\tConcurrentExecutor.runConcurrent(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\tfor (int i = 0; i < listenerCount; i++) {\n\t\t\t\t\tEventingTestBean bean = new EventingTestBean();\n\t\t\t\t\tpersistentReferences.add(bean);\n                    bus.subscribe(bean);\n\t\t\t\t}\n\n\t\t\t\tlong end = System.currentTimeMillis();\n\t\t\t\tSystem.out.println(\"MBassador: Creating \" + listenerCount + \" listeners took \" + (end - start) + \" ms\");\n\t\t\t}\n\t\t}, concurenny);\n\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                long start = System.currentTimeMillis();\n                for (int i = 0; i < listenerCount; i++) {\n                    TestEvent event = new TestEvent();\n                    SubTestEvent subEvent = new SubTestEvent();\n                    testEvents.add(event);\n                    subtestEvents.add(subEvent);\n\n                    bus.publishAsync(event);\n                    bus.publish(subEvent);\n                }\n\n                long end = System.currentTimeMillis();\n                System.out.println(\"MBassador: Publishing \" + 2 * listenerCount + \" events took \" + (end - start) + \" ms\");\n            }\n        }, concurenny);\n\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n\n        for(TestEvent event : testEvents){\n            Assert.assertEquals(listenerCount * concurenny, event.counter.get());\n        }\n\n        for(SubTestEvent event : subtestEvents){\n            Assert.assertEquals(listenerCount * concurenny * 2, event.counter.get());\n        }\n\n\t}\n\n\n\tpublic static class TestEvent {\n\n\t\tpublic AtomicInteger counter = new AtomicInteger();\n\n\t}\n\n\tpublic static class SubTestEvent extends TestEvent {\n\n\t}\n\n\n\tpublic class EventingTestBean {\n\n        // every event of type TestEvent or any subtype will be delivered\n        // to this listener\n\t\t@Listener\n\t\tpublic void handleTestEvent(TestEvent event) {\n\t\t\tevent.counter.incrementAndGet();\n\t\t}\n\n        // this handler will be invoked asynchronously\n\t\t@Listener(mode = Listener.Dispatch.Asynchronous)\n\t\tpublic void handleSubTestEvent(SubTestEvent event) {\n            event.counter.incrementAndGet();\n\t\t}\n\n        // this handler will receive events of type SubTestEvent\n        // or any subtabe and that passes the given filter\n        @Listener({@Filter(MessageFilter.None.class),@Filter(MessageFilter.All.class)})\n        public void handleFiltered(SubTestEvent event) {\n            event.counter.incrementAndGet();\n        }\n\n\n\t}\n\n\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport org.mbassy.filter.Filter;\nimport org.mbassy.filter.MessageFilter;\nimport org.mbassy.common.*;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n\npublic class MBassador<T> implements IMessageBus<T, SimplePostCommand>{\n\n\n\t//  This predicate is used to find all message listeners (methods annotated with @Listener)\n\tprivate static final IPredicate<Method> AllMessageListeners = new IPredicate<Method>() {\n\t\t@Override\n\t\tpublic boolean apply(Method target) {\n\t\t\treturn target.getAnnotation(Listener.class) != null;\n\t\t}\n\t};\n\n    // This is the default error handler it will simply log to standard out and\n    // print stack trace if available\n\tprotected static final class ConsoleLogger implements IPublicationErrorHandler {\n\t\t@Override\n\t\tpublic void handleError(PublicationError error) {\n            System.out.println(error);\n            if (error.getCause() != null) error.getCause().printStackTrace();\n\t\t}\n\t};\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private ExecutorService executor;\n\n\t// cache already created filter instances\n\tprivate final Map<Class<? extends MessageFilter>, MessageFilter> filterCache = new HashMap<Class<? extends MessageFilter>, MessageFilter>();\n\n\t// all subscriptions per message type\n\t// this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n\t// all subscriptions per messageHandler type\n\t// this list provides fast access for subscribing and unsubscribing\n\tprivate final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n\t// remember already processed classes that do not contain any listeners\n\tprivate final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n\tprivate IPublicationErrorHandler errorHandler = new ConsoleLogger();\n\n\n    // all threads that are available for asynchronous message dispatching\n    private final CopyOnWriteArrayList<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<T> pendingMessages = new LinkedBlockingQueue<T>();\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            publish(pendingMessages.take());\n                        } catch (InterruptedException e) {\n                            errorHandler.handleError(new PublicationError(e, \"Asynchronous publication interrupted\", null, null, null));\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    public MBassador(){\n        this(2);\n    }\n\n    public MBassador(int dispatcherThreadCount){\n        this(2, new ThreadPoolExecutor(5, 50, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>()));\n    }\n\n    public MBassador(int dispatcherThreadCount, ExecutorService executor){\n        this.executor = executor;\n        initDispatcherThreads(dispatcherThreadCount > 0 ? dispatcherThreadCount : 2);\n    }\n\n\n    public void publishAsync(T message){\n        pendingMessages.offer(message);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n\tpublic void publish(T message){\n\t\ttry {\n\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n\t\t\tif(subscriptions == null){\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions){\n                subscription.publish(message);\n            }\n\t\t} catch (Throwable e) {\n\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t.setMessage(\"Error during publication of message\")\n\t\t\t\t\t.setCause(e)\n\t\t\t\t\t.setPublishedObject(message));\n\t\t}\n\n\t}\n\n\n\tpublic void unsubscribe(Object listener){\n\t\tif (listener == null) return;\n\t\tCollection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n\t\tif(subscriptions == null)return;\n        for (Subscription subscription : subscriptions) {\n\t\t\tsubscription.unsubscribe(listener);\n\t\t}\n\t}\n\n    @Override\n    public SimplePostCommand post(T message) {\n        return new SimplePostCommand(this, message);\n    }\n\n    public void subscribe(Object listener){\n\t\tClass listeningClass = listener.getClass();\n\t\tif (nonListeners.contains(listeningClass))\n\t\t\treturn; // early reject of known classes that do not participate in eventing\n\t\tCollection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n\t\tif (subscriptionsByListener == null) { // if the type is registered for the first time\n\t\t\tsynchronized (this) { // new subscriptions must be processed sequentially for each class\n\t\t\t\tsubscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n\t\t\t\tif (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n\t\t\t\t\tList<Method> messageHandlers = getListeners(listeningClass);  // get all methods with subscriptions\n\t\t\t\t\tsubscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n\t\t\t\t\tif (messageHandlers.isEmpty()) {  // remember the class as non listening class\n\t\t\t\t\t\tnonListeners.add(listeningClass);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// create subscriptions for all detected listeners\n\t\t\t\t\tfor (Method messageHandler : messageHandlers) {\n\t\t\t\t\t\tif (!isValidMessageHandler(messageHandler)) continue; // ignore invalid listeners\n\t\t\t\t\t\tMessageFilter[] filter = getFilter(messageHandler.getAnnotation(Listener.class));\n\t\t\t\t\t\tClass eventType = getMessageType(messageHandler);\n\t\t\t\t\t\tSubscription subscription = createSubscription(messageHandler, filter);\n\t\t\t\t\t\tsubscription.subscribe(listener);\n\t\t\t\t\t\taddMessageTypeSubscription(eventType, subscription);\n\t\t\t\t\t\tsubscriptionsByListener.add(subscription);\n\t\t\t\t\t\t//updateMessageTypeHierarchy(eventType);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// register the listener to the existing subscriptions\n\t\tfor (Subscription sub : subscriptionsByListener) sub.subscribe(listener);\n\t}\n\n\n\tpublic void setErrorHandler(IPublicationErrorHandler handler){\n\t\tthis.errorHandler = handler;\n\t}\n\n\n\n\t// obtain the set of subscriptions for the given message type\n\tprivate Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n\t\tList<Subscription> subscriptions = new LinkedList<Subscription>();\n\n\t\tif(subscriptionsPerMessage.get(messageType) != null) {\n\t\t\tsubscriptions.addAll(subscriptionsPerMessage.get(messageType));\n\t\t}\n\t\tfor (Class eventSuperType : getSuperclasses(messageType)){\n           if(subscriptionsPerMessage.get(eventSuperType) != null){\n               subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n           }\n        }\n        // IMPROVEMENT: use tree list that sorts during insertion\n\t\t//Collections.sort(subscriptions, new SubscriptionByPriorityDesc());\n        return subscriptions;\n\t}\n\n    private Collection<Class> getSuperclasses(Class from){\n        Collection<Class> superclasses = new LinkedList<Class>();\n        while(!from.equals(Object.class)){\n            superclasses.add(from.getSuperclass());\n            from = from.getSuperclass();\n        }\n        return superclasses;\n    }\n\n\t// associate a suscription with a message type\n\tprivate void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n\t\tCollection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n\t\tif (subscriptions == null) {\n\t\t\tsubscriptions = new CopyOnWriteArraySet<Subscription>();\n\t\t\tsubscriptionsPerMessage.put(messageType, subscriptions);\n\t\t}\n\t\tsubscriptions.add(subscription);\n\t}\n\n\n\tprivate boolean isValidMessageHandler(Method handler) {\n\t\tif (handler.getParameterTypes().length != 1) {\n\t\t\t// a messageHandler only defines one parameter (the message)\n\t\t\tSystem.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n\t\t\t\t\t+ \"]. A messageHandler must define exactly one parameter\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static Class getMessageType(Method listener) {\n\t\treturn listener.getParameterTypes()[0];\n\t}\n\n\t// get all listeners defined by the given class (includes\n\t// listeners defined in super classes)\n\tprivate static List<Method> getListeners(Class<?> target) {\n\t\treturn ReflectionUtils.getMethods(AllMessageListeners, target);\n\t}\n\n\t// retrieve all instances of filters associated with the given subscription\n\tprivate MessageFilter[] getFilter(Listener subscription) {\n\t\tif (subscription.value().length == 0) return null;\n\t\tMessageFilter[] filters = new MessageFilter[subscription.value().length];\n\t\tint i = 0;\n\t\tfor (Filter filterDef : subscription.value()) {\n\t\t\tMessageFilter filter = filterCache.get(filterDef.value());\n\t\t\tif (filter == null) {\n\t\t\t\ttry {\n\t\t\t\t\tfilter = filterDef.value().newInstance();\n\t\t\t\t\tfilterCache.put(filterDef.value(), filter);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t\t\t.setMessage(\"Error retrieving filter\"));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfilters[i] = filter;\n\t\t\ti++;\n\t\t}\n\t\treturn filters;\n\t}\n\n\n\n\tprivate void handlePublicationError(PublicationError error) {\n\t\terrorHandler.handleError(error);\n\t}\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        for(Thread dispatcher : dispatchers){\n            dispatcher.interrupt();\n        }\n    }\n\n\n    private Subscription createSubscription(Method messageHandler, MessageFilter[] filter){\n        if(filter == null || filter.length == 0){\n            if(isAsynchronous(messageHandler)){\n                return new UnfilteredAsynchronousSubscription(messageHandler);\n            }\n            else{\n                return new UnfilteredSynchronousSubscription(messageHandler);\n            }\n        }\n        else{\n            if(isAsynchronous(messageHandler)){\n                return new FilteredAsynchronousSubscription(messageHandler, filter);\n            }\n            else{\n                return new FilteredSynchronousSubscription(messageHandler, filter);\n            }\n        }\n    }\n\n    private boolean isAsynchronous(Method messageHandler){\n         return messageHandler.getAnnotation(Listener.class).mode().equals(Listener.Dispatch.Asynchronous);\n    }\n\n\n    /**\n     * Subscription is a thread safe container for objects that contain message handlers\n     */\n\tprivate abstract class Subscription {\n\n\t\tprivate final Method messageHandler;\n\n\t\tprotected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n        private int priority = 0;\n\n\t\tprivate Subscription(Method messageHandler) {\n            // TODO: init priority\n\t\t\tthis.messageHandler = messageHandler;\n            this.messageHandler.setAccessible(true);\n\t\t}\n\n        protected abstract void publish(Object message);\n\n        protected abstract void dispatch(final Object message, final Object listener);\n\n\n        public int getPriority(){\n            return priority;\n        }\n\n\n\t\tpublic void subscribe(Object o) {\n\t\t\tlisteners.add(o);\n\n\t\t}\n\n        protected void invokeHandler(final Object message, final Object listener){\n            try {\n                messageHandler.invoke(listener, message);\n            }catch(IllegalAccessException e){\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"The class or method is not accessible\",\n                                messageHandler, listener, message));\n            }\n            catch(IllegalArgumentException e){\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"Wrong arguments passed to method. Was: \" + message.getClass()\n                                + \"Expected: \" + messageHandler.getParameterTypes()[0],\n                                messageHandler, listener, message));\n            }\n            catch (InvocationTargetException e) {\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"Message handler threw exception\",\n                                messageHandler, listener, message));\n            }\n            catch (Throwable e) {\n                MBassador.this.handlePublicationError(\n                        new PublicationError(e, \"Error during messageHandler notification. \" +\n                                \"Unexpected exception\",\n                                messageHandler, listener, message));\n            }\n        }\n\n\n\t\tpublic void unsubscribe(Object existingListener) {\n\t\t\tlisteners.remove(existingListener);\n\t\t}\n\n\n\n\n\t}\n\n    private abstract class UnfilteredSubscription extends Subscription{\n\n\n        private UnfilteredSubscription(Method messageHandler) {\n            super(messageHandler);\n        }\n\n        public void publish(Object message) {\n\n            Iterator<Object> iterator = listeners.iterator();\n            Object listener = null;\n            while ((listener = iterator.next()) != null) {\n                dispatch(message, listener);\n            }\n        }\n    }\n\n    private class UnfilteredAsynchronousSubscription extends UnfilteredSubscription{\n\n\n        private UnfilteredAsynchronousSubscription(Method messageHandler) {\n            super(messageHandler);\n        }\n\n        protected void dispatch(final Object message, final Object listener){\n                MBassador.this.executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        invokeHandler(message, listener);\n                    }\n                });\n\n        }\n    }\n\n    private class UnfilteredSynchronousSubscription extends UnfilteredSubscription{\n\n\n        private UnfilteredSynchronousSubscription(Method messageHandler) {\n            super(messageHandler);\n        }\n\n        protected void dispatch(final Object message, final Object listener){\n            invokeHandler(message, listener);\n        }\n    }\n\n    private abstract class FilteredSubscription extends Subscription{\n\n        private final MessageFilter[] filter;\n\n\n        private FilteredSubscription(Method messageHandler, MessageFilter[] filter) {\n            super(messageHandler);\n            this.filter = filter;\n        }\n\n        private boolean passesFilter(Object message, Object listener) {\n\n            if (filter == null) {\n                return true;\n            }\n            else {\n                for (int i = 0; i < filter.length; i++) {\n                    if (!filter[i].accepts(message, listener)) return false;\n                }\n                return true;\n            }\n        }\n\n        protected void publish(Object message) {\n\n            Iterator<Object> iterator = listeners.iterator();\n            Object listener = null;\n            while ((listener = iterator.next()) != null) {\n                if(passesFilter(message, listener)) {\n                    dispatch(message, listener);\n                }\n            }\n        }\n    }\n\n    private class FilteredSynchronousSubscription extends FilteredSubscription{\n\n\n        private FilteredSynchronousSubscription(Method messageHandler, MessageFilter[] filter) {\n            super(messageHandler, filter);\n        }\n\n        protected void dispatch(final Object message, final Object listener){\n            MBassador.this.executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    invokeHandler(message, listener);\n                }\n            });\n\n        }\n    }\n\n    private class FilteredAsynchronousSubscription extends FilteredSubscription{\n\n\n        private FilteredAsynchronousSubscription(Method messageHandler, MessageFilter[] filter) {\n            super(messageHandler, filter);\n        }\n\n        protected void dispatch(final Object message, final Object listener){\n            invokeHandler(message, listener);\n        }\n    }\n\n\n    private final class SubscriptionByPriorityDesc implements Comparator<Subscription> {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            return o1.getPriority() - o2.getPriority();\n        }\n    };\n\n}\n"},"preChangeRange":{"src/main/java/org/mbassy/MBassador.java":[[144,144],[368,368],[398,407],[126,126],[354,366],[273,273],[154,162],[122,122],[223,223],[172,178],[199,199],[110,110]]},"postChangeRange":{"src/main/java/org/mbassy/MBassador.java":[[112,114],[115,117],[334,334],[319,319],[89,89],[321,321],[223,223],[131,131],[85,85],[185,185],[162,162],[73,73]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":112,"endLine":112}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":131,"endLine":131}]}],"refactorings":[{"type":"\"Extract Interface\"","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":112,"endLine":112}]},{"type":"\"Extract Interface\"","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":131,"endLine":131}]},{"type":"\"Extract Interface\"","leftSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":355,"endLine":355}],"rightSideLocations":[]},{"type":"\"Extract Subclass\"","leftSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":355,"endLine":355}],"rightSideLocations":[]},{"type":"\"Extract Interface\"","leftSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":403,"endLine":403}],"rightSideLocations":[]},{"type":"\"Extract Subclass\"","leftSideLocations":[{"path":"src/main/java/org/mbassy/MBassador.java","startLine":403,"endLine":403},{"path":"src/main/java/org/mbassy/MBassador.java","startLine":403,"endLine":403}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"c31467da32150ea54b6eafa90f1973ef6ad0345c","url":"https://github.com/bennidi/mbassador/commit/c31467da32150ea54b6eafa90f1973ef6ad0345c","preChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/MessageListener.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * All instances of any class that defines at least one message handler (see @MessageHandler) are message listeners. Thus,\n * a message listener is any object capable of receiving messages by means of defined message handlers.\n * There are no restrictions about the number of allowed message handlers in a message listener.\n *\n * A message listener can be configured using the @Listener annotation but is always implicitly configured by the handler\n * definition it contains.\n *\n * This class is an internal representation of a message listener used to encapsulate all relevant objects\n * and data about that message listener, especially all its handlers.\n * There will be only one instance of MessageListener per message listener class and message bus instance.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListener<T> {\n\n\n    public static IPredicate<MessageHandler> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandler>() {\n            @Override\n            public boolean apply(MessageHandler target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandler> handlers = new ArrayList<MessageHandler>();\n\n    private Class<T> listenerDefinition;\n\n    private Listener listenerAnnotation;\n\n    public MessageListener(Class<T> listenerDefinition) {\n       this.listenerDefinition = listenerDefinition;\n       listenerAnnotation = ReflectionUtils.getAnnotation( listenerDefinition, Listener.class );\n    }\n\n\n    public boolean isFromListener(Class listener){\n        return listenerDefinition.equals(listener);\n    }\n\n    public boolean useStrongReferences(){\n        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n    }\n\n    public MessageListener addHandlers(Collection<? extends MessageHandler> c) {\n        handlers.addAll(c);\n        return this;\n    }\n\n    public boolean addHandler(MessageHandler messageHandler) {\n        return handlers.add(messageHandler);\n    }\n\n    public List<MessageHandler> getHandlers(){\n        return handlers;\n    }\n\n    public List<MessageHandler> getHandlers(IPredicate<MessageHandler> filter) {\n        List<MessageHandler> matching = new LinkedList<MessageHandler>();\n        for (MessageHandler handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n\t        return ReflectionUtils.getAnnotation(target, Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public MessageListener getMessageListener(Class target) {\n        MessageListener listenerMetadata = new MessageListener(target);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        List<Method> allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new LinkedList<Method>();\n        for (Method handler : allHandlers) {\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                bottomMostHandlers.add(handler);\n            }\n        }\n\n        // for each handler there will be no overriding method that specifies @Handler annotation\n        // but an overriding method does inherit the listener configuration of the overwritten method\n        for (Method handler : bottomMostHandlers) {\n            Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n            if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                continue; // disabled or invalid listeners are ignored\n            }\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            // if a handler is overwritten it inherits the configuration of its parent method\n            Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n                    handlerConfig, getFilter(handlerConfig), listenerMetadata);\n            MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n            listenerMetadata.addHandler(handlerMetadata);\n\n        }\n        return listenerMetadata;\n    }\n\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || ReflectionUtils.getAnnotation( handler, Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = ReflectionUtils.getAnnotation( handler, Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n\tpublic static List<Method> getMethods( IPredicate<Method> condition, Class<?> target ) {\n\t\tList<Method> methods = new LinkedList<Method>();\n\t\ttry {\n\t\t\tfor ( Method method : target.getDeclaredMethods() ) {\n\t\t\t\tif ( condition.apply( method ) ) {\n\t\t\t\t\tmethods.add( method );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t//nop\n\t\t}\n\t\tif ( !target.equals( Object.class ) ) {\n\t\t\tmethods.addAll( getMethods( condition, target.getSuperclass() ) );\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/**\n\t * Traverses the class hierarchy upwards, starting at the given subclass, looking\n\t * for an override of the given methods -> finds the bottom most override of the given\n\t * method if any exists\n\t *\n\t * @param overridingMethod\n\t * @param subclass\n\t */\n\tpublic static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n\t\tClass current = subclass;\n\t\twhile ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n\t\t\ttry {\n\t\t\t\treturn current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\tcurrent = current.getSuperclass();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n\tpublic static Set<Class> getSuperTypes(Class from) {\n\t\tSet<Class> superclasses = new HashSet<Class>();\n\t\tcollectInterfaces( from, superclasses );\n\t\twhile ( !from.equals( Object.class ) && !from.isInterface() ) {\n\t\t\tsuperclasses.add( from.getSuperclass() );\n\t\t\tfrom = from.getSuperclass();\n\t\t\tcollectInterfaces( from, superclasses );\n\t\t}\n\t\treturn superclasses;\n\t}\n\n\tpublic static void collectInterfaces( Class from, Set<Class> accumulator ) {\n\t\tfor ( Class intface : from.getInterfaces() ) {\n\t\t\taccumulator.add( intface );\n\t\t\tcollectInterfaces( intface, accumulator );\n\t\t}\n\t}\n\n\tpublic static boolean containsOverridingMethod( final List<Method> allMethods, final Method methodToCheck ) {\n\t\tfor ( Method method : allMethods ) {\n\t\t\tif ( isOverriddenBy( methodToCheck, method ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\t/**\n\t * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n\t *\n\t * @param from AnnotatedElement (class, method...)\n\t * @param annotationType Annotation class to look for.\n\t * @param <A> Class of annotation type\n\t * @return Annotation instance or null\n\t */\n\tprivate static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n\t\tif( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n\t}\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n\tprivate static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n\t\t// if the declaring classes are the same or the subclass method is not defined in the subclass\n\t\t// hierarchy of the given superclass method or the method names are not the same then\n\t\t// subclassMethod does not override superclassMethod\n\t\tif ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tClass[] superClassMethodParameters = superclassMethod.getParameterTypes();\n\t\tClass[] subClassMethodParameters = subclassMethod.getParameterTypes();\n\t\t// method must specify the same number of parameters\n\t\t//the parameters must occur in the exact same order\n\t\tfor ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n\t\t\tif ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage;\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener;\n\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n\n        // ConcurrentHashMapV8 is 15%-20% faster than regular ConcurrentHashMap, which is also faster than HashMap.\n        subscriptionsPerMessage = new HashMap<Class, Collection<Subscription>>(64);\n        subscriptionsPerListener = new HashMap<Class, Collection<Subscription>>(64);\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Collection<Subscription> subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Collection<Subscription> getSubscriptionsByListener(Object listener) {\n        Collection<Subscription> subscriptions;\n        ReadLock readLock = readWriteLock.readLock();\n        try {\n            readLock.lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readLock.unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            Class<?> listenerClass = listener.getClass();\n\n            if (nonListeners.contains(listenerClass)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n            \n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                List<MessageHandler> messageHandlers = metadataReader.getMessageListener(listenerClass).getHandlers();\n                if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listenerClass);\n                    return;\n                }\n                subscriptionsByListener = new ArrayDeque<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                // create subscriptions for all detected message handlers\n                for (MessageHandler messageHandler : messageHandlers) {\n                    // create the subscription\n                    subscriptionsByListener.add(subscriptionFactory.createSubscription(runtime, messageHandler));\n                }\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Collection<Subscription> subscriptions) {\n        WriteLock writeLock = readWriteLock.writeLock();\n        try {\n            writeLock.lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Collection<Subscription> subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        addMessageTypeSubscription(messageType, subscription);\n                    }\n                }\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n\n\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        ReadLock readLock = readWriteLock.readLock();\n        try {\n            readLock.lock();\n\n            if (subscriptionsPerMessage.get(messageType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n            }\n            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (Subscription sub : subs) {\n                        if (sub.handlesMessageType(messageType)) {\n                            subscriptions.add(sub);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readLock.unlock();\n        }\n        return subscriptions;\n    }\n\n\n    // associate a subscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n}\n"},"postChangeSourceCode":{"src/main/java/net/engio/mbassy/listener/MessageListener.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * All instances of any class that defines at least one message handler (see @MessageHandler) are message listeners. Thus,\n * a message listener is any object capable of receiving messages by means of defined message handlers.\n * There are no restrictions about the number of allowed message handlers in a message listener.\n *\n * A message listener can be configured using the @Listener annotation but is always implicitly configured by the handler\n * definition it contains.\n *\n * This class is an internal representation of a message listener used to encapsulate all relevant objects\n * and data about that message listener, especially all its handlers.\n * There will be only one instance of MessageListener per message listener class and message bus instance.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListener<T> {\n\n\n    public static IPredicate<MessageHandler> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandler>() {\n            @Override\n            public boolean apply(MessageHandler target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private ArrayList<MessageHandler> handlers = new ArrayList<MessageHandler>();\n\n    private Class<T> listenerDefinition;\n\n    private Listener listenerAnnotation;\n\n    public MessageListener(Class<T> listenerDefinition) {\n       this.listenerDefinition = listenerDefinition;\n       listenerAnnotation = ReflectionUtils.getAnnotation( listenerDefinition, Listener.class );\n    }\n\n\n    public boolean isFromListener(Class listener){\n        return listenerDefinition.equals(listener);\n    }\n\n    public boolean useStrongReferences(){\n        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n    }\n\n    public MessageListener addHandlers(Collection<? extends MessageHandler> c) {\n        handlers.addAll(c);\n        return this;\n    }\n\n    public boolean addHandler(MessageHandler messageHandler) {\n        return handlers.add(messageHandler);\n    }\n\n    public MessageHandler[] getHandlers(){\n        MessageHandler[] asArray = new MessageHandler[handlers.size()];\n        return handlers.toArray(asArray);\n    }\n\n    public List<MessageHandler> getHandlers(IPredicate<MessageHandler> filter) {\n        List<MessageHandler> matching = new ArrayList<MessageHandler>();\n        for (MessageHandler handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/listener/MetadataReader.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n *         Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Handler)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return ReflectionUtils.getAnnotation(target, Handler.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Handler subscription) {\n        if (subscription.filters().length == 0) {\n            return null;\n        }\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try {\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public MessageListener getMessageListener(Class target) {\n        MessageListener listenerMetadata = new MessageListener(target);\n        // get all handlers (this will include all (inherited) methods directly annotated using @Handler)\n        Method[] allHandlers = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        final int length = allHandlers.length;\n\n        // retain only those that are at the bottom of their respective class hierarchy (deepest overriding method)\n        List<Method> bottomMostHandlers = new ArrayList<Method>(length);\n\n        Method handler;\n        for (int i = 0; i < length; i++) {\n            handler = allHandlers[i];\n\n            if (!ReflectionUtils.containsOverridingMethod(allHandlers, handler)) {\n                // for each handler there will be no overriding method that specifies @Handler annotation\n                // but an overriding method does inherit the listener configuration of the overwritten method\n\n                Handler handlerConfig = ReflectionUtils.getAnnotation( handler, Handler.class);\n                if (!handlerConfig.enabled() || !isValidMessageHandler(handler)) {\n                    continue; // disabled or invalid listeners are ignored\n                }\n                Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n                // if a handler is overwritten it inherits the configuration of its parent method\n                Map<String, Object> handlerProperties = MessageHandler.Properties.Create(overriddenHandler == null ? handler : overriddenHandler,\n                                                                                         handlerConfig,\n                                                                                         getFilter(handlerConfig),\n                                                                                         listenerMetadata);\n                MessageHandler handlerMetadata = new MessageHandler(handlerProperties);\n                listenerMetadata.addHandler(handlerMetadata);\n            }\n        }\n\n        return listenerMetadata;\n    }\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler == null || ReflectionUtils.getAnnotation( handler, Handler.class) == null) {\n            return false;\n        }\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = ReflectionUtils.getAnnotation( handler, Enveloped.class);\n        if (envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])) {\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if (envelope != null && envelope.messages().length == 0) {\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n}\n","src/main/java/net/engio/mbassy/common/ReflectionUtils.java":"package net.engio.mbassy.common;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * @author bennidi\n *         Date: 2/16/12\n *         Time: 12:14 PM\n */\npublic class ReflectionUtils\n{\n\n    public static Method[] getMethods(IPredicate<Method> condition, Class<?> target) {\n        ArrayList<Method> methods = new ArrayList<Method>();\n\n        getMethods(condition, target, methods);\n\n        final Method[] array = new Method[methods.size()];\n        methods.toArray(array);\n        return array;\n    }\n\n\n    public static void getMethods(IPredicate<Method> condition, Class<?> target, ArrayList<Method> methods) {\n        try {\n            for ( Method method : target.getDeclaredMethods() ) {\n                if ( condition.apply( method ) ) {\n                    methods.add( method );\n                }\n            }\n        }\n        catch ( Exception e ) {\n            //nop\n        }\n        if ( !target.equals( Object.class ) ) {\n            getMethods(condition, target.getSuperclass(), methods);\n        }\n    }\n\n    /**\n    * Traverses the class hierarchy upwards, starting at the given subclass, looking\n    * for an override of the given methods -> finds the bottom most override of the given\n    * method if any exists\n    *\n    * @param overridingMethod\n    * @param subclass\n    */\n    public static Method getOverridingMethod( final Method overridingMethod, final Class subclass ) {\n        Class current = subclass;\n        while ( !current.equals( overridingMethod.getDeclaringClass() ) ) {\n            try {\n                return current.getDeclaredMethod( overridingMethod.getName(), overridingMethod.getParameterTypes() );\n            }\n            catch ( NoSuchMethodException e ) {\n                current = current.getSuperclass();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collect all directly and indirectly related super types (classes and interfaces) of\n     * a given class.\n     *\n     * @param from The root class to start with\n     * @return A set of classes, each representing a super type of the root class\n     */\n    public static Class[] getSuperTypes(Class from) {\n        ArrayList<Class> superclasses = new ArrayList<Class>();\n\n        collectInterfaces( from, superclasses );\n        while ( !from.equals( Object.class ) && !from.isInterface() ) {\n            superclasses.add( from.getSuperclass() );\n            from = from.getSuperclass();\n            collectInterfaces( from, superclasses );\n        }\n\n        final Class[] classes = new Class[superclasses.size()];\n        superclasses.toArray(classes);\n        return classes;\n    }\n\n    public static void collectInterfaces( Class from, Collection<Class> accumulator ) {\n        for ( Class intface : from.getInterfaces() ) {\n            accumulator.add( intface );\n            collectInterfaces( intface, accumulator );\n        }\n    }\n\n    public static boolean containsOverridingMethod( final Method[] allMethods, final Method methodToCheck ) {\n        final int length = allMethods.length;\n        Method method;\n        for (int i = 0; i < length; i++) {\n            method = allMethods[i];\n\n            if ( isOverriddenBy( methodToCheck, method ) ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n\n    /**\n    * Searches for an Annotation of the given type on the class.  Supports meta annotations.\n    *\n    * @param from AnnotatedElement (class, method...)\n    * @param annotationType Annotation class to look for.\n    * @param <A> Class of annotation type\n    * @return Annotation instance or null\n    */\n    private static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType, Set<AnnotatedElement> visited) {\n        if( visited.contains(from) ) return null;\n        visited.add(from);\n        A ann = from.getAnnotation( annotationType );\n        if( ann != null) return ann;\n        for ( Annotation metaAnn : from.getAnnotations() ) {\n            ann = getAnnotation(metaAnn.annotationType(), annotationType, visited);\n            if ( ann != null ) {\n                return ann;\n            }\n        }\n        return null;\n    }\n\n    public static <A extends Annotation> A getAnnotation( AnnotatedElement from, Class<A> annotationType){\n       return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\n    }\n\n    private static boolean isOverriddenBy( Method superclassMethod, Method subclassMethod ) {\n        // if the declaring classes are the same or the subclass method is not defined in the subclass\n        // hierarchy of the given superclass method or the method names are not the same then\n        // subclassMethod does not override superclassMethod\n        if ( superclassMethod.getDeclaringClass().equals(subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getDeclaringClass().isAssignableFrom( subclassMethod.getDeclaringClass() )\n                || !superclassMethod.getName().equals(subclassMethod.getName())) {\n            return false;\n        }\n\n        Class[] superClassMethodParameters = superclassMethod.getParameterTypes();\n        Class[] subClassMethodParameters = subclassMethod.getParameterTypes();\n        // method must specify the same number of parameters\n        //the parameters must occur in the exact same order\n        for ( int i = 0; i < subClassMethodParameters.length; i++ ) {\n            if ( !superClassMethodParameters[i].equals( subClassMethodParameters[i] ) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.bus.BusRuntime;\nimport net.engio.mbassy.common.ReflectionUtils;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.listener.MessageHandler;\nimport net.engio.mbassy.listener.MetadataReader;\n\nimport java.util.*;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n\n/**\n * The subscription managers responsibility is to consistently handle and synchronize the message listener subscription process.\n * It provides fast lookup of existing subscriptions when another instance of an already known\n * listener is subscribed and takes care of creating new set of subscriptions for any unknown class that defines\n * message handlers.\n *\n * @author bennidi\n *         Date: 5/11/13\n */\npublic class SubscriptionManager {\n\n    // the metadata reader that is used to inspect objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens only when a listener of a specific class is registered the first time\n    private final Map<Class, ArrayList<Subscription>> subscriptionsPerMessage;\n\n    // all subscriptions per messageHandler type\n    // this map provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    // once a collection of subscriptions is stored it does not change\n    private final Map<Class, Subscription[]> subscriptionsPerListener;\n\n\n    // remember already processed classes that do not contain any message handlers\n    private final StrongConcurrentSet<Class> nonListeners = new StrongConcurrentSet<Class>();\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // synchronize read/write acces to the subscription maps\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final BusRuntime runtime;\n\n    public SubscriptionManager(MetadataReader metadataReader, SubscriptionFactory subscriptionFactory, BusRuntime runtime) {\n        this.metadataReader = metadataReader;\n        this.subscriptionFactory = subscriptionFactory;\n        this.runtime = runtime;\n\n        subscriptionsPerMessage = new HashMap<Class, ArrayList<Subscription>>(64);\n        subscriptionsPerListener = new HashMap<Class, Subscription[]>(64);\n    }\n\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) {\n            return false;\n        }\n        Subscription[] subscriptions = getSubscriptionsByListener(listener);\n        if (subscriptions == null) {\n            return false;\n        }\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved &= subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    private Subscription[] getSubscriptionsByListener(Object listener) {\n        Subscription[] subscriptions;\n        ReadLock readLock = readWriteLock.readLock();\n        try {\n            readLock.lock();\n            subscriptions = subscriptionsPerListener.get(listener.getClass());\n        } finally {\n            readLock.unlock();\n        }\n        return subscriptions;\n    }\n\n    public void subscribe(Object listener) {\n        try {\n            Class<?> listenerClass = listener.getClass();\n\n            if (nonListeners.contains(listenerClass)) {\n                return; // early reject of known classes that do not define message handlers\n            }\n\n            Subscription[] subscriptionsByListener = getSubscriptionsByListener(listener);\n            // a listener is either subscribed for the first time\n            if (subscriptionsByListener == null) {\n                MessageHandler[] messageHandlers = metadataReader.getMessageListener(listenerClass).getHandlers();\n                int length = messageHandlers.length;\n\n                if (length == 0) {  // remember the class as non listening class if no handlers are found\n                    nonListeners.add(listenerClass);\n                    return;\n                }\n                subscriptionsByListener = new Subscription[length]; // it's safe to use non-concurrent collection here (read only)\n\n                // create subscriptions for all detected message handlers\n                MessageHandler messageHandler;\n                for (int i=0; i<length; i++) {\n                    messageHandler = messageHandlers[i];\n                    subscriptionsByListener[i] = subscriptionFactory.createSubscription(runtime, messageHandler);\n                }\n\n                // this will acquire a write lock and handle the case when another thread already subscribed\n                // this particular listener in the mean-time\n                subscribe(listener, subscriptionsByListener);\n            } // or the subscriptions already exist and must only be updated\n            else {\n                for (Subscription sub : subscriptionsByListener) {\n                    sub.subscribe(listener);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private void subscribe(Object listener, Subscription[] subscriptions) {\n        WriteLock writeLock = readWriteLock.writeLock();\n        try {\n            writeLock.lock();\n            // basically this is a deferred double check\n            // it's an ugly pattern but necessary because atomic upgrade from read to write lock\n            // is not possible\n            // the alternative of using a write lock from the beginning would decrease performance dramatically\n            // because of the huge number of reads compared to writes\n            Subscription[] subscriptionsByListener = getSubscriptionsByListener(listener);\n\n            if (subscriptionsByListener == null) {\n                for (Subscription subscription : subscriptions) {\n                    subscription.subscribe(listener);\n\n                    for (Class<?> messageType : subscription.getHandledMessageTypes()) {\n                        // associate a subscription with a message type\n                        ArrayList<Subscription> subscriptions2 = subscriptionsPerMessage.get(messageType);\n                        if (subscriptions2 == null) {\n                            subscriptions2 = new ArrayList<Subscription>(8);\n                            subscriptionsPerMessage.put(messageType, subscriptions2);\n                        }\n                        subscriptions2.add(subscription);\n                    }\n                }\n\n                subscriptionsPerListener.put(listener.getClass(), subscriptions);\n            }\n            // the rare case when multiple threads concurrently subscribed the same class for the first time\n            // one will be first, all others will have to subscribe to the existing instead the generated subscriptions\n            else {\n                for (Subscription existingSubscription : subscriptionsByListener) {\n                    existingSubscription.subscribe(listener);\n                }\n            }\n        } finally {\n            writeLock.unlock();\n        }\n\n\n    }\n\n    // obtain the set of subscriptions for the given message type\n    // Note: never returns null!\n    public Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n        ReadLock readLock = readWriteLock.readLock();\n        try {\n            readLock.lock();\n\n            Subscription subscription;\n            ArrayList<Subscription> subsPerMessage = subscriptionsPerMessage.get(messageType);\n\n            if (subsPerMessage != null) {\n                subscriptions.addAll(subsPerMessage);\n            }\n\n            for (Class eventSuperType : ReflectionUtils.getSuperTypes(messageType)) {\n                ArrayList<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n                if (subs != null) {\n                    for (int i = 0; i < subs.size(); i++) {\n                        subscription = subs.get(i);\n\n                        if (subscription.handlesMessageType(messageType)) {\n                            subscriptions.add(subscription);\n                        }\n                    }\n                }\n            }\n        }finally{\n            readLock.unlock();\n        }\n        return subscriptions;\n    }\n}\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/listener/MessageListener.java":[[67,69],[72,72]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[60,60],[62,62],[63,64],[65,66],[71,83]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[65,65],[66,66],[73,73],[19,19],[20,20],[21,30],[31,33],[34,34]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[58,58],[59,59],[67,67],[171,173],[175,175],[177,180],[99,99],[102,102],[103,103],[107,107],[109,112],[79,79],[80,80]]},"postChangeRange":{"src/main/java/net/engio/mbassy/listener/MessageListener.java":[[67,70],[73,73]],"src/main/java/net/engio/mbassy/listener/MetadataReader.java":[[61,61],[62,62],[65,65],[67,67],[68,71],[72,87]],"src/main/java/net/engio/mbassy/common/ReflectionUtils.java":[[76,76],[77,77],[86,86],[87,87],[88,88],[21,21],[22,22],[24,24],[26,26],[27,27],[28,28]],"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java":[[57,57],[58,58],[66,66],[183,183],[184,184],[186,188],[191,191],[193,198],[98,98],[101,101],[102,102],[104,104],[108,108],[111,111],[112,115],[78,78],[79,79]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":76,"endLine":76}]},{"type":"EncapsulateInCondition","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":73,"endLine":73}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MetadataReader.java","startLine":76,"endLine":76}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java","startLine":186,"endLine":186}]}],"refactorings":[{"type":"\"Extract Method\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":31,"endLine":31},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":31,"endLine":31},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":23,"endLine":23},{"path":"src/main/java/net/engio/mbassy/common/ReflectionUtils.java","startLine":31,"endLine":31}],"rightSideLocations":[]},{"type":"\"Inline Method\"","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java","startLine":196,"endLine":196}]},{"type":"\"Rename Variable\"","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java","startLine":196,"endLine":196}]},{"type":"\"Extract Variable\"","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/subscription/SubscriptionManager.java","startLine":171,"endLine":171}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"39ab0d61efad48fa65646a4aa829e70ed7e5b2f7","url":"https://github.com/bennidi/mbassador/commit/39ab0d61efad48fa65646a4aa829e70ed7e5b2f7","preChangeSourceCode":{"src/main/java/org/mbassy/listener/Listener.java":"package org.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any object as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Listener {\n\n\n\tFilter[] filters() default {}; // no filters by default\n\n    Mode dispatch() default Mode.Synchronous;\n\n    int priority() default 0;\n\n}\n","src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":"package org.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.dispatch.MessagingContext;\nimport org.mbassy.listener.MessageHandlerMetadata;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final LinkedBlockingQueue<SubscriptionDeliveryRequest<T>> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n    // indicates whether the shutdown method has been invoked\n    // -> if true, then dispatchers will have been shutdown\n    private final AtomicBoolean isShutDown = new AtomicBoolean(false);\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<SubscriptionDeliveryRequest<T>>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    protected void addAsynchronousDeliveryRequest(SubscriptionDeliveryRequest<T> request) {\n        pendingMessages.offer(request);\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            if (subscriptionsPerMessage.get(eventSuperType) != null) {\n                subscriptions.addAll(subscriptionsPerMessage.get(eventSuperType));\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n        isShutDown.set(true);\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/org/mbassy/SyncAsyncPostCommand.java":"package org.mbassy;\n\n/**\n * This post command provides access to standard synchronous and asynchronous dispatch\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n\n    private T message;\n    private MBassador<T> mBassador;\n\n    public SyncAsyncPostCommand(MBassador<T> mBassador, T message) {\n        this.mBassador = mBassador;\n        this.message = message;\n    }\n\n    @Override\n    public void now() {\n        mBassador.publish(message);\n    }\n\n    @Override\n    public void asynchronously() {\n        mBassador.publishAsync(message);\n    }\n}\n","src/main/java/org/mbassy/subscription/Subscription.java":"package org.mbassy.subscription;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\nimport org.mbassy.common.ConcurrentSet;\nimport org.mbassy.dispatch.IMessageDispatcher;\nimport org.mbassy.dispatch.MessagingContext;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private MessagingContext context;\n\n    public Subscription(MessagingContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public void publish(Object message){\n          dispatcher.dispatch(message, listeners);\n    }\n\n    public MessagingContext getContext(){\n        return context;\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n","src/test/java/org/mbassy/AllTests.java":"package org.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MBassadorTest.class,\n        FilterTest.class\n})\npublic class AllTests {\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport java.util.Collection;\n\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionDeliveryRequest;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>>{\n\n    public MBassador(BusConfiguration configuration){\n        super(configuration);\n    }\n\n\n    public void publishAsync(T message){\n        addAsynchronousDeliveryRequest(new SubscriptionDeliveryRequest<T>(getSubscriptionsByMessageType(message.getClass()), message));\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n\tpublic void publish(T message){\n\t\ttry {\n\t\t\tfinal Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n\t\t\tif(subscriptions == null){\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions){\n                subscription.publish(message);\n            }\n\t\t} catch (Throwable e) {\n\t\t\thandlePublicationError(new PublicationError()\n\t\t\t\t\t.setMessage(\"Error during publication of message\")\n\t\t\t\t\t.setCause(e)\n\t\t\t\t\t.setPublishedObject(message));\n\t\t}\n\n\t}\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/org/mbassy/BusConfiguration.java":"package org.mbassy;\n\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour. *\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration {\n\n    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread thread = Executors.defaultThreadFactory().newThread(r);\n            thread.setDaemon(true);\n            return thread;\n        }\n    };\n\n    public static final BusConfiguration Default(){\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    private SubscriptionFactory subscriptionFactory;\n\n    private MetadataReader metadataReader;\n\n    public BusConfiguration() {\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.subscriptionFactory = new SubscriptionFactory();\n        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n        this.metadataReader = new MetadataReader();\n    }\n\n    public MetadataReader getMetadataReader() {\n        return metadataReader;\n    }\n\n    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n        this.metadataReader = metadataReader;\n        return this;\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n    public SubscriptionFactory getSubscriptionFactory() {\n        return subscriptionFactory;\n    }\n\n    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n        this.subscriptionFactory = subscriptionFactory;\n        return this;\n    }\n}\n","src/main/java/org/mbassy/IMessageBus.java":"package org.mbassy;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Listener annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    public void subscribe(Object listener);\n\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     *\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return  true, if the listener was found and successfully removed\n     *          false otherwise\n     */\n    public boolean unsubscribe(Object listener);\n\n    /**\n     *\n     * @param message\n     * @return\n     */\n    public P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    public Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    public boolean hasPendingMessages();\n\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     *\n     */\n    public static interface IPostCommand{\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        public void now();\n\n        /**\n         * Execute the message publication asynchronously. This call return immediately and all matching message handlers\n         * will be invoked in another thread.\n         */\n        public void asynchronously();\n\n    }\n\n}\n","src/main/java/org/mbassy/listener/MetadataReader.java":"package org.mbassy.listener;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        List<Method>  handlers = new LinkedList<Method>();\n        for(Method listener : allMethods){\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(listener, target);\n\n            if(overriddenHandler != null && isHandler(overriddenHandler)){\n                handlers.add(overriddenHandler);\n            }\n            if(overriddenHandler == null){\n                handlers.add(listener);\n            }\n        }\n        handlers =  ReflectionUtils.withoutOverridenSuperclassMethods(handlers);\n        List<MessageHandlerMetadata> messageHandlers = new ArrayList<MessageHandlerMetadata>(handlers.size());\n        for(Method handler : handlers){\n            if(isValidMessageHandler(handler))\n                messageHandlers.add(getHandlerMetadata(handler));\n        }\n        return messageHandlers;\n    }\n\n    private static boolean isHandler(Method m){\n        Annotation[] annotations  = m.getDeclaredAnnotations();\n        for(Annotation annotation : annotations){\n            if(annotation.annotationType().equals(Listener.class))return true;\n        }\n        return false;\n    }\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n"},"postChangeSourceCode":{"src/main/java/org/mbassy/listener/Listener.java":"package org.mbassy.listener;\n\nimport java.lang.annotation.*;\n\n/**\n * Mark any method of any object as a message handler and configure the handler\n * using different properties.\n *\n * @author bennidi\n * Date: 2/8/12\n */\n@Retention(value = RetentionPolicy.RUNTIME)\n@Inherited\n@Target(value = {ElementType.METHOD})\npublic @interface Listener {\n\n\n\tFilter[] filters() default {}; // no filters by default\n\n    Mode dispatch() default Mode.Synchronous;\n\n    int priority() default 0;\n\n    boolean handlesSubtypes() default true;\n\n}\n","src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":"package org.mbassy.listener;\n\nimport java.lang.reflect.Method;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n *\n *\n * @author bennidi\n * Date: 11/14/12\n */\npublic class MessageHandlerMetadata {\n\n    private Method handler;\n\n    private IMessageFilter[] filter;\n\n    private Listener listenerConfig;\n\n    private boolean isAsynchronous = false;\n\n    private Enveloped envelope = null;\n\n    private List<Class<?>> handledMessages = new LinkedList<Class<?>>();\n\n    private boolean acceptsSubtypes = true;\n\n\n    public MessageHandlerMetadata(Method handler, IMessageFilter[] filter, Listener listenerConfig) {\n        this.handler = handler;\n        this.filter = filter;\n        this.listenerConfig = listenerConfig;\n        this.isAsynchronous = listenerConfig.dispatch().equals(Mode.Asynchronous);\n        this.envelope = handler.getAnnotation(Enveloped.class);\n        this.acceptsSubtypes = listenerConfig.handlesSubtypes();\n        if(this.envelope != null){\n            for(Class messageType : envelope.messages())\n                handledMessages.add(messageType);\n        }\n        else{\n            handledMessages.add(handler.getParameterTypes()[0]);\n        }\n        this.handler.setAccessible(true);\n    }\n\n\n    public boolean isAsynchronous(){\n        return isAsynchronous;\n    }\n\n    public boolean isFiltered(){\n        return filter != null && filter.length > 0;\n    }\n\n    public int getPriority(){\n        return listenerConfig.priority();\n    }\n\n    public Method getHandler() {\n        return handler;\n    }\n\n    public IMessageFilter[] getFilter() {\n        return filter;\n    }\n\n    public List<Class<?>> getHandledMessages(){\n        return handledMessages;\n    }\n\n    public boolean isEnveloped() {\n        return envelope != null;\n    }\n\n    public boolean handlesMessage(Class<?> messageType){\n        for(Class<?> handledMessage : handledMessages){\n            if(handledMessage.equals(messageType))return true;\n            if(handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) return true;\n        }\n        return false;\n    }\n\n    public boolean acceptsSubtypes(){\n        return acceptsSubtypes;\n    }\n\n\n}\n","src/main/java/org/mbassy/AbstractMessageBus.java":"package org.mbassy;\n\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.dispatch.MessagingContext;\nimport org.mbassy.listener.MessageHandlerMetadata;\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.Subscription;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * The base class for all message bus implementations.\n *\n * @param <T>\n * @param <P>\n */\npublic abstract class AbstractMessageBus<T, P extends IMessageBus.IPostCommand> implements IMessageBus<T, P> {\n\n    // executor for asynchronous listeners using unbound queuing strategy to ensure that no events get lost\n    private final ExecutorService executor;\n\n    // the metadata reader that is used to parse objects passed to the subscribe method\n    private final MetadataReader metadataReader;\n\n    // all subscriptions per message type\n    // this is the primary list for dispatching a specific message\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerMessage = new HashMap(50);\n\n    // all subscriptions per messageHandler type\n    // this list provides fast access for subscribing and unsubscribing\n    // write access is synchronized and happens very infrequently\n    private final Map<Class, Collection<Subscription>> subscriptionsPerListener = new HashMap(50);\n\n    // remember already processed classes that do not contain any listeners\n    private final Collection<Class> nonListeners = new HashSet();\n\n    // this handler will receive all errors that occur during message dispatch or message handling\n    private final List<IPublicationErrorHandler> errorHandlers = new CopyOnWriteArrayList<IPublicationErrorHandler>();\n\n    // all threads that are available for asynchronous message dispatching\n    private final List<Thread> dispatchers = new CopyOnWriteArrayList<Thread>();\n\n    // all pending messages scheduled for asynchronous dispatch are queued here\n    private final BlockingQueue<MessagePublication<T>> pendingMessages;\n\n    // this factory is used to create specialized subscriptions based on the given message handler configuration\n    // it can be customized by implementing the getSubscriptionFactory() method\n    private final SubscriptionFactory subscriptionFactory;\n\n\n\n    public AbstractMessageBus(BusConfiguration configuration) {\n        this.executor = configuration.getExecutor();\n        subscriptionFactory = configuration.getSubscriptionFactory();\n        this.metadataReader = configuration.getMetadataReader();\n        pendingMessages  = new LinkedBlockingQueue<MessagePublication<T>>(configuration.getMaximumNumberOfPendingMessages());\n        initDispatcherThreads(configuration.getNumberOfMessageDispatchers());\n        addErrorHandler(new IPublicationErrorHandler.ConsoleLogger());\n    }\n\n\n    // initialize the dispatch workers\n    private void initDispatcherThreads(int numberOfThreads) {\n        for (int i = 0; i < numberOfThreads; i++) {\n            // each thread will run forever and process incoming\n            //dispatch requests\n            Thread dispatcher = new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        try {\n                            pendingMessages.take().execute();\n                        } catch (InterruptedException e) {\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                }\n            });\n            dispatcher.setDaemon(true); // do not prevent the JVM from exiting\n            dispatchers.add(dispatcher);\n            dispatcher.start();\n        }\n    }\n\n    @Override\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {\n        return Collections.unmodifiableCollection(errorHandlers);\n    }\n\n    public boolean unsubscribe(Object listener) {\n        if (listener == null) return false;\n        Collection<Subscription> subscriptions = subscriptionsPerListener.get(listener.getClass());\n        if (subscriptions == null) return false;\n        boolean isRemoved = true;\n        for (Subscription subscription : subscriptions) {\n            isRemoved = isRemoved && subscription.unsubscribe(listener);\n        }\n        return isRemoved;\n    }\n\n\n    public void subscribe(Object listener) {\n        try {\n            Class listeningClass = listener.getClass();\n            if (nonListeners.contains(listeningClass))\n                return; // early reject of known classes that do not participate in eventing\n            Collection<Subscription> subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n            if (subscriptionsByListener == null) { // if the type is registered for the first time\n                synchronized (this) { // new subscriptions must be processed sequentially\n                    subscriptionsByListener = subscriptionsPerListener.get(listeningClass);\n                    if (subscriptionsByListener == null) {  // double check (a bit ugly but works here)\n                        List<MessageHandlerMetadata> messageHandlers = metadataReader.getMessageHandlers(listeningClass);\n                        if (messageHandlers.isEmpty()) {  // remember the class as non listening class if no handlers are found\n                            nonListeners.add(listeningClass);\n                            return;\n                        }\n                        subscriptionsByListener = new ArrayList<Subscription>(messageHandlers.size()); // it's safe to use non-concurrent collection here (read only)\n                        // create subscriptions for all detected listeners\n                        for (MessageHandlerMetadata messageHandler : messageHandlers) {\n                            // create the subscription\n                            Subscription subscription = subscriptionFactory\n                                    .createSubscription(new MessagingContext(this, messageHandler));\n                            subscription.subscribe(listener);\n                            subscriptionsByListener.add(subscription);// add it for the listener type (for future subscriptions)\n\n                            List<Class<?>> messageTypes = messageHandler.getHandledMessages();\n                            for(Class<?> messageType : messageTypes){\n                                addMessageTypeSubscription(messageType, subscription);\n                            }\n                            //updateMessageTypeHierarchy(eventType);\n                        }\n                        subscriptionsPerListener.put(listeningClass, subscriptionsByListener);\n                    }\n                }\n            }\n            // register the listener to the existing subscriptions\n            for (Subscription sub : subscriptionsByListener){\n                sub.subscribe(listener);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void addErrorHandler(IPublicationErrorHandler handler) {\n        errorHandlers.add(handler);\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request){\n        try {\n            pendingMessages.put(request);\n            return request.markScheduled();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // this method enqueues a message delivery request\n    protected MessagePublication<T> addAsynchronousDeliveryRequest(MessagePublication<T> request, long timeout, TimeUnit unit){\n        try {\n            return pendingMessages.offer(request, timeout, unit)\n                    ? request.markScheduled()\n                    : request.setError();\n        } catch (InterruptedException e) {\n            return request.setError();\n        }\n    }\n\n    // obtain the set of subscriptions for the given message type\n    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {\n        Set<Subscription> subscriptions = new TreeSet<Subscription>(Subscription.SubscriptionByPriorityDesc);\n\n        if (subscriptionsPerMessage.get(messageType) != null) {\n            subscriptions.addAll(subscriptionsPerMessage.get(messageType));\n        }\n        // TODO: get superclasses is eligible for caching\n        for (Class eventSuperType : ReflectionUtils.getSuperclasses(messageType)) {\n            Collection<Subscription> subs = subscriptionsPerMessage.get(eventSuperType);\n            if (subs != null) {\n                for(Subscription sub : subs){\n                    if(sub.handlesMessageType(messageType))subscriptions.add(sub);\n                }\n            }\n        }\n        return subscriptions;\n    }\n\n\n\n    // associate a suscription with a message type\n    // NOTE: Not thread-safe! must be synchronized in outer scope\n    private void addMessageTypeSubscription(Class messageType, Subscription subscription) {\n        Collection<Subscription> subscriptions = subscriptionsPerMessage.get(messageType);\n        if (subscriptions == null) {\n            subscriptions = new LinkedList<Subscription>();\n            subscriptionsPerMessage.put(messageType, subscriptions);\n        }\n        subscriptions.add(subscription);\n    }\n\n\n\n\n    public void handlePublicationError(PublicationError error) {\n        for (IPublicationErrorHandler errorHandler : errorHandlers){\n            errorHandler.handleError(error);\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        shutdown();\n        super.finalize();\n    }\n\n    private void shutdown(){\n        for (Thread dispatcher : dispatchers) {\n            dispatcher.interrupt();\n        }\n        executor.shutdown();\n    }\n\n    public boolean hasPendingMessages(){\n        return pendingMessages.size() > 0;\n    }\n\n    @Override\n    public Executor getExecutor() {\n        return executor;\n    }\n\n}\n","src/main/java/org/mbassy/SyncAsyncPostCommand.java":"package org.mbassy;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * This post command provides access to standard synchronous and asynchronous dispatch\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic class SyncAsyncPostCommand<T> implements IMessageBus.IPostCommand {\n\n    private T message;\n    private MBassador<T> mBassador;\n\n    public SyncAsyncPostCommand(MBassador<T> mBassador, T message) {\n        this.mBassador = mBassador;\n        this.message = message;\n    }\n\n    @Override\n    public void now() {\n        mBassador.publish(message);\n    }\n\n    @Override\n    public MessagePublication<T> asynchronously() {\n        return mBassador.publishAsync(message);\n    }\n\n    @Override\n    public MessagePublication asynchronously(long timeout, TimeUnit unit) {\n        return mBassador.publishAsync(message, timeout, unit);\n    }\n}\n","src/main/java/org/mbassy/subscription/Subscription.java":"package org.mbassy.subscription;\n\nimport java.util.Comparator;\nimport java.util.UUID;\n\nimport org.mbassy.common.ConcurrentSet;\nimport org.mbassy.dispatch.IMessageDispatcher;\nimport org.mbassy.dispatch.MessagingContext;\n\n/**\n * A subscription is a thread safe container for objects that contain message handlers\n */\npublic class Subscription {\n\n    private UUID id = UUID.randomUUID();\n\n    protected ConcurrentSet<Object> listeners = new ConcurrentSet<Object>();\n\n    private IMessageDispatcher dispatcher;\n\n    private MessagingContext context;\n\n    public Subscription(MessagingContext context, IMessageDispatcher dispatcher) {\n        this.context = context;\n        this.dispatcher = dispatcher;\n    }\n\n\n    public boolean handlesMessageType(Class<?> messageType){\n        return context.getHandlerMetadata().handlesMessage(messageType);\n    }\n\n\n    public void publish(Object message){\n          dispatcher.dispatch(message, listeners);\n    }\n\n    public MessagingContext getContext(){\n        return context;\n    }\n\n    public int getPriority(){\n        return context.getHandlerMetadata().getPriority();\n    }\n\n\n    public void subscribe(Object o) {\n        listeners.add(o);\n    }\n\n\n    public boolean unsubscribe(Object existingListener) {\n        return listeners.remove(existingListener);\n    }\n\n    public int size(){\n        return listeners.size();\n    }\n\n\n    public static final Comparator<Subscription> SubscriptionByPriorityDesc = new Comparator<Subscription>() {\n        @Override\n        public int compare(Subscription o1, Subscription o2) {\n            int result =  o1.getPriority() - o2.getPriority();\n            return result == 0 ? o1.id.compareTo(o2.id): result;\n        }\n    };\n\n}\n","src/test/java/org/mbassy/AllTests.java":"package org.mbassy;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n/**\n * Test suite for running all available unit tests\n *\n * @author bennidi\n *         Date: 11/23/12\n */\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ConcurrentSetTest.class,\n        MBassadorTest.class,\n        FilterTest.class,\n        MetadataReaderTest.class\n})\npublic class AllTests {\n}\n","src/main/java/org/mbassy/MBassador.java":"package org.mbassy;\n\nimport org.mbassy.subscription.Subscription;\n\nimport java.util.Collection;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class MBassador<T> extends AbstractMessageBus<T, SyncAsyncPostCommand<T>> {\n\n    public MBassador(BusConfiguration configuration) {\n        super(configuration);\n    }\n\n\n    public MessagePublication<T> publishAsync(T message) {\n        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n                getSubscriptionsByMessageType(message.getClass()), message));\n    }\n\n    public MessagePublication<T> publishAsync(T message, long timeout, TimeUnit unit) {\n        return addAsynchronousDeliveryRequest(MessagePublication.Create(\n                getSubscriptionsByMessageType(message.getClass()), message), timeout, unit);\n    }\n\n\n    /**\n     * Synchronously publish a message to all registered listeners (this includes listeners defined for super types)\n     * The call blocks until every messageHandler has processed the message.\n     *\n     * @param message\n     */\n    public void publish(T message) {\n        try {\n            final Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());\n            if (subscriptions == null) {\n                return; // TODO: Dead Event?\n            }\n            for (Subscription subscription : subscriptions) {\n                subscription.publish(message);\n            }\n        } catch (Throwable e) {\n            handlePublicationError(new PublicationError()\n                    .setMessage(\"Error during publication of message\")\n                    .setCause(e)\n                    .setPublishedObject(message));\n        }\n\n    }\n\n\n    @Override\n    public SyncAsyncPostCommand<T> post(T message) {\n        return new SyncAsyncPostCommand<T>(this, message);\n    }\n\n}\n","src/main/java/org/mbassy/BusConfiguration.java":"package org.mbassy;\n\nimport org.mbassy.listener.MetadataReader;\nimport org.mbassy.subscription.SubscriptionFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * The bus configuration holds various parameters that can be used to customize the bus' runtime behaviour. *\n *\n * @author bennidi\n *         Date: 12/8/12\n */\npublic class BusConfiguration {\n\n    private static final ThreadFactory DaemonThreadFactory = new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread thread = Executors.defaultThreadFactory().newThread(r);\n            thread.setDaemon(true);\n            return thread;\n        }\n    };\n\n    public static final BusConfiguration Default(){\n        return new BusConfiguration();\n    }\n\n    private int numberOfMessageDispatchers;\n\n    private ExecutorService executor;\n\n    private int maximumNumberOfPendingMessages;\n\n    private SubscriptionFactory subscriptionFactory;\n\n    private MetadataReader metadataReader;\n\n    public BusConfiguration() {\n        this.numberOfMessageDispatchers = 2;\n        this.maximumNumberOfPendingMessages = Integer.MAX_VALUE;\n        this.subscriptionFactory = new SubscriptionFactory();\n        this.executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), DaemonThreadFactory);\n        this.metadataReader = new MetadataReader();\n\n    }\n\n    public MetadataReader getMetadataReader() {\n        return metadataReader;\n    }\n\n    public BusConfiguration setMetadataReader(MetadataReader metadataReader) {\n        this.metadataReader = metadataReader;\n        return this;\n    }\n\n    public int getNumberOfMessageDispatchers() {\n        return numberOfMessageDispatchers > 0 ? numberOfMessageDispatchers : 2;\n    }\n\n    public BusConfiguration setNumberOfMessageDispatchers(int numberOfMessageDispatchers) {\n        this.numberOfMessageDispatchers = numberOfMessageDispatchers;\n        return this;\n    }\n\n    public ExecutorService getExecutor() {\n        return executor;\n    }\n\n    public BusConfiguration setExecutor(ExecutorService executor) {\n        this.executor = executor;\n        return this;\n    }\n\n    public int getMaximumNumberOfPendingMessages() {\n        return maximumNumberOfPendingMessages;\n    }\n\n    public BusConfiguration setMaximumNumberOfPendingMessages(int maximumNumberOfPendingMessages) {\n        this.maximumNumberOfPendingMessages = maximumNumberOfPendingMessages > 0\n                ? maximumNumberOfPendingMessages\n                : Integer.MAX_VALUE;\n        return this;\n    }\n\n    public SubscriptionFactory getSubscriptionFactory() {\n        return subscriptionFactory;\n    }\n\n    public BusConfiguration setSubscriptionFactory(SubscriptionFactory subscriptionFactory) {\n        this.subscriptionFactory = subscriptionFactory;\n        return this;\n    }\n}\n","src/main/java/org/mbassy/IMessageBus.java":"package org.mbassy;\n\nimport java.util.Collection;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n *\n * A message bus offers facilities for publishing messages to registered listeners. Messages can be dispatched\n * synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.\n * The dispatch mechanism can by controlled for per message handler and message publication.\n * A message publication is the publication of any message using one of the bus' publication methods.\n * <p/>\n * Each message publication is isolated from all other running publications such that it does not interfere with them.\n * Hence, the bus expects message handlers to be stateless as it may invoke them concurrently if multiple\n * messages get published asynchronously.\n * <p/>\n * A listener is any object that defines at least one message handler and that has been subscribed to at least\n * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked\n * as a message handler using the @Listener annotation.\n * <p/>\n * The bus uses weak references to all listeners such that registered listeners do not need to\n * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are\n * removed on-the-fly as messages get dispatched.\n * <p/>\n * Generally message handlers will be invoked in inverse sequence of subscription but any\n * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver\n * a specific message exactly once to each of the subscribed message handlers.\n * <p/>\n * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally\n * a message handler may define filters to narrow the set of messages that it accepts.\n * <p/>\n * Subscribed message handlers are available to all pending message publications that have not yet started processing.\n * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener\n * will be silently ignored)\n * <p/>\n * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation\n * immediately takes effect and on all running dispatch processes -> A removed listener (a listener\n * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.\n * Any running message publication that has not yet delivered the message to the removed listener will not see the listener\n * after the remove operation completed.\n *\n * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will\n * get dispatched to all message handlers that take an instance of List as their parameter\n *\n * @Author bennidi\n * Date: 2/8/12\n */\npublic interface IMessageBus<T, P extends IMessageBus.IPostCommand> {\n\n    /**\n     * Subscribe all listeners of the given message to receive message publications.\n     * Any message may only be subscribed once (subsequent subscriptions of an already subscribed\n     * message will be silently ignored)\n     *\n     * @param listener\n     */\n    public void subscribe(Object listener);\n\n\n    /**\n     * Immediately remove all registered message handlers (if any) of the given listener. When this call returns all handlers\n     * have effectively been removed and will not receive any message publications (including asynchronously scheduled\n     * publications that have been published when the message listener was still subscribed).\n     *\n     * A call to this method passing null, an already unsubscribed listener or any object that does not define any message\n     * handlers will not have any effect and is silently ignored.\n     *\n     * @param listener\n     * @return  true, if the listener was found and successfully removed\n     *          false otherwise\n     */\n    public boolean unsubscribe(Object listener);\n\n    /**\n     *\n     * @param message\n     * @return\n     */\n    public P post(T message);\n\n    /**\n     * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,\n     * may not be accessible due to security constraints or is not annotated properly.\n     * In any of all possible cases a publication error is created and passed to each of the registered error handlers.\n     * A call to this method will add the given error handler to the chain\n     *\n     * @param errorHandler\n     */\n    public void addErrorHandler(IPublicationErrorHandler errorHandler);\n\n    /**\n     * Returns an immutable collection containing all the registered error handlers\n     *\n     * @return\n     */\n    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();\n\n\n    /**\n     * Get the executor service that is used to asynchronous message publication.\n     * The executor is passed to the message bus at creation time.\n     *\n     * @return\n     */\n    public Executor getExecutor();\n\n    /**\n     * Check whether any asynchronous message publications are pending for being processed\n     *\n     * @return\n     */\n    public boolean hasPendingMessages();\n\n\n    /**\n     * A post command is used as an intermediate object created by a call to the message bus' post method.\n     * It encapsulates the functionality provided by the message bus that created the command.\n     * Subclasses may extend this interface and add functionality, e.g. different dispatch schemes.\n     *\n     */\n    public static interface IPostCommand<T>{\n\n        /**\n         * Execute the message publication immediately. This call blocks until every matching message handler\n         * has been invoked.\n         */\n        public void now();\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call might block until the message can be placed in the queue.\n         *\n         * @return A message publication that can be used to access information about the state of\n         */\n        public MessagePublication<T> asynchronously();\n\n\n        /**\n         * Execute the message publication asynchronously. The behaviour of this method depends on the\n         * configured queuing strategy:\n         *\n         * If an unbound queuing strategy is used the call returns immediately.\n         * If a bounded queue is used the call will block until the message can be placed in the queue\n         * or the timeout r\n         *\n         * @return A message publication that wraps up the publication request\n         */\n        public MessagePublication<T> asynchronously(long timeout, TimeUnit unit);\n\n    }\n\n}\n","src/main/java/org/mbassy/listener/MetadataReader.java":"package org.mbassy.listener;\n\nimport org.mbassy.common.IPredicate;\nimport org.mbassy.common.ReflectionUtils;\nimport org.mbassy.subscription.MessageEnvelope;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n *\n * The meta data reader is responsible for parsing and validating message handler configurations.\n *\n * @author bennidi\n * Date: 11/16/12\n */\npublic class MetadataReader {\n\n    //  This predicate is used to find all message listeners (methods annotated with @Listener)\n    private static final IPredicate<Method> AllMessageHandlers = new IPredicate<Method>() {\n        @Override\n        public boolean apply(Method target) {\n            return target.getAnnotation(Listener.class) != null;\n        }\n    };\n\n    // cache already created filter instances\n    private final Map<Class<? extends IMessageFilter>, IMessageFilter> filterCache = new HashMap<Class<? extends IMessageFilter>, IMessageFilter>();\n\n    // retrieve all instances of filters associated with the given subscription\n    private IMessageFilter[] getFilter(Listener subscription){\n        if (subscription.filters().length == 0) return null;\n        IMessageFilter[] filters = new IMessageFilter[subscription.filters().length];\n        int i = 0;\n        for (Filter filterDef : subscription.filters()) {\n            IMessageFilter filter = filterCache.get(filterDef.value());\n            if (filter == null) {\n                try{\n                    filter = filterDef.value().newInstance();\n                    filterCache.put(filterDef.value(), filter);\n                }\n                catch (Exception e){\n                    throw new RuntimeException(e);// propagate as runtime exception\n                }\n\n            }\n            filters[i] = filter;\n            i++;\n        }\n        return filters;\n    }\n\n\n    public MessageHandlerMetadata getHandlerMetadata(Method messageHandler){\n        Listener config = messageHandler.getAnnotation(Listener.class);\n        return new MessageHandlerMetadata(messageHandler, getFilter(config), config);\n    }\n\n    // get all listeners defined by the given class (includes\n    // listeners defined in super classes)\n    public List<MessageHandlerMetadata> getMessageHandlers(Class<?> target) {\n        // get all handlers (this will include overridden handlers)\n        List<Method> allMethods = ReflectionUtils.getMethods(AllMessageHandlers, target);\n        List<MessageHandlerMetadata>  handlers = new LinkedList<MessageHandlerMetadata>();\n        for(Method handler : allMethods){\n            Method overriddenHandler = ReflectionUtils.getOverridingMethod(handler, target);\n            if(overriddenHandler == null && isValidMessageHandler(handler)){\n                // add the handler only if it has not been overridden because\n                // either the override in the subclass deactivates the handler (by not specifying the @Listener)\n                // or the handler defined in the subclass is part of the list and will be processed itself\n                handlers.add(getHandlerMetadata(handler));\n            }\n        }\n        return handlers;\n    }\n\n\n    public <T> MessageListenerMetadata<T> getMessageListener(Class<T> target) {\n        return new MessageListenerMetadata(getMessageHandlers(target), target);\n    }\n\n\n\n    private boolean isValidMessageHandler(Method handler) {\n        if (handler.getParameterTypes().length != 1) {\n            // a messageHandler only defines one parameter (the message)\n            System.out.println(\"Found no or more than one parameter in messageHandler [\" + handler.getName()\n                    + \"]. A messageHandler must define exactly one parameter\");\n            return false;\n        }\n        Enveloped envelope = handler.getAnnotation(Enveloped.class);\n        if(envelope != null && !MessageEnvelope.class.isAssignableFrom(handler.getParameterTypes()[0])){\n            System.out.println(\"Message envelope configured but no subclass of MessageEnvelope found as parameter\");\n            return false;\n        }\n        if(envelope != null && envelope.messages().length == 0){\n            System.out.println(\"Message envelope configured but message types defined for handler\");\n            return false;\n        }\n        return true;\n    }\n\n}\n"},"preChangeRange":{"src/main/java/org/mbassy/AbstractMessageBus.java":[[172,174],[212,212],[65,65]],"src/main/java/org/mbassy/SyncAsyncPostCommand.java":[[25,25],[26,26]],"src/main/java/org/mbassy/MBassador.java":[[16,16],[17,17]],"src/main/java/org/mbassy/IMessageBus.java":[[130,130],[131,131],[133,133]],"src/main/java/org/mbassy/listener/MetadataReader.java":[[64,64],[65,73],[75,75],[76,76],[77,80],[81,81]]},"postChangeRange":{"src/main/java/org/mbassy/listener/MessageHandlerMetadata.java":[[36,36]],"src/main/java/org/mbassy/AbstractMessageBus.java":[[184,184],[185,189],[60,60]],"src/main/java/org/mbassy/SyncAsyncPostCommand.java":[[27,27],[28,28]],"src/main/java/org/mbassy/MBassador.java":[[16,16],[17,18]],"src/main/java/org/mbassy/IMessageBus.java":[[131,131],[132,132],[134,134],[135,135],[137,137],[139,139]],"src/main/java/org/mbassy/listener/MetadataReader.java":[[65,65],[66,73],[75,75]]},"microChanges":[{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/AbstractMessageBus.java","startLine":185,"endLine":185},{"path":"src/main/java/org/mbassy/AbstractMessageBus.java","startLine":187,"endLine":187}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/org/mbassy/AbstractMessageBus.java","startLine":187,"endLine":187}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/org/mbassy/AbstractMessageBus.java","startLine":172,"endLine":172}],"rightSideLocations":[{"path":"src/main/java/org/mbassy/AbstractMessageBus.java","startLine":187,"endLine":187}]},{"type":"EncapsulateInCondition","leftSideLocations":[{"path":"src/main/java/org/mbassy/listener/MetadataReader.java","startLine":78,"endLine":78}],"rightSideLocations":[{"path":"src/main/java/org/mbassy/listener/MetadataReader.java","startLine":68,"endLine":68}]},{"type":"ExtractFromCondition","leftSideLocations":[{"path":"src/main/java/org/mbassy/listener/MetadataReader.java","startLine":68,"endLine":68}],"rightSideLocations":[]}],"refactorings":[{"type":"\"Extract Variable\"","leftSideLocations":[{"path":"src/main/java/org/mbassy/AbstractMessageBus.java","startLine":172,"endLine":172}],"rightSideLocations":[]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/main/java/org/mbassy/listener/MetadataReader.java","startLine":68,"endLine":68},{"path":"src/main/java/org/mbassy/listener/MetadataReader.java","startLine":71,"endLine":71}],"rightSideLocations":[{"path":"src/main/java/org/mbassy/listener/MetadataReader.java","startLine":68,"endLine":68}]}]},{"repository":"mbassador","sha1":"55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9","url":"https://github.com/bennidi/mbassador/commit/55d9ad8daf204d3b6fb8ed0761c3d5ef2f3d83d9","preChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n    \n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSetWeak.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSetWeak.contains(uniqueObject));\n        }\n    }\n\n    @Test\n    public void testPerformance() {\n        final HashSet<Object> source = new HashSet<Object>();\n\n        final HashSet<Object> hashSet = new HashSet<Object>();\n\n        final IConcurrentSet weakConcurrentSet = createSet();\n\n        for (int i = 0; i < 1000000; i++) {\n            source.add(new Object());\n        }\n\n\n        long start = System.currentTimeMillis();\n        for (Object o : source) {\n            hashSet.add(o);\n        }\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of HashSet for 1.000.000 object insertions \" + duration);\n\n        start = System.currentTimeMillis();\n        for (Object o : source) {\n            weakConcurrentSet.add(o);\n        }\n        duration = System.currentTimeMillis() - start;\n        System.out.println(\"Performance of ConcurrentSet for 1.000.000 object insertions \" + duration);\n    }\n\n\n    @Test\n    public void testRemove2() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                    if (toRemove.contains(src))\n                        testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet setUnderTest = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            setUnderTest.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = setUnderTest.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, setUnderTest.size());\n        for(Object src : source){\n            assertFalse(setUnderTest.contains(src));\n        }\n    }\n\n\n    /**\n     * In this test HashMap will cross capacity threshold multiple times in\n     * different directions which will trigger rehashing. Because rehashing\n     * requires modification of Entry class for all hash map entries some keys\n     * may temporarily disappear from the map.\n     * <p>\n     * For more information please take a look at transfer method in HashMap.\n     *\n     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n     */\n    @Test\n    public void testConcurrentAddRemove() {\n        final IConcurrentSet set = createSet();\n        final List permanentObjects = createWithRandomIntegers(80, null);\n        final List volatileObjects = createWithRandomIntegers(10000, permanentObjects);\n        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n        final int mutatorThreshold = 1000;\n\n        // Add elements that will not be touched by the constantly running mutating thread\n        final int numItems = 8;\n        for (Object permanent : permanentObjects) {\n            set.add(permanent);\n        }\n\n        // Adds and removes items >= numItems\n        // thus forcing constant rehashing of the backing hashtable\n        Runnable updatingThread = new Runnable() {\n            public void run() {\n                Random rand = new Random();\n                for(int times = 0; times < 1000 ; times++){\n                    System.out.println(\"New mutator cycle: \" + times);\n                    HashSet elements = new HashSet(mutatorThreshold);\n\n                    for (int i = numItems; i < mutatorThreshold; i++) {\n                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n                        set.add(volatileObject);\n                        elements.add(volatileObject);\n                    }\n                    for (Object volObj : elements) {\n                        set.remove(volObj);\n                    }\n                }\n            };\n        };\n\n        Runnable lookupThread = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++) {\n                    System.out.println(\"New lookup cycle: \" + i);\n                    for (Object permanent : permanentObjects) {\n                        // permanent items are never touched,\n                        // --> set.contains(j) should always return true\n                        if(!set.contains(permanent))\n                            missing.add(permanent);\n                    }\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(updatingThread, lookupThread, lookupThread, lookupThread);\n        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n\n    }\n\n\n    public List createWithRandomIntegers(int size, List<Integer> exluding){\n        if(exluding == null) exluding = new ArrayList<Integer>();\n        List<Integer> result = new ArrayList<Integer>(size);\n        Random rand = new Random();\n        for(int i = 0; i < size;i++){\n            result.add(rand.nextInt());\n        }\n        for(Integer excluded : exluding)\n            result.remove(excluded);\n        return result;\n    }\n\n}\n","src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java":"package net.engio.mbassy.common;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\n/**\n * Run various tests concurrently. A given instance of runnable will be used to spawn and start\n * as many threads as specified by an additional parameter or (if multiple runnables have been\n * passed to the method) one thread for each runnable.\n * <p/>\n * Date: 2/14/12\n *\n * @Author bennidi\n */\npublic class ConcurrentExecutor {\n\n\n\tpublic static void runConcurrent(final Runnable unit, int numberOfConcurrentExecutions) {\n\t\tRunnable[] units = new Runnable[numberOfConcurrentExecutions];\n\t\t// create the tasks and schedule for execution\n\t\tfor (int i = 0; i < numberOfConcurrentExecutions; i++) {\n\t\t\tunits[i] = unit;\n\t\t}\n\t\trunConcurrent(units);\n\n\t}\n\n\tpublic static void runConcurrent(final Runnable... units) {\n\t\tExecutorService executor = Executors.newCachedThreadPool();\n\t\tList<Future<Long>> returnValues = new ArrayList<Future<Long>>();\n\n\t\t// create the tasks and schedule for execution\n\t\tfor (final Runnable unit : units) {\n\t\t\tCallable<Long> wrapper = new Callable<Long>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Long call() throws Exception {\n\t\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\t\tunit.run();\n\t\t\t\t\treturn System.currentTimeMillis() - start;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturnValues.add(executor.submit(wrapper));\n\t\t}\n\n\t\t// wait until all tasks have been executed\n\t\ttry {\n\t\t\texecutor.shutdown();// tells the thread pool to execute all waiting tasks\n\t\t\texecutor.awaitTermination(5, TimeUnit.MINUTES);\n\t\t} catch (InterruptedException e) {\n\t\t\t// unlikely that this will happen\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// print results\n\t\tfor (Future<Long> result : returnValues)\n\t\t\ttry {\n\t\t\t\tSystem.out.println(\"Execution of unit of work to \" + result.get() + \"ms.\");\n\t\t\t} catch (Exception e) {\n\t\t\t\t//should never happen\n\t\t\t\t// since the code waits until all tasks are processed\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t}\n\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers = new ArrayList<MessageHandlerMetadata>();\n\n    private Class<T> listenerDefinition;\n\n    private Listener listenerAnnotation;\n\n    public MessageListenerMetadata(Class<T> listenerDefinition) {\n        this.listenerDefinition = listenerDefinition;\n        Listener listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n    }\n\n\n    public boolean isFromListener(Class listener){\n        return listenerDefinition.equals(listener);\n    }\n\n    public boolean useStrongReferences(){\n        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n    }\n\n    public MessageListenerMetadata addHandlers(Collection<? extends MessageHandlerMetadata> c) {\n        handlers.addAll(c);\n        return this;\n    }\n\n    public boolean addHandler(MessageHandlerMetadata messageHandlerMetadata) {\n        return handlers.add(messageHandlerMetadata);\n    }\n\n    public List<MessageHandlerMetadata> getHandlers(){\n        return handlers;\n    }\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for (MessageHandlerMetadata handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.MessageBusException;\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    private ISyncMessageBus bus;\n\n    public SubscriptionFactory setBus(ISyncMessageBus bus) {\n        this.bus = bus;\n        return this;\n    }\n\n    public Subscription createSubscription(MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n        try {\n            SubscriptionContext context = new SubscriptionContext(bus, handlerMetadata);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, context.getHandlerMetadata().useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws Exception {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n        return constructor.newInstance(context);\n    }\n}\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":"package net.engio.mbassy;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.common.ConcurrentExecutor;\nimport net.engio.mbassy.common.IConcurrentSet;\nimport net.engio.mbassy.common.UnitTest;\nimport org.junit.Test;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * This test ensures the correct behaviour of the set implementation that is the building\n * block of the subscription implementations used by the Mbassador message bus.\n * <p/>\n * It should behave exactly like other set implementations do and as such all tests are based\n * on comparing the outcome of sequence of operations applied to a standard set implementation\n * and the concurrent set.\n *\n * @author bennidi\n *         Date: 11/12/12\n */\npublic abstract class ConcurrentSetTest extends UnitTest {\n\n    // Shared state\n    protected final int numberOfElements = 100000;\n    protected final int numberOfThreads = 50;\n    \n    \n    protected abstract IConcurrentSet createSet();\n\n\n    @Test\n    public void testUniqueness() {\n        final LinkedList<Object> duplicates = new LinkedList<Object>();\n        final HashSet<Object> distinct = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        Random rand = new Random();\n\n        // build set of distinct objects and list of duplicates\n        Object candidate = new Object();\n        for (int i = 0; i < numberOfElements; i++) {\n            if (rand.nextInt() % 3 == 0) {\n                candidate = new Object();\n            }\n            duplicates.add(candidate);\n            distinct.add(candidate);\n        }\n\n        // insert all elements (containing duplicates) into the set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : duplicates) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // check that the control set and the test set contain the exact same elements\n        assertEquals(distinct.size(), testSetWeak.size());\n        for (Object uniqueObject : distinct) {\n            assertTrue(testSetWeak.contains(uniqueObject));\n        }\n    }\n\n\n    @Test\n    public void testRandomRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of distinct objects and mark a subset of those for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build the test set from the set of candidates\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // remove all candidates that have previously been marked for removal from the test set\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : toRemove) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalOfHead() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final HashSet<Object> toRemove = new HashSet<Object>();\n\n        final IConcurrentSet testSetWeak = createSet();\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            if (i % 3 == 0) {\n                toRemove.add(candidate);\n            }\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.add(src);\n                    if (toRemove.contains(src))\n                        testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n        // ensure that the test set does not contain any of the elements that have been removed from it\n        for (Object tar : testSetWeak) {\n            Assert.assertTrue(!toRemove.contains(tar));\n        }\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(source.size() - toRemove.size(), testSetWeak.size());\n        for (Object src : source) {\n            if (!toRemove.contains(src)) assertTrue(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testCompleteRemoval() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet testSetWeak = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            testSetWeak.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                for (Object src : source) {\n                    testSetWeak.remove(src);\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, testSetWeak.size());\n        for(Object src : source){\n            assertFalse(testSetWeak.contains(src));\n        }\n    }\n\n    @Test\n    public void testRemovalViaIterator() {\n        final HashSet<Object> source = new HashSet<Object>();\n        final IConcurrentSet setUnderTest = createSet();\n\n        // build set of candidates and mark subset for removal\n        for (int i = 0; i < numberOfElements; i++) {\n            Object candidate = new Object();\n            source.add(candidate);\n            setUnderTest.add(candidate);\n        }\n\n        // build test set by adding the candidates\n        // and subsequently removing those marked for removal\n        ConcurrentExecutor.runConcurrent(new Runnable() {\n            @Override\n            public void run() {\n                Iterator<Object> iterator = setUnderTest.iterator();\n                while(iterator.hasNext()){\n                    iterator.remove();\n                }\n            }\n        }, numberOfThreads);\n\n\n        // ensure that the test set still contains all objects from the source set that have not been marked\n        // for removal\n        assertEquals(0, setUnderTest.size());\n        for(Object src : source){\n            assertFalse(setUnderTest.contains(src));\n        }\n    }\n\n\n    /**\n     * In this test HashMap will cross capacity threshold multiple times in\n     * different directions which will trigger rehashing. Because rehashing\n     * requires modification of Entry class for all hash map entries some keys\n     * may temporarily disappear from the map.\n     * <p>\n     * For more information please take a look at transfer method in HashMap.\n     *\n     * Thanks to Ivan Koblik (http://koblik.blogspot.com) for contributing initial code and idea\n     */\n    @Test\n    public void testConcurrentAddRemove() {\n        final IConcurrentSet testSet = createSet();\n        // a set of unique integers that will stay permanently in the test set\n        final List permanentObjects = new ArrayList();\n        // a set of objects that will be added and removed at random to the test set to force rehashing\n        final List volatileObjects = new ArrayList();\n        permanentObjects.addAll(createWithRandomIntegers(80, null));\n        volatileObjects.addAll(createWithRandomIntegers(10000, permanentObjects));\n        final CopyOnWriteArraySet missing = new CopyOnWriteArraySet();\n        final int mutatorThreshold = 1000;\n\n        // Add elements that will not be touched by the constantly running mutating thread\n        for (Object permanent : permanentObjects) {\n            testSet.add(permanent);\n        }\n\n        // Adds and removes items\n        // thus forcing constant rehashing of the backing hashtable\n        Runnable updatingThread = new Runnable() {\n            public void run() {\n                Random rand = new Random();\n                for(int times = 0; times < 1000 ; times++){\n                    HashSet elements = new HashSet(mutatorThreshold);\n\n                    for (int i = 0; i < mutatorThreshold; i++) {\n                        Object volatileObject = volatileObjects.get(Math.abs(rand.nextInt()) % volatileObjects.size());\n                        testSet.add(volatileObject);\n                        elements.add(volatileObject);\n                    }\n                    for (Object volObj : elements) {\n                        testSet.remove(volObj);\n                    }\n                }\n            };\n        };\n\n        Runnable lookupThread = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++) {\n                    for (Object permanent : permanentObjects) {\n                        // permanent items are never touched,\n                        // --> set.contains(j) should always return true\n                        if(!testSet.contains(permanent))\n                            missing.add(permanent);\n                    }\n                }\n            }\n        };\n\n        ConcurrentExecutor.runConcurrent(updatingThread, lookupThread, lookupThread, lookupThread);\n        assertTrue(\"There where items temporarily unavailable: \" + missing.size(), missing.size() == 0);\n\n    }\n\n\n    public Set createWithRandomIntegers(int size, List<Integer> excluding){\n        if(excluding == null) excluding = new ArrayList<Integer>();\n        Set<Integer> result = new HashSet<Integer>(size);\n        Random rand = new Random();\n        while(result.size() < size){\n            result.add(rand.nextInt());\n        }\n        for(Integer excluded : excluding)\n            result.remove(excluded);\n        return result;\n    }\n\n}\n","src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java":"package net.engio.mbassy.common;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\n/**\n * Run various tests concurrently. A given instance of runnable will be used to spawn and start\n * as many threads as specified by an additional parameter or (if multiple runnables have been\n * passed to the method) one thread for each runnable.\n * <p/>\n * Date: 2/14/12\n *\n * @Author bennidi\n */\npublic class ConcurrentExecutor {\n\n\n\tpublic static void runConcurrent(final Runnable unit, int numberOfConcurrentExecutions) {\n\t\tRunnable[] units = new Runnable[numberOfConcurrentExecutions];\n\t\t// create the tasks and schedule for execution\n\t\tfor (int i = 0; i < numberOfConcurrentExecutions; i++) {\n\t\t\tunits[i] = unit;\n\t\t}\n\t\trunConcurrent(units);\n\n\t}\n\n\tpublic static void runConcurrent(final Runnable... units) {\n\t\tExecutorService executor = Executors.newCachedThreadPool();\n\t\tList<Future<Long>> returnValues = new ArrayList<Future<Long>>();\n\n\t\t// create the tasks and schedule for execution\n\t\tfor (final Runnable unit : units) {\n\t\t\tCallable<Long> wrapper = new Callable<Long>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Long call() throws Exception {\n\t\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\t\tunit.run();\n\t\t\t\t\treturn System.currentTimeMillis() - start;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturnValues.add(executor.submit(wrapper));\n\t\t}\n\n\t\t// wait until all tasks have been executed\n\t\ttry {\n\t\t\texecutor.shutdown();// tells the thread pool to execute all waiting tasks\n\t\t\texecutor.awaitTermination(5, TimeUnit.MINUTES);\n\t\t} catch (InterruptedException e) {\n\t\t\t// unlikely that this will happen\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":"package net.engio.mbassy.listener;\n\nimport net.engio.mbassy.common.IPredicate;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Provides information about the message listeners of a specific class. Each message handler\n * defined by the target class is represented as a single entity.\n *\n * @author bennidi\n *         Date: 12/16/12\n */\npublic class MessageListenerMetadata<T> {\n\n\n    public static IPredicate<MessageHandlerMetadata> ForMessage(final Class<?> messageType) {\n        return new IPredicate<MessageHandlerMetadata>() {\n            @Override\n            public boolean apply(MessageHandlerMetadata target) {\n                return target.handlesMessage(messageType);\n            }\n        };\n    }\n\n    private List<MessageHandlerMetadata> handlers = new ArrayList<MessageHandlerMetadata>();\n\n    private Class<T> listenerDefinition;\n\n    private Listener listenerAnnotation;\n\n    public MessageListenerMetadata(Class<T> listenerDefinition) {\n       this.listenerDefinition = listenerDefinition;\n       listenerAnnotation = listenerDefinition.getAnnotation(Listener.class);\n    }\n\n\n    public boolean isFromListener(Class listener){\n        return listenerDefinition.equals(listener);\n    }\n\n    public boolean useStrongReferences(){\n        return listenerAnnotation != null && listenerAnnotation.references().equals(References.Strong);\n    }\n\n    public MessageListenerMetadata addHandlers(Collection<? extends MessageHandlerMetadata> c) {\n        handlers.addAll(c);\n        return this;\n    }\n\n    public boolean addHandler(MessageHandlerMetadata messageHandlerMetadata) {\n        return handlers.add(messageHandlerMetadata);\n    }\n\n    public List<MessageHandlerMetadata> getHandlers(){\n        return handlers;\n    }\n\n    public List<MessageHandlerMetadata> getHandlers(IPredicate<MessageHandlerMetadata> filter) {\n        List<MessageHandlerMetadata> matching = new LinkedList<MessageHandlerMetadata>();\n        for (MessageHandlerMetadata handler : handlers) {\n            if (filter.apply(handler)) {\n                matching.add(handler);\n            }\n        }\n        return matching;\n    }\n\n    public boolean handles(Class<?> messageType) {\n        return !getHandlers(ForMessage(messageType)).isEmpty();\n    }\n\n    public Class<T> getListerDefinition() {\n        return listenerDefinition;\n    }\n}\n","src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":"package net.engio.mbassy.subscription;\n\nimport net.engio.mbassy.MessageBusException;\nimport net.engio.mbassy.bus.ISyncMessageBus;\nimport net.engio.mbassy.common.StrongConcurrentSet;\nimport net.engio.mbassy.common.WeakConcurrentSet;\nimport net.engio.mbassy.dispatch.*;\nimport net.engio.mbassy.listener.MessageHandlerMetadata;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\n\n/**\n * The subscription factory is used to create an empty subscription for specific message handler.\n * The message handler's configuration is evaluated and a corresponding subscription is built.\n */\npublic class SubscriptionFactory {\n\n    private ISyncMessageBus bus;\n\n    public SubscriptionFactory setBus(ISyncMessageBus bus) {\n        this.bus = bus;\n        return this;\n    }\n\n    public Subscription createSubscription(MessageHandlerMetadata handlerMetadata) throws MessageBusException{\n        try {\n            SubscriptionContext context = new SubscriptionContext(bus, handlerMetadata);\n            IHandlerInvocation invocation = buildInvocationForHandler(context);\n            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);\n            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()\n                ? new StrongConcurrentSet<Object>()\n                : new WeakConcurrentSet<Object>());\n        } catch (Exception e) {\n            throw new MessageBusException(e);\n        }\n    }\n\n    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {\n        IHandlerInvocation invocation = createBaseHandlerInvocation(context);\n        if(context.getHandlerMetadata().isSynchronized()){\n            invocation = new SynchronizedHandlerInvocation(invocation);\n        }\n        if (context.getHandlerMetadata().isAsynchronous()) {\n            invocation = new AsynchronousHandlerInvocation(invocation);\n        }\n        return invocation;\n    }\n\n    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {\n        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);\n        if (context.getHandlerMetadata().isEnveloped()) {\n            dispatcher = new EnvelopedMessageDispatcher(dispatcher);\n        }\n        if (context.getHandlerMetadata().isFiltered()) {\n            dispatcher = new FilteredMessageDispatcher(dispatcher);\n        }\n        return dispatcher;\n    }\n\n    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws Exception {\n        Class<? extends HandlerInvocation> invocation = context.getHandlerMetadata().getHandlerInvocation();\n        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){\n            throw new MessageBusException(\"The handler invocation must be top level class or nested STATIC inner class\");\n        }\n        Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);\n        return constructor.newInstance(context);\n    }\n}\n"},"preChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[316,316],[317,317],[318,318],[320,321],[323,323],[262,262],[263,263],[264,264],[269,269],[271,271],[280,280],[283,283],[285,285],[289,289],[299,299],[303,303]],"src/test/java/net/engio/mbassy/common/ConcurrentExecutor.java":[[56,63]],"src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":[[37,37]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[31,31]]},"postChangeRange":{"src/test/java/net/engio/mbassy/ConcurrentSetTest.java":[[289,289],[290,290],[291,291],[293,294],[296,296],[234,234],[236,236],[238,238],[239,239],[240,240],[246,246],[257,257],[259,259],[263,263],[276,276]],"src/main/java/net/engio/mbassy/listener/MessageListenerMetadata.java":[[37,37]],"src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java":[[31,31]]},"microChanges":[],"refactorings":[{"type":"\"Rename Parameter\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":317,"endLine":317},{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":317,"endLine":317}],"rightSideLocations":[]},{"type":"\"Rename Variable\"","leftSideLocations":[{"path":"src/test/java/net/engio/mbassy/ConcurrentSetTest.java","startLine":303,"endLine":303}],"rightSideLocations":[]}]},{"repository":"mbassador","sha1":"7c0c0b6f825d98793525595a7be5ed43f6b99e43","url":"https://github.com/bennidi/mbassador/commit/7c0c0b6f825d98793525595a7be5ed43f6b99e43","preChangeSourceCode":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            Assert.fail();\n        }\n    };\n\n\n    private StrongConcurrentSet<MessagePublication> issuedPublications = new StrongConcurrentSet<MessagePublication>();\n\n    @Before\n    public void setUp(){\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public MBassador getBus(BusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n    public MBassador getBus(BusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(MessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(MessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n * defines such a message listener.\r\n *\r\n * @author bennidi\r\n *         Date: 11/14/12\r\n */\r\npublic class MessageHandler {\r\n\r\n    public static final class Properties{\r\n\r\n        public static final String HandlerMethod = \"handler\";\r\n        public static final String InvocationMode = \"invocationMode\";\r\n        public static final String Filter = \"filter\";\r\n        public static final String Condition = \"condition\";\r\n        public static final String Enveloped = \"envelope\";\r\n        public static final String HandledMessages = \"messages\";\r\n        public static final String IsSynchronized = \"synchronized\";\r\n        public static final String Listener = \"listener\";\r\n        public static final String AcceptSubtypes = \"subtypes\";\r\n        public static final String Priority = \"priority\";\r\n        public static final String Invocation = \"invocation\";\r\n\r\n        /**\r\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n         *\r\n         * @param handler  The handler annotated method of the listener\r\n         * @param handlerConfig The annotation that configures the handler\r\n         * @param filter   The set of preconfigured filters if any\r\n         * @param listenerConfig The listener metadata\r\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n         */\r\n        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n            if(handler == null){\r\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n            }\r\n            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\r\n            Class[] handledMessages = enveloped != null\r\n                    ? enveloped.messages()\r\n                    : handler.getParameterTypes();\r\n            handler.setAccessible(true);\r\n            Map<String, Object> properties = new HashMap<String, Object>();\r\n            properties.put(HandlerMethod, handler);\r\n            properties.put(Filter, filter != null ? filter : new IMessageFilter[]{});\r\n            properties.put(Condition, handlerConfig.condition());\r\n            properties.put(Priority, handlerConfig.priority());\r\n            properties.put(Invocation, handlerConfig.invocation());\r\n            properties.put(InvocationMode, handlerConfig.delivery());\r\n            properties.put(Enveloped, enveloped != null);\r\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n            properties.put(Listener, listenerConfig);\r\n            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\r\n            properties.put(HandledMessages, handledMessages);\r\n            return properties;\r\n        }\r\n    }\r\n\r\n\r\n    private final Method handler;\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n\tprivate String condition;\r\n    \r\n    private final int priority;\r\n\r\n    private final Class<? extends HandlerInvocation> invocation;\r\n\r\n    private final Invoke invocationMode;\r\n\r\n    private final boolean isEnvelope;\r\n\r\n    private final Class[] handledMessages;\r\n\r\n    private final boolean acceptsSubtypes;\r\n\r\n    private final MessageListener listenerConfig;\r\n\r\n    private final boolean isSynchronized;\r\n\r\n\r\n    public MessageHandler(Map<String, Object> properties){\r\n        super();\r\n        validate(properties);\r\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n        this.condition = (String)properties.get(Properties.Condition);\r\n        this.priority = (Integer)properties.get(Properties.Priority);\r\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n    }\r\n\r\n    private void validate(Map<String, Object> properties){\r\n        Object[][] expectedProperties = new Object[][]{\r\n                new Object[]{Properties.HandlerMethod, Method.class },\r\n                new Object[]{Properties.Priority, Integer.class },\r\n                new Object[]{Properties.Invocation, Class.class },\r\n                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n                new Object[]{Properties.Condition, String.class },\r\n                new Object[]{Properties.Enveloped, Boolean.class },\r\n                new Object[]{Properties.HandledMessages, Class[].class },\r\n                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n                new Object[]{Properties.Listener, MessageListener.class },\r\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n        };\r\n        for(Object[] property : expectedProperties){\r\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                        + \" but was: \" + properties.get(property[0]));\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public boolean isSynchronized(){\r\n        return isSynchronized;\r\n    }\r\n\r\n    public boolean useStrongReferences(){\r\n        return listenerConfig.useStrongReferences();\r\n    }\r\n\r\n    public boolean isFromListener(Class listener){\r\n        return listenerConfig.isFromListener(listener);\r\n    }\r\n\r\n    public boolean isAsynchronous() {\r\n        return invocationMode.equals(Invoke.Asynchronously);\r\n    }\r\n\r\n    public boolean isFiltered() {\r\n        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n    }\r\n\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    public Method getHandler() {\r\n        return handler;\r\n    }\r\n\r\n    public IMessageFilter[] getFilter() {\r\n        return filter;\r\n    }\r\n    \r\n    public String getCondition() {\r\n    \treturn this.condition;\r\n    }\r\n\r\n    public Class[] getHandledMessages() {\r\n        return handledMessages;\r\n    }\r\n\r\n    public boolean isEnveloped() {\r\n        return isEnvelope;\r\n    }\r\n\r\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n        return invocation;\r\n    }\r\n\r\n    public boolean handlesMessage(Class<?> messageType) {\r\n        for (Class<?> handledMessage : handledMessages) {\r\n            if (handledMessage.equals(messageType)) {\r\n                return true;\r\n            }\r\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean acceptsSubtypes() {\r\n        return acceptsSubtypes;\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\r\n\r\nimport net.engio.mbassy.bus.MessagePublication;\r\nimport net.engio.mbassy.dispatch.el.ElFilter;\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\n\r\n/**\r\n * A dispatcher that implements message filtering based on the filter configuration\r\n * of the associated message handler. It will delegate message delivery to another\r\n * message dispatcher after having performed the filtering logic.\r\n *\r\n * @author bennidi\r\n *         Date: 11/23/12\r\n */\r\npublic class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\r\n        super(dispatcher);\r\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\r\n    }\r\n\r\n    private boolean passesFilter(Object message) {\r\n\r\n        if (filter == null) {\r\n            return true;\r\n        } else {\r\n            for (IMessageFilter aFilter : filter) {\r\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\r\n        if (passesFilter(message) && passesELFilter(message)) {\r\n            getDelegate().dispatch(publication, message, listeners);\r\n        }\r\n    }\r\n\r\n\t/*************************************************************************\r\n\t * This will test the EL expression defined on the Handler annotation.\r\n\t * This is like a \"parameterizable\" filter.\r\n\t * @param me the message object to filter with the EL expression if there is one.\r\n\t * @return true if the event is allowed, false if it is rejected.\r\n\t ************************************************************************/\r\n        \r\n\tprivate boolean passesELFilter(Object message) {\r\n\t\tElFilter filter = ElFilter.getInstance();\r\n\t\treturn filter != null && filter.accepts(message, getContext().getHandlerMetadata());\r\n\t}\r\n}\r\n","src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":"package net.engio.mbassy.dispatch.el;\r\n\r\nimport javax.el.ExpressionFactory;\r\nimport javax.el.ValueExpression;\r\n\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\nimport net.engio.mbassy.listener.MessageHandler;\r\n\r\n/*****************************************************************************\r\n * A filter that will use a expression from the handler annotation and \r\n * parse it as EL.\r\n ****************************************************************************/\r\n\r\npublic class ElFilter implements IMessageFilter {\r\n\r\n\tprivate static ElFilter instance;\r\n\t\r\n\tstatic {\r\n\t\ttry {\r\n\t\t\tinstance = new ElFilter();\r\n\t\t} catch (Exception e) {\r\n\t\t\t// Most likely the javax.el package is not available.\r\n\t\t\tinstance = null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate ExpressionFactory elFactory;\r\n\t\r\n\t/*************************************************************************\r\n\t * Constructor\r\n\t ************************************************************************/\r\n\t\r\n\tprivate ElFilter() {\r\n\t\tsuper();\r\n\t\tinitELFactory();\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * Get an implementation of the ExpressionFactory. This uses the \r\n\t * Java service lookup mechanism to find a proper implementation.\r\n\t * If none if available we do not support EL filters.\r\n\t ************************************************************************/\r\n\r\n\tprivate void initELFactory() {\r\n\t\ttry {\r\n\t\t\tthis.elFactory = ExpressionFactory.newInstance();\r\n\t\t} catch (RuntimeException e) {\r\n\t\t\t// No EL implementation on the class path.\r\n\t\t\telFactory = null;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * accepts\r\n\t * @see net.engio.mbassy.listener.IMessageFilter#accepts(java.lang.Object, net.engio.mbassy.listener.MessageHandler)\r\n\t ************************************************************************/\r\n\t@Override\r\n\tpublic boolean accepts(Object message, MessageHandler metadata) {\r\n\t\tString expression = metadata.getCondition();\r\n\t\tif (expression == null || expression.trim().length() == 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (elFactory == null) {\r\n\t\t\t// TODO should we test this some where earlier? Perhaps in MessageHandler.validate()  ?\r\n\t\t\tthrow new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n\t\t}\r\n\t\t\r\n\t\texpression = cleanupExpression(expression);\r\n\t\t\r\n\t\tEventContext context = new EventContext();\r\n\t\tcontext.bindToEvent(message);\r\n\t\t\r\n\t\treturn evalExpression(expression, context);\r\n\t}\r\n\r\n\t/*************************************************************************\r\n\t * @param expression\r\n\t * @param context\r\n\t * @return\r\n\t ************************************************************************/\r\n\t\r\n\tprivate boolean evalExpression(String expression, EventContext context) {\r\n\t\tValueExpression ve = elFactory.createValueExpression(context, expression, Boolean.class);\r\n\t\tObject result = ve.getValue(context);\r\n\t\tif (!(result instanceof Boolean)) {\r\n\t\t\tthrow new IllegalStateException(\"A handler uses an EL filter but the output is not \\\"true\\\" or \\\"false\\\".\");\r\n\t\t}\r\n\t\treturn (Boolean)result;\r\n\t}\r\n\r\n\t/*************************************************************************\r\n\t * Make it a valid expression because the parser expects it like this.\r\n\t * @param expression\r\n\t * @return\r\n\t ************************************************************************/\r\n\t\r\n\tprivate String cleanupExpression(String expression) {\r\n\t\t \r\n\t\tif (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n\t\t\texpression = \"${\"+expression+\"}\";\r\n\t\t}\r\n\t\treturn expression;\r\n\t}\r\n\r\n\t/*************************************************************************\r\n\t * @return the one and only\r\n\t ************************************************************************/\r\n\t\r\n\tpublic static synchronized ElFilter getInstance() {\r\n\t\treturn instance;\r\n\t}\r\n\r\n}\r\n","src/test/java/net/engio/mbassy/ConditionTest.java":"package net.engio.mbassy;\r\n\r\nimport net.engio.mbassy.bus.MBassador;\r\nimport net.engio.mbassy.bus.config.BusConfiguration;\r\nimport net.engio.mbassy.common.MessageBusTest;\r\nimport net.engio.mbassy.listener.Handler;\r\n\r\nimport org.junit.Test;\r\n\r\n/*****************************************************************************\r\n * Some unit tests for the \"condition\" filter.\r\n ****************************************************************************/\r\n\r\npublic class ConditionTest extends MessageBusTest {\r\n\r\n\tpublic static class TestEvent {\r\n\r\n\t\tpublic Object result;\r\n\t\tprivate String type;\r\n\t\tprivate int size;\r\n\r\n\t\tpublic TestEvent(String type, int size) {\r\n\t\t\tsuper();\r\n\t\t\tthis.type = type;\r\n\t\t\tthis.size = size;\r\n\t\t}\r\n\t\t\r\n\t\tpublic String getType() {\r\n\t\t\treturn type;\r\n\t\t}\r\n\r\n\t\tpublic int getSize() {\r\n\t\t\treturn size;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tpublic static class ConditionalMessageListener {\r\n\r\n\t\t@Handler(condition = \"msg.type == 'TEST'\")\r\n\t\tpublic void handleTypeMessage(TestEvent message) {\r\n\t\t\tmessage.result = \"handleTypeMessage\";\r\n\t\t}\r\n\r\n\t\t@Handler(condition = \"msg.size > 4\")\r\n\t\tpublic void handleSizeMessage(TestEvent message) {\r\n\t\t\tmessage.result = \"handleSizeMessage\";\r\n\t\t}\r\n\t\t\r\n\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\r\n\t\tpublic void handleCombinedEL(TestEvent message) {\r\n\t\t\tmessage.result = \"handleCombinedEL\";\r\n\t\t}\r\n\t\t\r\n\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\r\n\t\tpublic void handleMethodAccessEL(TestEvent message) {\r\n\t\t\tmessage.result = \"handleMethodAccessEL\";\r\n\t\t}\r\n\r\n\t\t\r\n\t}\r\n\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testSimpleStringCondition() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"TEST\", 0);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertEquals(\"handleTypeMessage\", message.result);\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testSimpleNumberCondition() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"\", 5);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertEquals(\"handleSizeMessage\", message.result);\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testHandleCombinedEL() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"\", 3);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertEquals(\"handleCombinedEL\", message.result);\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testNotMatchingAnyCondition() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"\", 0);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertTrue(message.result == null);\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testHandleMethodAccessEL() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertEquals(\"handleMethodAccessEL\", message.result);\r\n\t}\r\n\r\n}\r\n"},"postChangeSourceCode":{"src/test/java/net/engio/mbassy/common/MessageBusTest.java":"package net.engio.mbassy.common;\n\nimport junit.framework.Assert;\nimport net.engio.mbassy.bus.MBassador;\nimport net.engio.mbassy.bus.MessagePublication;\nimport net.engio.mbassy.bus.config.BusConfiguration;\nimport net.engio.mbassy.bus.error.IPublicationErrorHandler;\nimport net.engio.mbassy.bus.error.PublicationError;\nimport net.engio.mbassy.messages.MessageTypes;\nimport org.junit.Before;\n\n/**\n * A base test that provides a factory for message bus that makes tests fail if any\n * publication error occurs\n *\n * @author bennidi\n *         Date: 3/2/13\n */\npublic abstract class MessageBusTest extends AssertSupport {\n\n    // this value probably needs to be adjusted depending on the performance of the underlying plattform\n    // otherwise the tests will fail since asynchronous processing might not have finished when\n    // evaluation is run\n    protected static final int processingTimeInMS = 6000;\n    protected static final int InstancesPerListener = 5000;\n    protected static final int ConcurrentUnits = 10;\n    protected static final int IterationsPerThread = 100;\n\n    protected static final IPublicationErrorHandler TestFailingHandler = new IPublicationErrorHandler() {\n        @Override\n        public void handleError(PublicationError error) {\n            error.getCause().printStackTrace();\n            Assert.fail();\n        }\n    };\n\n\n    private StrongConcurrentSet<MessagePublication> issuedPublications = new StrongConcurrentSet<MessagePublication>();\n\n    @Before\n    public void setUp(){\n        for(MessageTypes mes : MessageTypes.values())\n            mes.reset();\n    }\n\n    public MBassador getBus(BusConfiguration configuration) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        return bus;\n    }\n\n    public MBassador getBus(BusConfiguration configuration, ListenerFactory listeners) {\n        MBassador bus = new MBassador(configuration);\n        bus.addErrorHandler(TestFailingHandler);\n        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);\n        return bus;\n    }\n\n    public void waitForPublications(long timeOutInMs){\n        long start = System.currentTimeMillis();\n        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){\n            for(MessagePublication pub : issuedPublications){\n                if(pub.isFinished())\n                    issuedPublications.remove(pub);\n            }\n        }\n        if(issuedPublications.size() > 0)\n            fail(\"Issued publications did not finish within specified timeout of \" + timeOutInMs + \" ms\");\n    }\n\n    public void addPublication(MessagePublication publication){\n        issuedPublications.add(publication);\n    }\n\n}\n","src/main/java/net/engio/mbassy/listener/MessageHandler.java":"package net.engio.mbassy.listener;\r\n\r\nimport net.engio.mbassy.dispatch.HandlerInvocation;\r\nimport net.engio.mbassy.dispatch.el.ElFilter;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Any method in any class annotated with the @Handler annotation represents a message handler. The class that contains\r\n * the handler is called a  message listener and more generally, any class containing a message handler in its class hierarchy\r\n * defines such a message listener.\r\n *\r\n * @author bennidi\r\n *         Date: 11/14/12\r\n */\r\npublic class MessageHandler {\r\n\r\n    public static final class Properties{\r\n\r\n        public static final String HandlerMethod = \"handler\";\r\n        public static final String InvocationMode = \"invocationMode\";\r\n        public static final String Filter = \"filter\";\r\n        public static final String Condition = \"condition\";\r\n        public static final String Enveloped = \"envelope\";\r\n        public static final String HandledMessages = \"messages\";\r\n        public static final String IsSynchronized = \"synchronized\";\r\n        public static final String Listener = \"listener\";\r\n        public static final String AcceptSubtypes = \"subtypes\";\r\n        public static final String Priority = \"priority\";\r\n        public static final String Invocation = \"invocation\";\r\n\r\n        /**\r\n         * Create the property map for the {@link MessageHandler} constructor using the default objects.\r\n         *\r\n         * @param handler  The handler annotated method of the listener\r\n         * @param handlerConfig The annotation that configures the handler\r\n         * @param filter   The set of preconfigured filters if any\r\n         * @param listenerConfig The listener metadata\r\n         * @return  A map of properties initialized from the given parameters that will conform to the requirements of the\r\n         *         {@link MessageHandler} constructor. See {@see MessageHandler.validate()} for more details.\r\n         */\r\n        public static final Map<String, Object> Create(Method handler, Handler handlerConfig, IMessageFilter[] filter, MessageListener listenerConfig){\r\n            if(handler == null){\r\n                throw new IllegalArgumentException(\"The message handler configuration may not be null\");\r\n            }\r\n            if(filter == null){\r\n                filter = new IMessageFilter[]{};\r\n            }\r\n            net.engio.mbassy.listener.Enveloped enveloped = handler.getAnnotation(Enveloped.class);\r\n            Class[] handledMessages = enveloped != null\r\n                    ? enveloped.messages()\r\n                    : handler.getParameterTypes();\r\n            handler.setAccessible(true);\r\n            Map<String, Object> properties = new HashMap<String, Object>();\r\n            properties.put(HandlerMethod, handler);\r\n            // add EL filter if a condition is present\r\n            if(handlerConfig.condition() != null){\r\n                if (!ElFilter.isELAvailable()) {\r\n                    throw new IllegalStateException(\"A handler uses an EL filter but no EL implementation is available.\");\r\n                }\r\n\r\n                IMessageFilter[] expandedFilter = new IMessageFilter[filter.length + 1];\r\n                for(int i = 0; i < filter.length ; i++){\r\n                   expandedFilter[i] = filter[i];\r\n                }\r\n                expandedFilter[filter.length] = new ElFilter();\r\n                filter = expandedFilter;\r\n            }\r\n            properties.put(Filter, filter);\r\n            properties.put(Condition, cleanEL(handlerConfig.condition()));\r\n            properties.put(Priority, handlerConfig.priority());\r\n            properties.put(Invocation, handlerConfig.invocation());\r\n            properties.put(InvocationMode, handlerConfig.delivery());\r\n            properties.put(Enveloped, enveloped != null);\r\n            properties.put(AcceptSubtypes, !handlerConfig.rejectSubtypes());\r\n            properties.put(Listener, listenerConfig);\r\n            properties.put(IsSynchronized, handler.getAnnotation(Synchronized.class) != null);\r\n            properties.put(HandledMessages, handledMessages);\r\n            return properties;\r\n        }\r\n\r\n        private static String cleanEL(String expression) {\r\n\r\n            if (!expression.trim().startsWith(\"${\") && !expression.trim().startsWith(\"#{\")) {\r\n                expression = \"${\"+expression+\"}\";\r\n            }\r\n            return expression;\r\n        }\r\n    }\r\n\r\n\r\n    private final Method handler;\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n\tprivate String condition;\r\n    \r\n    private final int priority;\r\n\r\n    private final Class<? extends HandlerInvocation> invocation;\r\n\r\n    private final Invoke invocationMode;\r\n\r\n    private final boolean isEnvelope;\r\n\r\n    private final Class[] handledMessages;\r\n\r\n    private final boolean acceptsSubtypes;\r\n\r\n    private final MessageListener listenerConfig;\r\n\r\n    private final boolean isSynchronized;\r\n\r\n\r\n    public MessageHandler(Map<String, Object> properties){\r\n        super();\r\n        validate(properties);\r\n        this.handler = (Method)properties.get(Properties.HandlerMethod);\r\n        this.filter = (IMessageFilter[])properties.get(Properties.Filter);\r\n        this.condition = (String)properties.get(Properties.Condition);\r\n        this.priority = (Integer)properties.get(Properties.Priority);\r\n        this.invocation = (Class<? extends HandlerInvocation>)properties.get(Properties.Invocation);\r\n        this.invocationMode = (Invoke)properties.get(Properties.InvocationMode);\r\n        this.isEnvelope = (Boolean)properties.get(Properties.Enveloped);\r\n        this.acceptsSubtypes = (Boolean)properties.get(Properties.AcceptSubtypes);\r\n        this.listenerConfig = (MessageListener)properties.get(Properties.Listener);\r\n        this.isSynchronized = (Boolean)properties.get(Properties.IsSynchronized);\r\n        this.handledMessages = (Class[])properties.get(Properties.HandledMessages);\r\n    }\r\n\r\n    private void validate(Map<String, Object> properties){\r\n        Object[][] expectedProperties = new Object[][]{\r\n                new Object[]{Properties.HandlerMethod, Method.class },\r\n                new Object[]{Properties.Priority, Integer.class },\r\n                new Object[]{Properties.Invocation, Class.class },\r\n                new Object[]{Properties.Filter, IMessageFilter[].class },\r\n                new Object[]{Properties.Condition, String.class },\r\n                new Object[]{Properties.Enveloped, Boolean.class },\r\n                new Object[]{Properties.HandledMessages, Class[].class },\r\n                new Object[]{Properties.IsSynchronized, Boolean.class },\r\n                new Object[]{Properties.Listener, MessageListener.class },\r\n                new Object[]{Properties.AcceptSubtypes, Boolean.class }\r\n        };\r\n        for(Object[] property : expectedProperties){\r\n            if (properties.get(property[0]) == null || !((Class)property[1]).isAssignableFrom(properties.get(property[0]).getClass()))\r\n                throw new IllegalArgumentException(\"Property \" + property[0] + \" was expected to be not null and of type \" + property[1]\r\n                        + \" but was: \" + properties.get(property[0]));\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public boolean isSynchronized(){\r\n        return isSynchronized;\r\n    }\r\n\r\n    public boolean useStrongReferences(){\r\n        return listenerConfig.useStrongReferences();\r\n    }\r\n\r\n    public boolean isFromListener(Class listener){\r\n        return listenerConfig.isFromListener(listener);\r\n    }\r\n\r\n    public boolean isAsynchronous() {\r\n        return invocationMode.equals(Invoke.Asynchronously);\r\n    }\r\n\r\n    public boolean isFiltered() {\r\n        return filter.length > 0 || (condition != null && condition.trim().length() > 0);\r\n    }\r\n\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    public Method getHandler() {\r\n        return handler;\r\n    }\r\n\r\n    public IMessageFilter[] getFilter() {\r\n        return filter;\r\n    }\r\n    \r\n    public String getCondition() {\r\n    \treturn this.condition;\r\n    }\r\n\r\n    public Class[] getHandledMessages() {\r\n        return handledMessages;\r\n    }\r\n\r\n    public boolean isEnveloped() {\r\n        return isEnvelope;\r\n    }\r\n\r\n    public Class<? extends HandlerInvocation> getHandlerInvocation(){\r\n        return invocation;\r\n    }\r\n\r\n    public boolean handlesMessage(Class<?> messageType) {\r\n        for (Class<?> handledMessage : handledMessages) {\r\n            if (handledMessage.equals(messageType)) {\r\n                return true;\r\n            }\r\n            if (handledMessage.isAssignableFrom(messageType) && acceptsSubtypes()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean acceptsSubtypes() {\r\n        return acceptsSubtypes;\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":"package net.engio.mbassy.dispatch;\r\n\r\nimport net.engio.mbassy.bus.MessagePublication;\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\n\r\n/**\r\n * A dispatcher that implements message filtering based on the filter configuration\r\n * of the associated message handler. It will delegate message delivery to another\r\n * message dispatcher after having performed the filtering logic.\r\n *\r\n * @author bennidi\r\n *         Date: 11/23/12\r\n */\r\npublic final class FilteredMessageDispatcher extends DelegatingMessageDispatcher {\r\n\r\n    private final IMessageFilter[] filter;\r\n\r\n    public FilteredMessageDispatcher(IMessageDispatcher dispatcher) {\r\n        super(dispatcher);\r\n        this.filter = dispatcher.getContext().getHandlerMetadata().getFilter();\r\n    }\r\n\r\n    private boolean passesFilter(Object message) {\r\n\r\n        if (filter == null) {\r\n            return true;\r\n        } else {\r\n            for (IMessageFilter aFilter : filter) {\r\n                if (!aFilter.accepts(message, getContext().getHandlerMetadata())) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void dispatch(MessagePublication publication, Object message, Iterable listeners){\r\n        if (passesFilter(message)) {\r\n            getDelegate().dispatch(publication, message, listeners);\r\n        }\r\n    }\r\n\r\n}\r\n","src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":"package net.engio.mbassy.dispatch.el;\r\n\r\nimport net.engio.mbassy.listener.IMessageFilter;\r\nimport net.engio.mbassy.listener.MessageHandler;\r\n\r\nimport javax.el.ExpressionFactory;\r\nimport javax.el.ValueExpression;\r\n\r\n/*****************************************************************************\r\n * A filter that will use a expression from the handler annotation and \r\n * parse it as EL.\r\n ****************************************************************************/\r\n\r\npublic class ElFilter implements IMessageFilter {\r\n\r\n    // thread-safe initialization of EL factory singleton\r\n    public static final class ExpressionFactoryHolder{\r\n\r\n        // if runtime exception is thrown, this will\r\n        public static final ExpressionFactory ELFactory = getELFactory();\r\n\r\n        /*************************************************************************\r\n         * Get an implementation of the ExpressionFactory. This uses the\r\n         * Java service lookup mechanism to find a proper implementation.\r\n         * If none if available we do not support EL filters.\r\n         ************************************************************************/\r\n        private static final ExpressionFactory getELFactory(){\r\n            try {\r\n                return ExpressionFactory.newInstance();\r\n            } catch (RuntimeException e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static final boolean isELAvailable(){\r\n        return ExpressionFactoryHolder.ELFactory != null;\r\n    }\r\n\r\n    public static final ExpressionFactory ELFactory(){\r\n        return ExpressionFactoryHolder.ELFactory;\r\n    }\r\n\r\n    /**\r\n     * Accepts a message if the associated EL expression of the message handler resolves to 'true'\r\n     *\r\n     * @param message the message to be handled by the handler\r\n     * @param  metadata the metadata object which describes the message handler\r\n     * @return\r\n     */\r\n\t@Override\r\n\tpublic boolean accepts(Object message, MessageHandler metadata) {\r\n\t\tString expression = metadata.getCondition();\r\n\t\tStandardELResolutionContext context = new StandardELResolutionContext(message);\r\n\t\treturn evalExpression(expression, context);\r\n\t}\r\n\r\n\tprivate boolean evalExpression(String expression, StandardELResolutionContext context) {\r\n\t\tValueExpression ve = ELFactory().createValueExpression(context, expression, Boolean.class);\r\n\t\ttry{\r\n            Object result = ve.getValue(context);\r\n            return (Boolean)result;\r\n             }\r\n        catch(Throwable exception){\r\n            // TODO: BusRuntime should be available in this filter to propagate resolution errors\r\n            // -> this is generally a good feature for filters\r\n            return false;\r\n            //throw new IllegalStateException(\"A handler uses an EL filter but the output is not \\\"true\\\" or \\\"false\\\".\");\r\n        }\r\n\t}\r\n\r\n}\r\n","src/test/java/net/engio/mbassy/ConditionTest.java":"package net.engio.mbassy;\r\n\r\nimport net.engio.mbassy.bus.MBassador;\r\nimport net.engio.mbassy.bus.config.BusConfiguration;\r\nimport net.engio.mbassy.common.MessageBusTest;\r\nimport net.engio.mbassy.listener.Enveloped;\r\nimport net.engio.mbassy.listener.Handler;\r\nimport net.engio.mbassy.listener.Listener;\r\nimport net.engio.mbassy.listener.References;\r\nimport net.engio.mbassy.subscription.MessageEnvelope;\r\nimport org.junit.Test;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n/*****************************************************************************\r\n * Some unit tests for the \"condition\" filter.\r\n ****************************************************************************/\r\n\r\npublic class ConditionTest extends MessageBusTest {\r\n\r\n\tpublic static class TestEvent {\r\n\r\n\t\tprivate Set<String> handledBy = new HashSet<String>();\r\n\t\tprivate String type;\r\n\t\tprivate int size;\r\n\r\n\t\tpublic TestEvent(String type, int size) {\r\n\t\t\tsuper();\r\n\t\t\tthis.type = type;\r\n\t\t\tthis.size = size;\r\n\t\t}\r\n\t\t\r\n\t\tpublic String getType() {\r\n\t\t\treturn type;\r\n\t\t}\r\n\r\n\t\tpublic int getSize() {\r\n\t\t\treturn size;\r\n\t\t}\r\n\r\n        public boolean wasHandledBy(String ...handlers){\r\n            for(String handler : handlers){\r\n                if (!handledBy.contains(handler)) return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public void handledBy(String handler){\r\n            handledBy.add(handler);\r\n        }\r\n\t\t\r\n\t}\r\n\r\n    @Listener(references = References.Strong)\r\n\tpublic static class ConditionalMessageListener {\r\n\r\n\t\t@Handler(condition = \"msg.type == 'TEST'\")\r\n\t\tpublic void handleTypeMessage(TestEvent message) {\r\n\t\t\tmessage.handledBy(\"handleTypeMessage\");\r\n\t\t}\r\n\r\n\t\t@Handler(condition = \"msg.size > 4\")\r\n\t\tpublic void handleSizeMessage(TestEvent message) {\r\n\t\t\tmessage.handledBy(\"handleSizeMessage\");\r\n\t\t}\r\n\r\n        @Handler(condition = \"msg.foo > 4\")\r\n        public void handleInvalidEL(TestEvent message) {\r\n            message.handledBy(\"handleInvalidEL\");\r\n        }\r\n\t\t\r\n\t\t@Handler(condition = \"msg.size > 2 && msg.size < 4\")\r\n\t\tpublic void handleCombinedEL(TestEvent message) {\r\n\t\t\tmessage.handledBy( \"handleCombinedEL\");\r\n\t\t}\r\n\t\t\r\n\t\t@Handler(condition = \"msg.getType().equals('XYZ') && msg.getSize() == 1\")\r\n\t\tpublic void handleMethodAccessEL(TestEvent message) {\r\n\t\t\tmessage.handledBy(\"handleMethodAccessEL\");\r\n\t\t}\r\n\r\n        @Handler(condition = \"msg.type == 'TEST'\")\r\n        @Enveloped(messages = {TestEvent.class, Object.class})\r\n        public void handleEnvelopedMessage(MessageEnvelope envelope) {\r\n            envelope.<TestEvent>getMessage().handledBy(\"handleEnvelopedMessage\");\r\n        }\r\n\t\t\r\n\t}\r\n\r\n\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testSimpleStringCondition() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"TEST\", 0);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertTrue(message.wasHandledBy(\"handleTypeMessage\", \"handleEnvelopedMessage\"));\r\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n\t}\r\n\r\n\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testSimpleNumberCondition() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"\", 5);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertTrue(message.wasHandledBy(\"handleSizeMessage\"));\r\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testHandleCombinedEL() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"\", 3);\r\n\t\tbus.publish(message);\r\n\r\n        assertTrue(message.wasHandledBy(\"handleCombinedEL\"));\r\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testNotMatchingAnyCondition() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"\", 0);\r\n\t\tbus.publish(message);\r\n\r\n\t\tassertTrue(message.handledBy.isEmpty());\r\n\t}\r\n\t\r\n\t/*************************************************************************\r\n\t * @throws Exception\r\n\t ************************************************************************/\r\n\t@Test\r\n\tpublic void testHandleMethodAccessEL() throws Exception {\r\n\t\tMBassador bus = getBus(BusConfiguration.Default());\r\n\t\tbus.subscribe(new ConditionalMessageListener());\r\n\r\n\t\tTestEvent message = new TestEvent(\"XYZ\", 1);\r\n\t\tbus.publish(message);\r\n\r\n        assertTrue(message.wasHandledBy(\"handleMethodAccessEL\"));\r\n        assertFalse(message.wasHandledBy(\"handleInvalidEL\"));\r\n\r\n    }\r\n\r\n}\r\n"},"preChangeRange":{"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[54,54],[55,55]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[41,41]],"src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":[[54,54],[55,55],[60,62],[63,66],[68,68],[70,70],[71,71]],"src/test/java/net/engio/mbassy/ConditionTest.java":[[116,116],[74,74],[52,52],[88,88],[42,42],[47,47],[130,130],[57,57],[102,102]]},"postChangeRange":{"src/main/java/net/engio/mbassy/listener/MessageHandler.java":[[48,50],[59,70],[71,71],[72,72]],"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java":[[40,40]],"src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java":[[45,45],[47,47],[48,48],[49,49],[54,54]],"src/test/java/net/engio/mbassy/ConditionTest.java":[[149,149],[103,103],[104,104],[75,75],[119,119],[120,120],[60,60],[65,65],[163,163],[164,164],[80,80],[134,134],[135,135]]},"microChanges":[{"type":"SimplifyConditional","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java","startLine":41,"endLine":41}],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/dispatch/FilteredMessageDispatcher.java","startLine":40,"endLine":40}]},{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java","startLine":60,"endLine":60}],"rightSideLocations":[]},{"type":"RemoveConditionBlock","leftSideLocations":[{"path":"src/main/java/net/engio/mbassy/dispatch/el/ElFilter.java","startLine":63,"endLine":63}],"rightSideLocations":[]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":48,"endLine":48}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":59,"endLine":59},{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":60,"endLine":60}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":59,"endLine":59}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":59,"endLine":59}]},{"type":"InsertConditionBlock","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":60,"endLine":60}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":59,"endLine":59}]},{"type":"EncapsulateInCondition","leftSideLocations":[],"rightSideLocations":[{"path":"src/main/java/net/engio/mbassy/listener/MessageHandler.java","startLine":60,"endLine":60}]}],"refactorings":[]}]